<html>
<head>
<title>threadpoolctl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
threadpoolctl.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;threadpoolctl 
 
This module provides utilities to introspect native libraries that relies on 
thread pools (notably BLAS and OpenMP implementations) and dynamically set the 
maximal number of threads they can use. 
&quot;&quot;&quot;</span>
<span class="s2"># License: BSD 3-Clause</span>

<span class="s2"># The code to introspect dynamically loaded libraries on POSIX systems is</span>
<span class="s2"># adapted from code by Intel developer @anton-malakhov available at</span>
<span class="s2"># https://github.com/IntelPython/smp (Copyright (c) 2017, Intel Corporation)</span>
<span class="s2"># and also published under the BSD 3-Clause license</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">ctypes</span>
<span class="s3">import </span><span class="s1">textwrap</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">ctypes.util </span><span class="s3">import </span><span class="s1">find_library</span>
<span class="s3">from </span><span class="s1">abc </span><span class="s3">import </span><span class="s1">ABC</span><span class="s3">, </span><span class="s1">abstractmethod</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">lru_cache</span>
<span class="s3">from </span><span class="s1">contextlib </span><span class="s3">import </span><span class="s1">ContextDecorator</span>

<span class="s1">__version__ = </span><span class="s4">&quot;3.1.0&quot;</span>
<span class="s1">__all__ = [</span><span class="s4">&quot;threadpool_limits&quot;</span><span class="s3">, </span><span class="s4">&quot;threadpool_info&quot;</span><span class="s3">, </span><span class="s4">&quot;ThreadpoolController&quot;</span><span class="s1">]</span>


<span class="s2"># One can get runtime errors or even segfaults due to multiple OpenMP libraries</span>
<span class="s2"># loaded simultaneously which can happen easily in Python when importing and</span>
<span class="s2"># using compiled extensions built with different compilers and therefore</span>
<span class="s2"># different OpenMP runtimes in the same program. In particular libiomp (used by</span>
<span class="s2"># Intel ICC) and libomp used by clang/llvm tend to crash. This can happen for</span>
<span class="s2"># instance when calling BLAS inside a prange. Setting the following environment</span>
<span class="s2"># variable allows multiple OpenMP libraries to be loaded. It should not degrade</span>
<span class="s2"># performances since we manually take care of potential over-subscription</span>
<span class="s2"># performance issues, in sections of the code where nested OpenMP loops can</span>
<span class="s2"># happen, by dynamically reconfiguring the inner OpenMP runtime to temporarily</span>
<span class="s2"># disable it while under the scope of the outer OpenMP parallel section.</span>
<span class="s1">os.environ.setdefault(</span><span class="s4">&quot;KMP_DUPLICATE_LIB_OK&quot;</span><span class="s3">, </span><span class="s4">&quot;True&quot;</span><span class="s1">)</span>

<span class="s2"># Structure to cast the info on dynamically loaded library. See</span>
<span class="s2"># https://linux.die.net/man/3/dl_iterate_phdr for more details.</span>
<span class="s1">_SYSTEM_UINT = ctypes.c_uint64 </span><span class="s3">if </span><span class="s1">sys.maxsize &gt; </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">32 </span><span class="s3">else </span><span class="s1">ctypes.c_uint32</span>
<span class="s1">_SYSTEM_UINT_HALF = ctypes.c_uint32 </span><span class="s3">if </span><span class="s1">sys.maxsize &gt; </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">32 </span><span class="s3">else </span><span class="s1">ctypes.c_uint16</span>


<span class="s3">class </span><span class="s1">_dl_phdr_info(ctypes.Structure):</span>
    <span class="s1">_fields_ = [</span>
        <span class="s1">(</span><span class="s4">&quot;dlpi_addr&quot;</span><span class="s3">, </span><span class="s1">_SYSTEM_UINT)</span><span class="s3">,  </span><span class="s2"># Base address of object</span>
        <span class="s1">(</span><span class="s4">&quot;dlpi_name&quot;</span><span class="s3">, </span><span class="s1">ctypes.c_char_p)</span><span class="s3">,  </span><span class="s2"># path to the library</span>
        <span class="s1">(</span><span class="s4">&quot;dlpi_phdr&quot;</span><span class="s3">, </span><span class="s1">ctypes.c_void_p)</span><span class="s3">,  </span><span class="s2"># pointer on dlpi_headers</span>
        <span class="s1">(</span><span class="s4">&quot;dlpi_phnum&quot;</span><span class="s3">, </span><span class="s1">_SYSTEM_UINT_HALF)</span><span class="s3">,  </span><span class="s2"># number of elements in dlpi_phdr</span>
    <span class="s1">]</span>


<span class="s2"># The RTLD_NOLOAD flag for loading shared libraries is not defined on Windows.</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s1">_RTLD_NOLOAD = os.RTLD_NOLOAD</span>
<span class="s3">except </span><span class="s1">AttributeError:</span>
    <span class="s1">_RTLD_NOLOAD = ctypes.DEFAULT_MODE</span>


<span class="s2"># List of the supported libraries. The items are indexed by the name of the</span>
<span class="s2"># class to instantiate to create the library controller objects. The items hold</span>
<span class="s2"># the possible prefixes of loaded shared objects, the name of the internal_api</span>
<span class="s2"># to call, the name of the user_api and potentially some symbols that the library is</span>
<span class="s2"># expected to have (this is necessary to distinguish between the blas implementations</span>
<span class="s2"># when they are all renamed &quot;libblas.dll&quot; on conda-forge on windows).</span>
<span class="s1">_SUPPORTED_LIBRARIES = {</span>
    <span class="s4">&quot;OpenMPController&quot;</span><span class="s1">: {</span>
        <span class="s4">&quot;user_api&quot;</span><span class="s1">: </span><span class="s4">&quot;openmp&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;internal_api&quot;</span><span class="s1">: </span><span class="s4">&quot;openmp&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;filename_prefixes&quot;</span><span class="s1">: (</span><span class="s4">&quot;libiomp&quot;</span><span class="s3">, </span><span class="s4">&quot;libgomp&quot;</span><span class="s3">, </span><span class="s4">&quot;libomp&quot;</span><span class="s3">, </span><span class="s4">&quot;vcomp&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s4">&quot;OpenBLASController&quot;</span><span class="s1">: {</span>
        <span class="s4">&quot;user_api&quot;</span><span class="s1">: </span><span class="s4">&quot;blas&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;internal_api&quot;</span><span class="s1">: </span><span class="s4">&quot;openblas&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;filename_prefixes&quot;</span><span class="s1">: (</span><span class="s4">&quot;libopenblas&quot;</span><span class="s3">, </span><span class="s4">&quot;libblas&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s4">&quot;check_symbols&quot;</span><span class="s1">: (</span><span class="s4">&quot;openblas_get_num_threads&quot;</span><span class="s3">, </span><span class="s4">&quot;openblas_get_num_threads64_&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s4">&quot;MKLController&quot;</span><span class="s1">: {</span>
        <span class="s4">&quot;user_api&quot;</span><span class="s1">: </span><span class="s4">&quot;blas&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;internal_api&quot;</span><span class="s1">: </span><span class="s4">&quot;mkl&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;filename_prefixes&quot;</span><span class="s1">: (</span><span class="s4">&quot;libmkl_rt&quot;</span><span class="s3">, </span><span class="s4">&quot;mkl_rt&quot;</span><span class="s3">, </span><span class="s4">&quot;libblas&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s4">&quot;check_symbols&quot;</span><span class="s1">: (</span><span class="s4">&quot;MKL_Get_Max_Threads&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s4">&quot;BLISController&quot;</span><span class="s1">: {</span>
        <span class="s4">&quot;user_api&quot;</span><span class="s1">: </span><span class="s4">&quot;blas&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;internal_api&quot;</span><span class="s1">: </span><span class="s4">&quot;blis&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;filename_prefixes&quot;</span><span class="s1">: (</span><span class="s4">&quot;libblis&quot;</span><span class="s3">, </span><span class="s4">&quot;libblas&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s4">&quot;check_symbols&quot;</span><span class="s1">: (</span><span class="s4">&quot;bli_thread_get_num_threads&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s2"># Helpers for the doc and test names</span>
<span class="s1">_ALL_USER_APIS = list(set(lib[</span><span class="s4">&quot;user_api&quot;</span><span class="s1">] </span><span class="s3">for </span><span class="s1">lib </span><span class="s3">in </span><span class="s1">_SUPPORTED_LIBRARIES.values()))</span>
<span class="s1">_ALL_INTERNAL_APIS = [lib[</span><span class="s4">&quot;internal_api&quot;</span><span class="s1">] </span><span class="s3">for </span><span class="s1">lib </span><span class="s3">in </span><span class="s1">_SUPPORTED_LIBRARIES.values()]</span>
<span class="s1">_ALL_PREFIXES = list(</span>
    <span class="s1">set(</span>
        <span class="s1">prefix</span>
        <span class="s3">for </span><span class="s1">lib </span><span class="s3">in </span><span class="s1">_SUPPORTED_LIBRARIES.values()</span>
        <span class="s3">for </span><span class="s1">prefix </span><span class="s3">in </span><span class="s1">lib[</span><span class="s4">&quot;filename_prefixes&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
<span class="s1">)</span>
<span class="s1">_ALL_BLAS_LIBRARIES = [</span>
    <span class="s1">lib[</span><span class="s4">&quot;internal_api&quot;</span><span class="s1">]</span>
    <span class="s3">for </span><span class="s1">lib </span><span class="s3">in </span><span class="s1">_SUPPORTED_LIBRARIES.values()</span>
    <span class="s3">if </span><span class="s1">lib[</span><span class="s4">&quot;user_api&quot;</span><span class="s1">] == </span><span class="s4">&quot;blas&quot;</span>
<span class="s1">]</span>
<span class="s1">_ALL_OPENMP_LIBRARIES = list(</span>
    <span class="s1">_SUPPORTED_LIBRARIES[</span><span class="s4">&quot;OpenMPController&quot;</span><span class="s1">][</span><span class="s4">&quot;filename_prefixes&quot;</span><span class="s1">]</span>
<span class="s1">)</span>


<span class="s3">def </span><span class="s1">_format_docstring(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s3">def </span><span class="s1">decorator(o):</span>
        <span class="s3">if </span><span class="s1">o.__doc__ </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">o.__doc__ = o.__doc__.format(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">return </span><span class="s1">o</span>

    <span class="s3">return </span><span class="s1">decorator</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s5">10000</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">_realpath(filepath):</span>
    <span class="s0">&quot;&quot;&quot;Small caching wrapper around os.path.realpath to limit system calls&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">os.path.realpath(filepath)</span>


<span class="s1">@_format_docstring(USER_APIS=list(_ALL_USER_APIS)</span><span class="s3">, </span><span class="s1">INTERNAL_APIS=_ALL_INTERNAL_APIS)</span>
<span class="s3">def </span><span class="s1">threadpool_info():</span>
    <span class="s0">&quot;&quot;&quot;Return the maximal number of threads for each detected library. 
 
    Return a list with all the supported libraries that have been found. Each 
    library is represented by a dict with the following information: 
 
      - &quot;user_api&quot; : user API. Possible values are {USER_APIS}. 
      - &quot;internal_api&quot;: internal API. Possible values are {INTERNAL_APIS}. 
      - &quot;prefix&quot; : filename prefix of the specific implementation. 
      - &quot;filepath&quot;: path to the loaded library. 
      - &quot;version&quot;: version of the library (if available). 
      - &quot;num_threads&quot;: the current thread limit. 
 
    In addition, each library may contain internal_api specific entries. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">ThreadpoolController().info()</span>


<span class="s3">class </span><span class="s1">_ThreadpoolLimiter:</span>
    <span class="s0">&quot;&quot;&quot;The guts of ThreadpoolController.limit 
 
    Refer to the docstring of ThreadpoolController.limit for more details. 
 
    It will only act on the library controllers held by the provided `controller`. 
    Using the default constructor sets the limits right away such that it can be used as 
    a callable. Setting the limits can be delayed by using the `wrap` class method such 
    that it can be used as a decorator. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">controller</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">user_api=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self._controller = controller</span>
        <span class="s1">self._limits</span><span class="s3">, </span><span class="s1">self._user_api</span><span class="s3">, </span><span class="s1">self._prefixes = self._check_params(</span>
            <span class="s1">limits</span><span class="s3">, </span><span class="s1">user_api</span>
        <span class="s1">)</span>
        <span class="s1">self._original_info = self._controller.info()</span>
        <span class="s1">self._set_threadpool_limits()</span>

    <span class="s3">def </span><span class="s1">__enter__(self):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">traceback):</span>
        <span class="s1">self.restore_original_limits()</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">wrap(cls</span><span class="s3">, </span><span class="s1">controller</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">user_api=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return an instance of this class that can be used as a decorator&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">_ThreadpoolLimiterDecorator(</span>
            <span class="s1">controller=controller</span><span class="s3">, </span><span class="s1">limits=limits</span><span class="s3">, </span><span class="s1">user_api=user_api</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">restore_original_limits(self):</span>
        <span class="s0">&quot;&quot;&quot;Set the limits back to their original values&quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">lib_controller</span><span class="s3">, </span><span class="s1">original_info </span><span class="s3">in </span><span class="s1">zip(</span>
            <span class="s1">self._controller.lib_controllers</span><span class="s3">, </span><span class="s1">self._original_info</span>
        <span class="s1">):</span>
            <span class="s1">lib_controller.set_num_threads(original_info[</span><span class="s4">&quot;num_threads&quot;</span><span class="s1">])</span>

    <span class="s2"># Alias of `restore_original_limits` for backward compatibility</span>
    <span class="s1">unregister = restore_original_limits</span>

    <span class="s3">def </span><span class="s1">get_original_num_threads(self):</span>
        <span class="s0">&quot;&quot;&quot;Original num_threads from before calling threadpool_limits 
 
        Return a dict `{user_api: num_threads}`. 
        &quot;&quot;&quot;</span>
        <span class="s1">num_threads = {}</span>
        <span class="s1">warning_apis = []</span>

        <span class="s3">for </span><span class="s1">user_api </span><span class="s3">in </span><span class="s1">self._user_api:</span>
            <span class="s1">limits = [</span>
                <span class="s1">lib_info[</span><span class="s4">&quot;num_threads&quot;</span><span class="s1">]</span>
                <span class="s3">for </span><span class="s1">lib_info </span><span class="s3">in </span><span class="s1">self._original_info</span>
                <span class="s3">if </span><span class="s1">lib_info[</span><span class="s4">&quot;user_api&quot;</span><span class="s1">] == user_api</span>
            <span class="s1">]</span>
            <span class="s1">limits = set(limits)</span>
            <span class="s1">n_limits = len(limits)</span>

            <span class="s3">if </span><span class="s1">n_limits == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">limit = limits.pop()</span>
            <span class="s3">elif </span><span class="s1">n_limits == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">limit = </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">limit = min(limits)</span>
                <span class="s1">warning_apis.append(user_api)</span>

            <span class="s1">num_threads[user_api] = limit</span>

        <span class="s3">if </span><span class="s1">warning_apis:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;Multiple value possible for following user apis: &quot;</span>
                <span class="s1">+ </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(warning_apis)</span>
                <span class="s1">+ </span><span class="s4">&quot;. Returning the minimum.&quot;</span>
            <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">num_threads</span>

    <span class="s3">def </span><span class="s1">_check_params(self</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">, </span><span class="s1">user_api):</span>
        <span class="s0">&quot;&quot;&quot;Suitable values for the _limits, _user_api and _prefixes attributes&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">isinstance(limits</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">and </span><span class="s1">limits == </span><span class="s4">&quot;sequential_blas_under_openmp&quot;</span><span class="s1">:</span>
            <span class="s1">(</span>
                <span class="s1">limits</span><span class="s3">,</span>
                <span class="s1">user_api</span><span class="s3">,</span>
            <span class="s1">) = self._controller._get_params_for_sequential_blas_under_openmp().values()</span>

        <span class="s3">if </span><span class="s1">limits </span><span class="s3">is None or </span><span class="s1">isinstance(limits</span><span class="s3">, </span><span class="s1">int):</span>
            <span class="s3">if </span><span class="s1">user_api </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">user_api = _ALL_USER_APIS</span>
            <span class="s3">elif </span><span class="s1">user_api </span><span class="s3">in </span><span class="s1">_ALL_USER_APIS:</span>
                <span class="s1">user_api = [user_api]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;user_api must be either in </span><span class="s3">{</span><span class="s1">_ALL_USER_APIS</span><span class="s3">} </span><span class="s4">or None. Got &quot;</span>
                    <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">user_api</span><span class="s3">} </span><span class="s4">instead.&quot;</span>
                <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">limits </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">limits = {api: limits </span><span class="s3">for </span><span class="s1">api </span><span class="s3">in </span><span class="s1">user_api}</span>
            <span class="s1">prefixes = []</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">isinstance(limits</span><span class="s3">, </span><span class="s1">list):</span>
                <span class="s2"># This should be a list of dicts of library info, for</span>
                <span class="s2"># compatibility with the result from threadpool_info.</span>
                <span class="s1">limits = {</span>
                    <span class="s1">lib_info[</span><span class="s4">&quot;prefix&quot;</span><span class="s1">]: lib_info[</span><span class="s4">&quot;num_threads&quot;</span><span class="s1">] </span><span class="s3">for </span><span class="s1">lib_info </span><span class="s3">in </span><span class="s1">limits</span>
                <span class="s1">}</span>
            <span class="s3">elif </span><span class="s1">isinstance(limits</span><span class="s3">, </span><span class="s1">ThreadpoolController):</span>
                <span class="s2"># To set the limits from the library controllers of a</span>
                <span class="s2"># ThreadpoolController object.</span>
                <span class="s1">limits = {</span>
                    <span class="s1">lib_controller.prefix: lib_controller.num_threads</span>
                    <span class="s3">for </span><span class="s1">lib_controller </span><span class="s3">in </span><span class="s1">limits.lib_controllers</span>
                <span class="s1">}</span>

            <span class="s3">if not </span><span class="s1">isinstance(limits</span><span class="s3">, </span><span class="s1">dict):</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;limits must either be an int, a list, a dict, or &quot;</span>
                    <span class="s4">f&quot;'sequential_blas_under_openmp'. Got </span><span class="s3">{</span><span class="s1">type(limits)</span><span class="s3">} </span><span class="s4">instead&quot;</span>
                <span class="s1">)</span>

            <span class="s2"># With a dictionary, can set both specific limit for given</span>
            <span class="s2"># libraries and global limit for user_api. Fetch each separately.</span>
            <span class="s1">prefixes = [prefix </span><span class="s3">for </span><span class="s1">prefix </span><span class="s3">in </span><span class="s1">limits </span><span class="s3">if </span><span class="s1">prefix </span><span class="s3">in </span><span class="s1">_ALL_PREFIXES]</span>
            <span class="s1">user_api = [api </span><span class="s3">for </span><span class="s1">api </span><span class="s3">in </span><span class="s1">limits </span><span class="s3">if </span><span class="s1">api </span><span class="s3">in </span><span class="s1">_ALL_USER_APIS]</span>

        <span class="s3">return </span><span class="s1">limits</span><span class="s3">, </span><span class="s1">user_api</span><span class="s3">, </span><span class="s1">prefixes</span>

    <span class="s3">def </span><span class="s1">_set_threadpool_limits(self):</span>
        <span class="s0">&quot;&quot;&quot;Change the maximal number of threads in selected thread pools. 
 
        Return a list with all the supported libraries that have been found 
        matching `self._prefixes` and `self._user_api`. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._limits </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s3">for </span><span class="s1">lib_controller </span><span class="s3">in </span><span class="s1">self._controller.lib_controllers:</span>
            <span class="s2"># self._limits is a dict {key: num_threads} where key is either</span>
            <span class="s2"># a prefix or a user_api. If a library matches both, the limit</span>
            <span class="s2"># corresponding to the prefix is chosen.</span>
            <span class="s3">if </span><span class="s1">lib_controller.prefix </span><span class="s3">in </span><span class="s1">self._limits:</span>
                <span class="s1">num_threads = self._limits[lib_controller.prefix]</span>
            <span class="s3">elif </span><span class="s1">lib_controller.user_api </span><span class="s3">in </span><span class="s1">self._limits:</span>
                <span class="s1">num_threads = self._limits[lib_controller.user_api]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">num_threads </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">lib_controller.set_num_threads(num_threads)</span>


<span class="s3">class </span><span class="s1">_ThreadpoolLimiterDecorator(_ThreadpoolLimiter</span><span class="s3">, </span><span class="s1">ContextDecorator):</span>
    <span class="s0">&quot;&quot;&quot;Same as _ThreadpoolLimiter but to be used as a decorator&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">controller</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">user_api=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self._limits</span><span class="s3">, </span><span class="s1">self._user_api</span><span class="s3">, </span><span class="s1">self._prefixes = self._check_params(</span>
            <span class="s1">limits</span><span class="s3">, </span><span class="s1">user_api</span>
        <span class="s1">)</span>
        <span class="s1">self._controller = controller</span>

    <span class="s3">def </span><span class="s1">__enter__(self):</span>
        <span class="s2"># we need to set the limits here and not in the __init__ because we want the</span>
        <span class="s2"># limits to be set when calling the decorated function, not when creating the</span>
        <span class="s2"># decorator.</span>
        <span class="s1">self._original_info = self._controller.info()</span>
        <span class="s1">self._set_threadpool_limits()</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s1">@_format_docstring(</span>
    <span class="s1">USER_APIS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">f'&quot;</span><span class="s3">{</span><span class="s1">api</span><span class="s3">}</span><span class="s4">&quot;' </span><span class="s3">for </span><span class="s1">api </span><span class="s3">in </span><span class="s1">_ALL_USER_APIS)</span><span class="s3">,</span>
    <span class="s1">BLAS_LIBS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_ALL_BLAS_LIBRARIES)</span><span class="s3">,</span>
    <span class="s1">OPENMP_LIBS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_ALL_OPENMP_LIBRARIES)</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">class </span><span class="s1">threadpool_limits(_ThreadpoolLimiter):</span>
    <span class="s0">&quot;&quot;&quot;Change the maximal number of threads that can be used in thread pools. 
 
    This object can be used either as a callable (the construction of this object 
    limits the number of threads), as a context manager in a `with` block to 
    automatically restore the original state of the controlled libraries when exiting 
    the block, or as a decorator through its `wrap` method. 
 
    Set the maximal number of threads that can be used in thread pools used in 
    the supported libraries to `limit`. This function works for libraries that 
    are already loaded in the interpreter and can be changed dynamically. 
 
    This effect is global and impacts the whole Python process. There is no thread level 
    isolation as these libraries do not offer thread-local APIs to configure the number 
    of threads to use in nested parallel calls. 
 
    Parameters 
    ---------- 
    limits : int, dict, 'sequential_blas_under_openmp' or None (default=None) 
        The maximal number of threads that can be used in thread pools 
 
        - If int, sets the maximum number of threads to `limits` for each 
          library selected by `user_api`. 
 
        - If it is a dictionary `{{key: max_threads}}`, this function sets a 
          custom maximum number of threads for each `key` which can be either a 
          `user_api` or a `prefix` for a specific library. 
 
        - If 'sequential_blas_under_openmp', it will chose the appropriate `limits` 
          and `user_api` parameters for the specific use case of sequential BLAS 
          calls within an OpenMP parallel region. The `user_api` parameter is 
          ignored. 
 
        - If None, this function does not do anything. 
 
    user_api : {USER_APIS} or None (default=None) 
        APIs of libraries to limit. Used only if `limits` is an int. 
 
        - If &quot;blas&quot;, it will only limit BLAS supported libraries ({BLAS_LIBS}). 
 
        - If &quot;openmp&quot;, it will only limit OpenMP supported libraries 
          ({OPENMP_LIBS}). Note that it can affect the number of threads used 
          by the BLAS libraries if they rely on OpenMP. 
 
        - If None, this function will apply to all supported libraries. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">user_api=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(ThreadpoolController()</span><span class="s3">, </span><span class="s1">limits=limits</span><span class="s3">, </span><span class="s1">user_api=user_api)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">wrap(cls</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">user_api=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">super().wrap(ThreadpoolController()</span><span class="s3">, </span><span class="s1">limits=limits</span><span class="s3">, </span><span class="s1">user_api=user_api)</span>


<span class="s1">@_format_docstring(</span>
    <span class="s1">PREFIXES=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">f'&quot;</span><span class="s3">{</span><span class="s1">prefix</span><span class="s3">}</span><span class="s4">&quot;' </span><span class="s3">for </span><span class="s1">prefix </span><span class="s3">in </span><span class="s1">_ALL_PREFIXES)</span><span class="s3">,</span>
    <span class="s1">USER_APIS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">f'&quot;</span><span class="s3">{</span><span class="s1">api</span><span class="s3">}</span><span class="s4">&quot;' </span><span class="s3">for </span><span class="s1">api </span><span class="s3">in </span><span class="s1">_ALL_USER_APIS)</span><span class="s3">,</span>
    <span class="s1">BLAS_LIBS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_ALL_BLAS_LIBRARIES)</span><span class="s3">,</span>
    <span class="s1">OPENMP_LIBS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_ALL_OPENMP_LIBRARIES)</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">class </span><span class="s1">ThreadpoolController:</span>
    <span class="s0">&quot;&quot;&quot;Collection of LibController objects for all loaded supported libraries 
 
    Attributes 
    ---------- 
    lib_controllers : list of `LibController` objects 
        The list of library controllers of all loaded supported libraries. 
    &quot;&quot;&quot;</span>

    <span class="s2"># Cache for libc under POSIX and a few system libraries under Windows.</span>
    <span class="s2"># We use a class level cache instead of an instance level cache because</span>
    <span class="s2"># it's very unlikely that a shared library will be unloaded and reloaded</span>
    <span class="s2"># during the lifetime of a program.</span>
    <span class="s1">_system_libraries = dict()</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.lib_controllers = []</span>
        <span class="s1">self._load_libraries()</span>
        <span class="s1">self._warn_if_incompatible_openmp()</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_from_controllers(cls</span><span class="s3">, </span><span class="s1">lib_controllers):</span>
        <span class="s1">new_controller = cls.__new__(cls)</span>
        <span class="s1">new_controller.lib_controllers = lib_controllers</span>
        <span class="s3">return </span><span class="s1">new_controller</span>

    <span class="s3">def </span><span class="s1">info(self):</span>
        <span class="s0">&quot;&quot;&quot;Return lib_controllers info as a list of dicts&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">[lib_controller.info() </span><span class="s3">for </span><span class="s1">lib_controller </span><span class="s3">in </span><span class="s1">self.lib_controllers]</span>

    <span class="s3">def </span><span class="s1">select(self</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Return a ThreadpoolController containing a subset of its current 
        library controllers 
 
        It will select all libraries matching at least one pair (key, value) from kwargs 
        where key is an entry of the library info dict (like &quot;user_api&quot;, &quot;internal_api&quot;, 
        &quot;prefix&quot;, ...) and value is the value or a list of acceptable values for that 
        entry. 
 
        For instance, `ThreadpoolController().select(internal_api=[&quot;blis&quot;, &quot;openblas&quot;])` 
        will select all library controllers whose internal_api is either &quot;blis&quot; or 
        &quot;openblas&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">vals </span><span class="s3">in </span><span class="s1">kwargs.items():</span>
            <span class="s1">kwargs[key] = [vals] </span><span class="s3">if not </span><span class="s1">isinstance(vals</span><span class="s3">, </span><span class="s1">list) </span><span class="s3">else </span><span class="s1">vals</span>

        <span class="s1">lib_controllers = [</span>
            <span class="s1">lib_controller</span>
            <span class="s3">for </span><span class="s1">lib_controller </span><span class="s3">in </span><span class="s1">self.lib_controllers</span>
            <span class="s3">if </span><span class="s1">any(</span>
                <span class="s1">getattr(lib_controller</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">in </span><span class="s1">vals</span>
                <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">vals </span><span class="s3">in </span><span class="s1">kwargs.items()</span>
            <span class="s1">)</span>
        <span class="s1">]</span>

        <span class="s3">return </span><span class="s1">ThreadpoolController._from_controllers(lib_controllers)</span>

    <span class="s3">def </span><span class="s1">_get_params_for_sequential_blas_under_openmp(self):</span>
        <span class="s0">&quot;&quot;&quot;Return appropriate params to use for a sequential BLAS call in an OpenMP loop 
 
        This function takes into account the unexpected behavior of OpenBLAS with the 
        OpenMP threading layer. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.select(</span>
            <span class="s1">internal_api=</span><span class="s4">&quot;openblas&quot;</span><span class="s3">, </span><span class="s1">threading_layer=</span><span class="s4">&quot;openmp&quot;</span>
        <span class="s1">).lib_controllers:</span>
            <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;limits&quot;</span><span class="s1">: </span><span class="s3">None, </span><span class="s4">&quot;user_api&quot;</span><span class="s1">: </span><span class="s3">None</span><span class="s1">}</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;limits&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;user_api&quot;</span><span class="s1">: </span><span class="s4">&quot;blas&quot;</span><span class="s1">}</span>

    <span class="s1">@_format_docstring(</span>
        <span class="s1">USER_APIS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">'&quot;{}&quot;'</span><span class="s1">.format(api) </span><span class="s3">for </span><span class="s1">api </span><span class="s3">in </span><span class="s1">_ALL_USER_APIS)</span><span class="s3">,</span>
        <span class="s1">BLAS_LIBS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_ALL_BLAS_LIBRARIES)</span><span class="s3">,</span>
        <span class="s1">OPENMP_LIBS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_ALL_OPENMP_LIBRARIES)</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">def </span><span class="s1">limit(self</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">user_api=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Change the maximal number of threads that can be used in thread pools. 
 
        This function returns an object that can be used either as a callable (the 
        construction of this object limits the number of threads) or as a context 
        manager, in a `with` block to automatically restore the original state of the 
        controlled libraries when exiting the block. 
 
        Set the maximal number of threads that can be used in thread pools used in 
        the supported libraries to `limits`. This function works for libraries that 
        are already loaded in the interpreter and can be changed dynamically. 
 
        This effect is global and impacts the whole Python process. There is no thread 
        level isolation as these libraries do not offer thread-local APIs to configure 
        the number of threads to use in nested parallel calls. 
 
        Parameters 
        ---------- 
        limits : int, dict, 'sequential_blas_under_openmp' or None (default=None) 
            The maximal number of threads that can be used in thread pools 
 
            - If int, sets the maximum number of threads to `limits` for each 
              library selected by `user_api`. 
 
            - If it is a dictionary `{{key: max_threads}}`, this function sets a 
              custom maximum number of threads for each `key` which can be either a 
              `user_api` or a `prefix` for a specific library. 
 
            - If 'sequential_blas_under_openmp', it will chose the appropriate `limits` 
              and `user_api` parameters for the specific use case of sequential BLAS 
              calls within an OpenMP parallel region. The `user_api` parameter is 
              ignored. 
 
            - If None, this function does not do anything. 
 
        user_api : {USER_APIS} or None (default=None) 
            APIs of libraries to limit. Used only if `limits` is an int. 
 
            - If &quot;blas&quot;, it will only limit BLAS supported libraries ({BLAS_LIBS}). 
 
            - If &quot;openmp&quot;, it will only limit OpenMP supported libraries 
              ({OPENMP_LIBS}). Note that it can affect the number of threads used 
              by the BLAS libraries if they rely on OpenMP. 
 
            - If None, this function will apply to all supported libraries. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">_ThreadpoolLimiter(self</span><span class="s3">, </span><span class="s1">limits=limits</span><span class="s3">, </span><span class="s1">user_api=user_api)</span>

    <span class="s1">@_format_docstring(</span>
        <span class="s1">USER_APIS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">'&quot;{}&quot;'</span><span class="s1">.format(api) </span><span class="s3">for </span><span class="s1">api </span><span class="s3">in </span><span class="s1">_ALL_USER_APIS)</span><span class="s3">,</span>
        <span class="s1">BLAS_LIBS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_ALL_BLAS_LIBRARIES)</span><span class="s3">,</span>
        <span class="s1">OPENMP_LIBS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_ALL_OPENMP_LIBRARIES)</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">def </span><span class="s1">wrap(self</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">user_api=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Change the maximal number of threads that can be used in thread pools. 
 
        This function returns an object that can be used as a decorator. 
 
        Set the maximal number of threads that can be used in thread pools used in 
        the supported libraries to `limits`. This function works for libraries that 
        are already loaded in the interpreter and can be changed dynamically. 
 
        Parameters 
        ---------- 
        limits : int, dict or None (default=None) 
            The maximal number of threads that can be used in thread pools 
 
            - If int, sets the maximum number of threads to `limits` for each 
              library selected by `user_api`. 
 
            - If it is a dictionary `{{key: max_threads}}`, this function sets a 
              custom maximum number of threads for each `key` which can be either a 
              `user_api` or a `prefix` for a specific library. 
 
            - If None, this function does not do anything. 
 
        user_api : {USER_APIS} or None (default=None) 
            APIs of libraries to limit. Used only if `limits` is an int. 
 
            - If &quot;blas&quot;, it will only limit BLAS supported libraries ({BLAS_LIBS}). 
 
            - If &quot;openmp&quot;, it will only limit OpenMP supported libraries 
              ({OPENMP_LIBS}). Note that it can affect the number of threads used 
              by the BLAS libraries if they rely on OpenMP. 
 
            - If None, this function will apply to all supported libraries. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">_ThreadpoolLimiter.wrap(self</span><span class="s3">, </span><span class="s1">limits=limits</span><span class="s3">, </span><span class="s1">user_api=user_api)</span>

    <span class="s3">def </span><span class="s1">__len__(self):</span>
        <span class="s3">return </span><span class="s1">len(self.lib_controllers)</span>

    <span class="s3">def </span><span class="s1">_load_libraries(self):</span>
        <span class="s0">&quot;&quot;&quot;Loop through loaded shared libraries and store the supported ones&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">&quot;darwin&quot;</span><span class="s1">:</span>
            <span class="s1">self._find_libraries_with_dyld()</span>
        <span class="s3">elif </span><span class="s1">sys.platform == </span><span class="s4">&quot;win32&quot;</span><span class="s1">:</span>
            <span class="s1">self._find_libraries_with_enum_process_module_ex()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._find_libraries_with_dl_iterate_phdr()</span>

    <span class="s3">def </span><span class="s1">_find_libraries_with_dl_iterate_phdr(self):</span>
        <span class="s0">&quot;&quot;&quot;Loop through loaded libraries and return binders on supported ones 
 
        This function is expected to work on POSIX system only. 
        This code is adapted from code by Intel developer @anton-malakhov 
        available at https://github.com/IntelPython/smp 
 
        Copyright (c) 2017, Intel Corporation published under the BSD 3-Clause 
        license 
        &quot;&quot;&quot;</span>
        <span class="s1">libc = self._get_libc()</span>
        <span class="s3">if not </span><span class="s1">hasattr(libc</span><span class="s3">, </span><span class="s4">&quot;dl_iterate_phdr&quot;</span><span class="s1">):  </span><span class="s2"># pragma: no cover</span>
            <span class="s3">return </span><span class="s1">[]</span>

        <span class="s2"># Callback function for `dl_iterate_phdr` which is called for every</span>
        <span class="s2"># library loaded in the current process until it returns 1.</span>
        <span class="s3">def </span><span class="s1">match_library_callback(info</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">data):</span>
            <span class="s2"># Get the path of the current library</span>
            <span class="s1">filepath = info.contents.dlpi_name</span>
            <span class="s3">if </span><span class="s1">filepath:</span>
                <span class="s1">filepath = filepath.decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>

                <span class="s2"># Store the library controller if it is supported and selected</span>
                <span class="s1">self._make_controller_from_path(filepath)</span>
            <span class="s3">return </span><span class="s5">0</span>

        <span class="s1">c_func_signature = ctypes.CFUNCTYPE(</span>
            <span class="s1">ctypes.c_int</span><span class="s3">,  </span><span class="s2"># Return type</span>
            <span class="s1">ctypes.POINTER(_dl_phdr_info)</span><span class="s3">,</span>
            <span class="s1">ctypes.c_size_t</span><span class="s3">,</span>
            <span class="s1">ctypes.c_char_p</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">c_match_library_callback = c_func_signature(match_library_callback)</span>

        <span class="s1">data = ctypes.c_char_p(</span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">libc.dl_iterate_phdr(c_match_library_callback</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">_find_libraries_with_dyld(self):</span>
        <span class="s0">&quot;&quot;&quot;Loop through loaded libraries and return binders on supported ones 
 
        This function is expected to work on OSX system only 
        &quot;&quot;&quot;</span>
        <span class="s1">libc = self._get_libc()</span>
        <span class="s3">if not </span><span class="s1">hasattr(libc</span><span class="s3">, </span><span class="s4">&quot;_dyld_image_count&quot;</span><span class="s1">):  </span><span class="s2"># pragma: no cover</span>
            <span class="s3">return </span><span class="s1">[]</span>

        <span class="s1">n_dyld = libc._dyld_image_count()</span>
        <span class="s1">libc._dyld_get_image_name.restype = ctypes.c_char_p</span>

        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n_dyld):</span>
            <span class="s1">filepath = ctypes.string_at(libc._dyld_get_image_name(i))</span>
            <span class="s1">filepath = filepath.decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>

            <span class="s2"># Store the library controller if it is supported and selected</span>
            <span class="s1">self._make_controller_from_path(filepath)</span>

    <span class="s3">def </span><span class="s1">_find_libraries_with_enum_process_module_ex(self):</span>
        <span class="s0">&quot;&quot;&quot;Loop through loaded libraries and return binders on supported ones 
 
        This function is expected to work on windows system only. 
        This code is adapted from code by Philipp Hagemeister @phihag available 
        at https://stackoverflow.com/questions/17474574 
        &quot;&quot;&quot;</span>
        <span class="s3">from </span><span class="s1">ctypes.wintypes </span><span class="s3">import </span><span class="s1">DWORD</span><span class="s3">, </span><span class="s1">HMODULE</span><span class="s3">, </span><span class="s1">MAX_PATH</span>

        <span class="s1">PROCESS_QUERY_INFORMATION = </span><span class="s5">0x0400</span>
        <span class="s1">PROCESS_VM_READ = </span><span class="s5">0x0010</span>

        <span class="s1">LIST_LIBRARIES_ALL = </span><span class="s5">0x03</span>

        <span class="s1">ps_api = self._get_windll(</span><span class="s4">&quot;Psapi&quot;</span><span class="s1">)</span>
        <span class="s1">kernel_32 = self._get_windll(</span><span class="s4">&quot;kernel32&quot;</span><span class="s1">)</span>

        <span class="s1">h_process = kernel_32.OpenProcess(</span>
            <span class="s1">PROCESS_QUERY_INFORMATION | PROCESS_VM_READ</span><span class="s3">, False, </span><span class="s1">os.getpid()</span>
        <span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">h_process:  </span><span class="s2"># pragma: no cover</span>
            <span class="s3">raise </span><span class="s1">OSError(</span><span class="s4">f&quot;Could not open PID </span><span class="s3">{</span><span class="s1">os.getpid()</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">buf_count = </span><span class="s5">256</span>
            <span class="s1">needed = DWORD()</span>
            <span class="s2"># Grow the buffer until it becomes large enough to hold all the</span>
            <span class="s2"># module headers</span>
            <span class="s3">while True</span><span class="s1">:</span>
                <span class="s1">buf = (HMODULE * buf_count)()</span>
                <span class="s1">buf_size = ctypes.sizeof(buf)</span>
                <span class="s3">if not </span><span class="s1">ps_api.EnumProcessModulesEx(</span>
                    <span class="s1">h_process</span><span class="s3">,</span>
                    <span class="s1">ctypes.byref(buf)</span><span class="s3">,</span>
                    <span class="s1">buf_size</span><span class="s3">,</span>
                    <span class="s1">ctypes.byref(needed)</span><span class="s3">,</span>
                    <span class="s1">LIST_LIBRARIES_ALL</span><span class="s3">,</span>
                <span class="s1">):</span>
                    <span class="s3">raise </span><span class="s1">OSError(</span><span class="s4">&quot;EnumProcessModulesEx failed&quot;</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">buf_size &gt;= needed.value:</span>
                    <span class="s3">break</span>
                <span class="s1">buf_count = needed.value // (buf_size // buf_count)</span>

            <span class="s1">count = needed.value // (buf_size // buf_count)</span>
            <span class="s1">h_modules = map(HMODULE</span><span class="s3">, </span><span class="s1">buf[:count])</span>

            <span class="s2"># Loop through all the module headers and get the library path</span>
            <span class="s1">buf = ctypes.create_unicode_buffer(MAX_PATH)</span>
            <span class="s1">n_size = DWORD()</span>
            <span class="s3">for </span><span class="s1">h_module </span><span class="s3">in </span><span class="s1">h_modules:</span>

                <span class="s2"># Get the path of the current module</span>
                <span class="s3">if not </span><span class="s1">ps_api.GetModuleFileNameExW(</span>
                    <span class="s1">h_process</span><span class="s3">, </span><span class="s1">h_module</span><span class="s3">, </span><span class="s1">ctypes.byref(buf)</span><span class="s3">, </span><span class="s1">ctypes.byref(n_size)</span>
                <span class="s1">):</span>
                    <span class="s3">raise </span><span class="s1">OSError(</span><span class="s4">&quot;GetModuleFileNameEx failed&quot;</span><span class="s1">)</span>
                <span class="s1">filepath = buf.value</span>

                <span class="s2"># Store the library controller if it is supported and selected</span>
                <span class="s1">self._make_controller_from_path(filepath)</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">kernel_32.CloseHandle(h_process)</span>

    <span class="s3">def </span><span class="s1">_make_controller_from_path(self</span><span class="s3">, </span><span class="s1">filepath):</span>
        <span class="s0">&quot;&quot;&quot;Store a library controller if it is supported and selected&quot;&quot;&quot;</span>
        <span class="s2"># Required to resolve symlinks</span>
        <span class="s1">filepath = _realpath(filepath)</span>
        <span class="s2"># `lower` required to take account of OpenMP dll case on Windows</span>
        <span class="s2"># (vcomp, VCOMP, Vcomp, ...)</span>
        <span class="s1">filename = os.path.basename(filepath).lower()</span>

        <span class="s2"># Loop through supported libraries to find if this filename corresponds</span>
        <span class="s2"># to a supported one.</span>
        <span class="s3">for </span><span class="s1">controller_class</span><span class="s3">, </span><span class="s1">candidate_lib </span><span class="s3">in </span><span class="s1">_SUPPORTED_LIBRARIES.items():</span>
            <span class="s2"># check if filename matches a supported prefix</span>
            <span class="s1">prefix = self._check_prefix(filename</span><span class="s3">, </span><span class="s1">candidate_lib[</span><span class="s4">&quot;filename_prefixes&quot;</span><span class="s1">])</span>

            <span class="s2"># filename does not match any of the prefixes of the candidate</span>
            <span class="s2"># library. move to next library.</span>
            <span class="s3">if </span><span class="s1">prefix </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">continue</span>

            <span class="s2"># workaround for BLAS libraries packaged by conda-forge on windows, which</span>
            <span class="s2"># are all renamed &quot;libblas.dll&quot;. We thus have to check to which BLAS</span>
            <span class="s2"># implementation it actually corresponds looking for implementation</span>
            <span class="s2"># specific symbols.</span>
            <span class="s3">if </span><span class="s1">prefix == </span><span class="s4">&quot;libblas&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">filename.endswith(</span><span class="s4">&quot;.dll&quot;</span><span class="s1">):</span>
                    <span class="s1">libblas = ctypes.CDLL(filepath</span><span class="s3">, </span><span class="s1">_RTLD_NOLOAD)</span>
                    <span class="s3">if not </span><span class="s1">any(</span>
                        <span class="s1">hasattr(libblas</span><span class="s3">, </span><span class="s1">func)</span>
                        <span class="s3">for </span><span class="s1">func </span><span class="s3">in </span><span class="s1">candidate_lib[</span><span class="s4">&quot;check_symbols&quot;</span><span class="s1">]</span>
                    <span class="s1">):</span>
                        <span class="s3">continue</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s2"># We ignore libblas on other platforms than windows because there</span>
                    <span class="s2"># might be a libblas dso comming with openblas for instance that</span>
                    <span class="s2"># can't be used to instantiate a pertinent LibController (many</span>
                    <span class="s2"># symbols are missing) and would create confusion by making a</span>
                    <span class="s2"># duplicate entry in threadpool_info.</span>
                    <span class="s3">continue</span>

            <span class="s2"># filename matches a prefix. Create and store the library</span>
            <span class="s2"># controller.</span>
            <span class="s1">user_api = candidate_lib[</span><span class="s4">&quot;user_api&quot;</span><span class="s1">]</span>
            <span class="s1">internal_api = candidate_lib[</span><span class="s4">&quot;internal_api&quot;</span><span class="s1">]</span>

            <span class="s1">lib_controller_class = globals()[controller_class]</span>
            <span class="s1">lib_controller = lib_controller_class(</span>
                <span class="s1">filepath=filepath</span><span class="s3">,</span>
                <span class="s1">prefix=prefix</span><span class="s3">,</span>
                <span class="s1">user_api=user_api</span><span class="s3">,</span>
                <span class="s1">internal_api=internal_api</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">self.lib_controllers.append(lib_controller)</span>

    <span class="s3">def </span><span class="s1">_check_prefix(self</span><span class="s3">, </span><span class="s1">library_basename</span><span class="s3">, </span><span class="s1">filename_prefixes):</span>
        <span class="s0">&quot;&quot;&quot;Return the prefix library_basename starts with 
 
        Return None if none matches. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">prefix </span><span class="s3">in </span><span class="s1">filename_prefixes:</span>
            <span class="s3">if </span><span class="s1">library_basename.startswith(prefix):</span>
                <span class="s3">return </span><span class="s1">prefix</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_warn_if_incompatible_openmp(self):</span>
        <span class="s0">&quot;&quot;&quot;Raise a warning if llvm-OpenMP and intel-OpenMP are both loaded&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">sys.platform != </span><span class="s4">&quot;linux&quot;</span><span class="s1">:</span>
            <span class="s2"># Only raise the warning on linux</span>
            <span class="s3">return</span>

        <span class="s1">prefixes = [lib_controller.prefix </span><span class="s3">for </span><span class="s1">lib_controller </span><span class="s3">in </span><span class="s1">self.lib_controllers]</span>
        <span class="s1">msg = textwrap.dedent(</span>
            <span class="s4">&quot;&quot;&quot; 
            Found Intel OpenMP ('libiomp') and LLVM OpenMP ('libomp') loaded at 
            the same time. Both libraries are known to be incompatible and this 
            can cause random crashes or deadlocks on Linux when loaded in the 
            same Python program. 
            Using threadpoolctl may cause crashes or deadlocks. For more 
            information and possible workarounds, please see 
                https://github.com/joblib/threadpoolctl/blob/master/multiple_openmp.md 
            &quot;&quot;&quot;</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s4">&quot;libomp&quot; </span><span class="s3">in </span><span class="s1">prefixes </span><span class="s3">and </span><span class="s4">&quot;libiomp&quot; </span><span class="s3">in </span><span class="s1">prefixes:</span>
            <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_get_libc(cls):</span>
        <span class="s0">&quot;&quot;&quot;Load the lib-C for unix systems.&quot;&quot;&quot;</span>
        <span class="s1">libc = cls._system_libraries.get(</span><span class="s4">&quot;libc&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">libc </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">libc_name = find_library(</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">libc_name </span><span class="s3">is None</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
                <span class="s3">return None</span>
            <span class="s1">libc = ctypes.CDLL(libc_name</span><span class="s3">, </span><span class="s1">mode=_RTLD_NOLOAD)</span>
            <span class="s1">cls._system_libraries[</span><span class="s4">&quot;libc&quot;</span><span class="s1">] = libc</span>
        <span class="s3">return </span><span class="s1">libc</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_get_windll(cls</span><span class="s3">, </span><span class="s1">dll_name):</span>
        <span class="s0">&quot;&quot;&quot;Load a windows DLL&quot;&quot;&quot;</span>
        <span class="s1">dll = cls._system_libraries.get(dll_name)</span>
        <span class="s3">if </span><span class="s1">dll </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">dll = ctypes.WinDLL(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">dll_name</span><span class="s3">}</span><span class="s4">.dll&quot;</span><span class="s1">)</span>
            <span class="s1">cls._system_libraries[dll_name] = dll</span>
        <span class="s3">return </span><span class="s1">dll</span>


<span class="s1">@_format_docstring(</span>
    <span class="s1">USER_APIS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">'&quot;{}&quot;'</span><span class="s1">.format(api) </span><span class="s3">for </span><span class="s1">api </span><span class="s3">in </span><span class="s1">_ALL_USER_APIS)</span><span class="s3">,</span>
    <span class="s1">INTERNAL_APIS=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">'&quot;{}&quot;'</span><span class="s1">.format(api) </span><span class="s3">for </span><span class="s1">api </span><span class="s3">in </span><span class="s1">_ALL_INTERNAL_APIS)</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">class </span><span class="s1">LibController(ABC):</span>
    <span class="s0">&quot;&quot;&quot;Abstract base class for the individual library controllers 
 
    A library controller is represented by the following information: 
      - &quot;user_api&quot; : user API. Possible values are {USER_APIS}. 
      - &quot;internal_api&quot; : internal API. Possible values are {INTERNAL_APIS}. 
      - &quot;prefix&quot; : prefix of the shared library's name. 
      - &quot;filepath&quot; : path to the loaded library. 
      - &quot;version&quot; : version of the library (if available). 
      - &quot;num_threads&quot; : the current thread limit. 
 
    In addition, each library controller may contain internal_api specific 
    entries. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">filepath=</span><span class="s3">None, </span><span class="s1">prefix=</span><span class="s3">None, </span><span class="s1">user_api=</span><span class="s3">None, </span><span class="s1">internal_api=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self.user_api = user_api</span>
        <span class="s1">self.internal_api = internal_api</span>
        <span class="s1">self.prefix = prefix</span>
        <span class="s1">self.filepath = filepath</span>
        <span class="s1">self._dynlib = ctypes.CDLL(filepath</span><span class="s3">, </span><span class="s1">mode=_RTLD_NOLOAD)</span>
        <span class="s1">self.version = self.get_version()</span>

    <span class="s3">def </span><span class="s1">info(self):</span>
        <span class="s0">&quot;&quot;&quot;Return relevant info wrapped in a dict&quot;&quot;&quot;</span>
        <span class="s1">all_attrs = dict(vars(self)</span><span class="s3">, </span><span class="s1">**{</span><span class="s4">&quot;num_threads&quot;</span><span class="s1">: self.num_threads})</span>
        <span class="s3">return </span><span class="s1">{k: v </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">all_attrs.items() </span><span class="s3">if not </span><span class="s1">k.startswith(</span><span class="s4">&quot;_&quot;</span><span class="s1">)}</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">num_threads(self):</span>
        <span class="s3">return </span><span class="s1">self.get_num_threads()</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">get_num_threads(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the maximum number of threads available to use&quot;&quot;&quot;</span>
        <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">set_num_threads(self</span><span class="s3">, </span><span class="s1">num_threads):</span>
        <span class="s0">&quot;&quot;&quot;Set the maximum number of threads to use&quot;&quot;&quot;</span>
        <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">get_version(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the version of the shared library&quot;&quot;&quot;</span>
        <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>


<span class="s3">class </span><span class="s1">OpenBLASController(LibController):</span>
    <span class="s0">&quot;&quot;&quot;Controller class for OpenBLAS&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.threading_layer = self._get_threading_layer()</span>
        <span class="s1">self.architecture = self._get_architecture()</span>

    <span class="s3">def </span><span class="s1">get_num_threads(self):</span>
        <span class="s1">get_func = getattr(</span>
            <span class="s1">self._dynlib</span><span class="s3">,</span>
            <span class="s4">&quot;openblas_get_num_threads&quot;</span><span class="s3">,</span>
            <span class="s2"># Symbols differ when built for 64bit integers in Fortran</span>
            <span class="s1">getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;openblas_get_num_threads64_&quot;</span><span class="s3">, lambda</span><span class="s1">: </span><span class="s3">None</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">get_func()</span>

    <span class="s3">def </span><span class="s1">set_num_threads(self</span><span class="s3">, </span><span class="s1">num_threads):</span>
        <span class="s1">set_func = getattr(</span>
            <span class="s1">self._dynlib</span><span class="s3">,</span>
            <span class="s4">&quot;openblas_set_num_threads&quot;</span><span class="s3">,</span>
            <span class="s2"># Symbols differ when built for 64bit integers in Fortran</span>
            <span class="s1">getattr(</span>
                <span class="s1">self._dynlib</span><span class="s3">, </span><span class="s4">&quot;openblas_set_num_threads64_&quot;</span><span class="s3">, lambda </span><span class="s1">num_threads: </span><span class="s3">None</span>
            <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">set_func(num_threads)</span>

    <span class="s3">def </span><span class="s1">get_version(self):</span>
        <span class="s2"># None means OpenBLAS is not loaded or version &lt; 0.3.4, since OpenBLAS</span>
        <span class="s2"># did not expose its version before that.</span>
        <span class="s1">get_config = getattr(</span>
            <span class="s1">self._dynlib</span><span class="s3">,</span>
            <span class="s4">&quot;openblas_get_config&quot;</span><span class="s3">,</span>
            <span class="s1">getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;openblas_get_config64_&quot;</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">get_config </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s1">get_config.restype = ctypes.c_char_p</span>
        <span class="s1">config = get_config().split()</span>
        <span class="s3">if </span><span class="s1">config[</span><span class="s5">0</span><span class="s1">] == </span><span class="s6">b&quot;OpenBLAS&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">config[</span><span class="s5">1</span><span class="s1">].decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_get_threading_layer(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the threading layer of OpenBLAS&quot;&quot;&quot;</span>
        <span class="s1">openblas_get_parallel = getattr(</span>
            <span class="s1">self._dynlib</span><span class="s3">,</span>
            <span class="s4">&quot;openblas_get_parallel&quot;</span><span class="s3">,</span>
            <span class="s1">getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;openblas_get_parallel64_&quot;</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">openblas_get_parallel </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;unknown&quot;</span>
        <span class="s1">threading_layer = openblas_get_parallel()</span>
        <span class="s3">if </span><span class="s1">threading_layer == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;openmp&quot;</span>
        <span class="s3">elif </span><span class="s1">threading_layer == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;pthreads&quot;</span>
        <span class="s3">return </span><span class="s4">&quot;disabled&quot;</span>

    <span class="s3">def </span><span class="s1">_get_architecture(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the architecture detected by OpenBLAS&quot;&quot;&quot;</span>
        <span class="s1">get_corename = getattr(</span>
            <span class="s1">self._dynlib</span><span class="s3">,</span>
            <span class="s4">&quot;openblas_get_corename&quot;</span><span class="s3">,</span>
            <span class="s1">getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;openblas_get_corename64_&quot;</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">get_corename </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s1">get_corename.restype = ctypes.c_char_p</span>
        <span class="s3">return </span><span class="s1">get_corename().decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">BLISController(LibController):</span>
    <span class="s0">&quot;&quot;&quot;Controller class for BLIS&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.threading_layer = self._get_threading_layer()</span>
        <span class="s1">self.architecture = self._get_architecture()</span>

    <span class="s3">def </span><span class="s1">get_num_threads(self):</span>
        <span class="s1">get_func = getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;bli_thread_get_num_threads&quot;</span><span class="s3">, lambda</span><span class="s1">: </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">num_threads = get_func()</span>
        <span class="s2"># by default BLIS is single-threaded and get_num_threads</span>
        <span class="s2"># returns -1. We map it to 1 for consistency with other libraries.</span>
        <span class="s3">return </span><span class="s5">1 </span><span class="s3">if </span><span class="s1">num_threads == -</span><span class="s5">1 </span><span class="s3">else </span><span class="s1">num_threads</span>

    <span class="s3">def </span><span class="s1">set_num_threads(self</span><span class="s3">, </span><span class="s1">num_threads):</span>
        <span class="s1">set_func = getattr(</span>
            <span class="s1">self._dynlib</span><span class="s3">, </span><span class="s4">&quot;bli_thread_set_num_threads&quot;</span><span class="s3">, lambda </span><span class="s1">num_threads: </span><span class="s3">None</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">set_func(num_threads)</span>

    <span class="s3">def </span><span class="s1">get_version(self):</span>
        <span class="s1">get_version_ = getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;bli_info_get_version_str&quot;</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">get_version_ </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s1">get_version_.restype = ctypes.c_char_p</span>
        <span class="s3">return </span><span class="s1">get_version_().decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_get_threading_layer(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the threading layer of BLIS&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._dynlib.bli_info_get_enable_openmp():</span>
            <span class="s3">return </span><span class="s4">&quot;openmp&quot;</span>
        <span class="s3">elif </span><span class="s1">self._dynlib.bli_info_get_enable_pthreads():</span>
            <span class="s3">return </span><span class="s4">&quot;pthreads&quot;</span>
        <span class="s3">return </span><span class="s4">&quot;disabled&quot;</span>

    <span class="s3">def </span><span class="s1">_get_architecture(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the architecture detected by BLIS&quot;&quot;&quot;</span>
        <span class="s1">bli_arch_query_id = getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;bli_arch_query_id&quot;</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">bli_arch_string = getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;bli_arch_string&quot;</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">bli_arch_query_id </span><span class="s3">is None or </span><span class="s1">bli_arch_string </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s2"># the true restype should be BLIS' arch_t (enum) but int should work</span>
        <span class="s2"># for us:</span>
        <span class="s1">bli_arch_query_id.restype = ctypes.c_int</span>
        <span class="s1">bli_arch_string.restype = ctypes.c_char_p</span>
        <span class="s3">return </span><span class="s1">bli_arch_string(bli_arch_query_id()).decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">MKLController(LibController):</span>
    <span class="s0">&quot;&quot;&quot;Controller class for MKL&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.threading_layer = self._get_threading_layer()</span>

    <span class="s3">def </span><span class="s1">get_num_threads(self):</span>
        <span class="s1">get_func = getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;MKL_Get_Max_Threads&quot;</span><span class="s3">, lambda</span><span class="s1">: </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">get_func()</span>

    <span class="s3">def </span><span class="s1">set_num_threads(self</span><span class="s3">, </span><span class="s1">num_threads):</span>
        <span class="s1">set_func = getattr(</span>
            <span class="s1">self._dynlib</span><span class="s3">, </span><span class="s4">&quot;MKL_Set_Num_Threads&quot;</span><span class="s3">, lambda </span><span class="s1">num_threads: </span><span class="s3">None</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">set_func(num_threads)</span>

    <span class="s3">def </span><span class="s1">get_version(self):</span>
        <span class="s3">if not </span><span class="s1">hasattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;MKL_Get_Version_String&quot;</span><span class="s1">):</span>
            <span class="s3">return None</span>

        <span class="s1">res = ctypes.create_string_buffer(</span><span class="s5">200</span><span class="s1">)</span>
        <span class="s1">self._dynlib.MKL_Get_Version_String(res</span><span class="s3">, </span><span class="s5">200</span><span class="s1">)</span>

        <span class="s1">version = res.value.decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s1">group = re.search(</span><span class="s4">r&quot;Version ([^ ]+) &quot;</span><span class="s3">, </span><span class="s1">version)</span>
        <span class="s3">if </span><span class="s1">group </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">version = group.groups()[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">version.strip()</span>

    <span class="s3">def </span><span class="s1">_get_threading_layer(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the threading layer of MKL&quot;&quot;&quot;</span>
        <span class="s2"># The function mkl_set_threading_layer returns the current threading</span>
        <span class="s2"># layer. Calling it with an invalid threading layer allows us to safely</span>
        <span class="s2"># get the threading layer</span>
        <span class="s1">set_threading_layer = getattr(</span>
            <span class="s1">self._dynlib</span><span class="s3">, </span><span class="s4">&quot;MKL_Set_Threading_Layer&quot;</span><span class="s3">, lambda </span><span class="s1">layer: -</span><span class="s5">1</span>
        <span class="s1">)</span>
        <span class="s1">layer_map = {</span>
            <span class="s5">0</span><span class="s1">: </span><span class="s4">&quot;intel&quot;</span><span class="s3">,</span>
            <span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;sequential&quot;</span><span class="s3">,</span>
            <span class="s5">2</span><span class="s1">: </span><span class="s4">&quot;pgi&quot;</span><span class="s3">,</span>
            <span class="s5">3</span><span class="s1">: </span><span class="s4">&quot;gnu&quot;</span><span class="s3">,</span>
            <span class="s5">4</span><span class="s1">: </span><span class="s4">&quot;tbb&quot;</span><span class="s3">,</span>
            <span class="s1">-</span><span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;not specified&quot;</span><span class="s3">,</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">layer_map[set_threading_layer(-</span><span class="s5">1</span><span class="s1">)]</span>


<span class="s3">class </span><span class="s1">OpenMPController(LibController):</span>
    <span class="s0">&quot;&quot;&quot;Controller class for OpenMP&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">get_num_threads(self):</span>
        <span class="s1">get_func = getattr(self._dynlib</span><span class="s3">, </span><span class="s4">&quot;omp_get_max_threads&quot;</span><span class="s3">, lambda</span><span class="s1">: </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">get_func()</span>

    <span class="s3">def </span><span class="s1">set_num_threads(self</span><span class="s3">, </span><span class="s1">num_threads):</span>
        <span class="s1">set_func = getattr(</span>
            <span class="s1">self._dynlib</span><span class="s3">, </span><span class="s4">&quot;omp_set_num_threads&quot;</span><span class="s3">, lambda </span><span class="s1">num_threads: </span><span class="s3">None</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">set_func(num_threads)</span>

    <span class="s3">def </span><span class="s1">get_version(self):</span>
        <span class="s2"># There is no way to get the version number programmatically in OpenMP.</span>
        <span class="s3">return None</span>


<span class="s3">def </span><span class="s1">_main():</span>
    <span class="s0">&quot;&quot;&quot;Commandline interface to display thread-pool information and exit.&quot;&quot;&quot;</span>
    <span class="s3">import </span><span class="s1">argparse</span>
    <span class="s3">import </span><span class="s1">importlib</span>
    <span class="s3">import </span><span class="s1">json</span>
    <span class="s3">import </span><span class="s1">sys</span>

    <span class="s1">parser = argparse.ArgumentParser(</span>
        <span class="s1">usage=</span><span class="s4">&quot;python -m threadpoolctl -i numpy scipy.linalg xgboost&quot;</span><span class="s3">,</span>
        <span class="s1">description=</span><span class="s4">&quot;Display thread-pool information and exit.&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s4">&quot;-i&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;--import&quot;</span><span class="s3">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;modules&quot;</span><span class="s3">,</span>
        <span class="s1">nargs=</span><span class="s4">&quot;*&quot;</span><span class="s3">,</span>
        <span class="s1">default=()</span><span class="s3">,</span>
        <span class="s1">help=</span><span class="s4">&quot;Python modules to import before introspecting thread-pools.&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s4">&quot;-c&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;--command&quot;</span><span class="s3">,</span>
        <span class="s1">help=</span><span class="s4">&quot;a Python statement to execute before introspecting thread-pools.&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>

    <span class="s1">options = parser.parse_args(sys.argv[</span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s3">for </span><span class="s1">module </span><span class="s3">in </span><span class="s1">options.modules:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">importlib.import_module(module</span><span class="s3">, </span><span class="s1">package=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">ImportError:</span>
            <span class="s1">print(</span><span class="s4">&quot;WARNING: could not import&quot;</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">file=sys.stderr)</span>

    <span class="s3">if </span><span class="s1">options.command:</span>
        <span class="s1">exec(options.command)</span>

    <span class="s1">print(json.dumps(threadpool_info()</span><span class="s3">, </span><span class="s1">indent=</span><span class="s5">2</span><span class="s1">))</span>


<span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">_main()</span>
</pre>
</body>
</html>