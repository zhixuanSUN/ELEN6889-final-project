<html>
<head>
<title>util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
util.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Copyright (C) 2012-2021 The Python Software Foundation.</span>
<span class="s0"># See LICENSE.txt and CONTRIBUTORS.txt.</span>
<span class="s0">#</span>
<span class="s2">import </span><span class="s1">codecs</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">deque</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">csv</span>
<span class="s2">from </span><span class="s1">glob </span><span class="s2">import </span><span class="s1">iglob </span><span class="s2">as </span><span class="s1">std_iglob</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">json</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">py_compile</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">socket</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">ssl</span>
<span class="s2">except </span><span class="s1">ImportError:  </span><span class="s0"># pragma: no cover</span>
    <span class="s1">ssl = </span><span class="s2">None</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">tarfile</span>
<span class="s2">import </span><span class="s1">tempfile</span>
<span class="s2">import </span><span class="s1">textwrap</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">threading</span>
<span class="s2">except </span><span class="s1">ImportError:  </span><span class="s0"># pragma: no cover</span>
    <span class="s2">import </span><span class="s1">dummy_threading </span><span class="s2">as </span><span class="s1">threading</span>
<span class="s2">import </span><span class="s1">time</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">DistlibException</span>
<span class="s2">from </span><span class="s1">.compat </span><span class="s2">import </span><span class="s1">(string_types</span><span class="s2">, </span><span class="s1">text_type</span><span class="s2">, </span><span class="s1">shutil</span><span class="s2">, </span><span class="s1">raw_input</span><span class="s2">, </span><span class="s1">StringIO</span><span class="s2">,</span>
                     <span class="s1">cache_from_source</span><span class="s2">, </span><span class="s1">urlopen</span><span class="s2">, </span><span class="s1">urljoin</span><span class="s2">, </span><span class="s1">httplib</span><span class="s2">, </span><span class="s1">xmlrpclib</span><span class="s2">,</span>
                     <span class="s1">splittype</span><span class="s2">, </span><span class="s1">HTTPHandler</span><span class="s2">, </span><span class="s1">BaseConfigurator</span><span class="s2">, </span><span class="s1">valid_ident</span><span class="s2">,</span>
                     <span class="s1">Container</span><span class="s2">, </span><span class="s1">configparser</span><span class="s2">, </span><span class="s1">URLError</span><span class="s2">, </span><span class="s1">ZipFile</span><span class="s2">, </span><span class="s1">fsdecode</span><span class="s2">,</span>
                     <span class="s1">unquote</span><span class="s2">, </span><span class="s1">urlparse)</span>

<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s0">#</span>
<span class="s0"># Requirement parsing code as per PEP 508</span>
<span class="s0">#</span>

<span class="s1">IDENTIFIER = re.compile(</span><span class="s3">r'^([\w\.-]+)\s*'</span><span class="s1">)</span>
<span class="s1">VERSION_IDENTIFIER = re.compile(</span><span class="s3">r'^([\w\.*+-]+)\s*'</span><span class="s1">)</span>
<span class="s1">COMPARE_OP = re.compile(</span><span class="s3">r'^(&lt;=?|&gt;=?|={2,3}|[~!]=)\s*'</span><span class="s1">)</span>
<span class="s1">MARKER_OP = re.compile(</span><span class="s3">r'^((&lt;=?)|(&gt;=?)|={2,3}|[~!]=|in|not\s+in)\s*'</span><span class="s1">)</span>
<span class="s1">OR = re.compile(</span><span class="s3">r'^or\b\s*'</span><span class="s1">)</span>
<span class="s1">AND = re.compile(</span><span class="s3">r'^and\b\s*'</span><span class="s1">)</span>
<span class="s1">NON_SPACE = re.compile(</span><span class="s3">r'(\S+)\s*'</span><span class="s1">)</span>
<span class="s1">STRING_CHUNK = re.compile(</span><span class="s3">r'([\s\w\.{}()*+#:;,/?!~`@$%^&amp;=|&lt;&gt;\[\]-]+)'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">parse_marker(marker_string):</span>
    <span class="s4">&quot;&quot;&quot; 
    Parse a marker string and return a dictionary containing a marker expression. 
 
    The dictionary will contain keys &quot;op&quot;, &quot;lhs&quot; and &quot;rhs&quot; for non-terminals in 
    the expression grammar, or strings. A string contained in quotes is to be 
    interpreted as a literal string, and a string not contained in quotes is a 
    variable (such as os_name). 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">marker_var(remaining):</span>
        <span class="s0"># either identifier, or literal string</span>
        <span class="s1">m = IDENTIFIER.match(remaining)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">result = m.groups()[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">remaining = remaining[m.end():]</span>
        <span class="s2">elif not </span><span class="s1">remaining:</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'unexpected end of input'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">q = remaining[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">q </span><span class="s2">not in </span><span class="s3">'</span><span class="s2">\'</span><span class="s3">&quot;'</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'invalid expression: %s' </span><span class="s1">% remaining)</span>
            <span class="s1">oq = </span><span class="s3">'</span><span class="s2">\'</span><span class="s3">&quot;'</span><span class="s1">.replace(q</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">remaining = remaining[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s1">parts = [q]</span>
            <span class="s2">while </span><span class="s1">remaining:</span>
                <span class="s0"># either a string chunk, or oq, or q to terminate</span>
                <span class="s2">if </span><span class="s1">remaining[</span><span class="s5">0</span><span class="s1">] == q:</span>
                    <span class="s2">break</span>
                <span class="s2">elif </span><span class="s1">remaining[</span><span class="s5">0</span><span class="s1">] == oq:</span>
                    <span class="s1">parts.append(oq)</span>
                    <span class="s1">remaining = remaining[</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">m = STRING_CHUNK.match(remaining)</span>
                    <span class="s2">if not </span><span class="s1">m:</span>
                        <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'error in string literal: %s' </span><span class="s1">% remaining)</span>
                    <span class="s1">parts.append(m.groups()[</span><span class="s5">0</span><span class="s1">])</span>
                    <span class="s1">remaining = remaining[m.end():]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">s = </span><span class="s3">''</span><span class="s1">.join(parts)</span>
                <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'unterminated string: %s' </span><span class="s1">% s)</span>
            <span class="s1">parts.append(q)</span>
            <span class="s1">result = </span><span class="s3">''</span><span class="s1">.join(parts)</span>
            <span class="s1">remaining = remaining[</span><span class="s5">1</span><span class="s1">:].lstrip() </span><span class="s0"># skip past closing quote</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">remaining</span>

    <span class="s2">def </span><span class="s1">marker_expr(remaining):</span>
        <span class="s2">if </span><span class="s1">remaining </span><span class="s2">and </span><span class="s1">remaining[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'('</span><span class="s1">:</span>
            <span class="s1">result</span><span class="s2">, </span><span class="s1">remaining = marker(remaining[</span><span class="s5">1</span><span class="s1">:].lstrip())</span>
            <span class="s2">if </span><span class="s1">remaining[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">')'</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'unterminated parenthesis: %s' </span><span class="s1">% remaining)</span>
            <span class="s1">remaining = remaining[</span><span class="s5">1</span><span class="s1">:].lstrip()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lhs</span><span class="s2">, </span><span class="s1">remaining = marker_var(remaining)</span>
            <span class="s2">while </span><span class="s1">remaining:</span>
                <span class="s1">m = MARKER_OP.match(remaining)</span>
                <span class="s2">if not </span><span class="s1">m:</span>
                    <span class="s2">break</span>
                <span class="s1">op = m.groups()[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">remaining = remaining[m.end():]</span>
                <span class="s1">rhs</span><span class="s2">, </span><span class="s1">remaining = marker_var(remaining)</span>
                <span class="s1">lhs = {</span><span class="s3">'op'</span><span class="s1">: op</span><span class="s2">, </span><span class="s3">'lhs'</span><span class="s1">: lhs</span><span class="s2">, </span><span class="s3">'rhs'</span><span class="s1">: rhs}</span>
            <span class="s1">result = lhs</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">remaining</span>

    <span class="s2">def </span><span class="s1">marker_and(remaining):</span>
        <span class="s1">lhs</span><span class="s2">, </span><span class="s1">remaining = marker_expr(remaining)</span>
        <span class="s2">while </span><span class="s1">remaining:</span>
            <span class="s1">m = AND.match(remaining)</span>
            <span class="s2">if not </span><span class="s1">m:</span>
                <span class="s2">break</span>
            <span class="s1">remaining = remaining[m.end():]</span>
            <span class="s1">rhs</span><span class="s2">, </span><span class="s1">remaining = marker_expr(remaining)</span>
            <span class="s1">lhs = {</span><span class="s3">'op'</span><span class="s1">: </span><span class="s3">'and'</span><span class="s2">, </span><span class="s3">'lhs'</span><span class="s1">: lhs</span><span class="s2">, </span><span class="s3">'rhs'</span><span class="s1">: rhs}</span>
        <span class="s2">return </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">remaining</span>

    <span class="s2">def </span><span class="s1">marker(remaining):</span>
        <span class="s1">lhs</span><span class="s2">, </span><span class="s1">remaining = marker_and(remaining)</span>
        <span class="s2">while </span><span class="s1">remaining:</span>
            <span class="s1">m = OR.match(remaining)</span>
            <span class="s2">if not </span><span class="s1">m:</span>
                <span class="s2">break</span>
            <span class="s1">remaining = remaining[m.end():]</span>
            <span class="s1">rhs</span><span class="s2">, </span><span class="s1">remaining = marker_and(remaining)</span>
            <span class="s1">lhs = {</span><span class="s3">'op'</span><span class="s1">: </span><span class="s3">'or'</span><span class="s2">, </span><span class="s3">'lhs'</span><span class="s1">: lhs</span><span class="s2">, </span><span class="s3">'rhs'</span><span class="s1">: rhs}</span>
        <span class="s2">return </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">remaining</span>

    <span class="s2">return </span><span class="s1">marker(marker_string)</span>


<span class="s2">def </span><span class="s1">parse_requirement(req):</span>
    <span class="s4">&quot;&quot;&quot; 
    Parse a requirement passed in as a string. Return a Container 
    whose attributes contain the various parts of the requirement. 
    &quot;&quot;&quot;</span>
    <span class="s1">remaining = req.strip()</span>
    <span class="s2">if not </span><span class="s1">remaining </span><span class="s2">or </span><span class="s1">remaining.startswith(</span><span class="s3">'#'</span><span class="s1">):</span>
        <span class="s2">return None</span>
    <span class="s1">m = IDENTIFIER.match(remaining)</span>
    <span class="s2">if not </span><span class="s1">m:</span>
        <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'name expected: %s' </span><span class="s1">% remaining)</span>
    <span class="s1">distname = m.groups()[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">remaining = remaining[m.end():]</span>
    <span class="s1">extras = mark_expr = versions = uri = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">remaining </span><span class="s2">and </span><span class="s1">remaining[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'['</span><span class="s1">:</span>
        <span class="s1">i = remaining.find(</span><span class="s3">']'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">i &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'unterminated extra: %s' </span><span class="s1">% remaining)</span>
        <span class="s1">s = remaining[</span><span class="s5">1</span><span class="s1">:i]</span>
        <span class="s1">remaining = remaining[i + </span><span class="s5">1</span><span class="s1">:].lstrip()</span>
        <span class="s1">extras = []</span>
        <span class="s2">while </span><span class="s1">s:</span>
            <span class="s1">m = IDENTIFIER.match(s)</span>
            <span class="s2">if not </span><span class="s1">m:</span>
                <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'malformed extra: %s' </span><span class="s1">% s)</span>
            <span class="s1">extras.append(m.groups()[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">s = s[m.end():]</span>
            <span class="s2">if not </span><span class="s1">s:</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">','</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'comma expected in extras: %s' </span><span class="s1">% s)</span>
            <span class="s1">s = s[</span><span class="s5">1</span><span class="s1">:].lstrip()</span>
        <span class="s2">if not </span><span class="s1">extras:</span>
            <span class="s1">extras = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">remaining:</span>
        <span class="s2">if </span><span class="s1">remaining[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'@'</span><span class="s1">:</span>
            <span class="s0"># it's a URI</span>
            <span class="s1">remaining = remaining[</span><span class="s5">1</span><span class="s1">:].lstrip()</span>
            <span class="s1">m = NON_SPACE.match(remaining)</span>
            <span class="s2">if not </span><span class="s1">m:</span>
                <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'invalid URI: %s' </span><span class="s1">% remaining)</span>
            <span class="s1">uri = m.groups()[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">t = urlparse(uri)</span>
            <span class="s0"># there are issues with Python and URL parsing, so this test</span>
            <span class="s0"># is a bit crude. See bpo-20271, bpo-23505. Python doesn't</span>
            <span class="s0"># always parse invalid URLs correctly - it should raise</span>
            <span class="s0"># exceptions for malformed URLs</span>
            <span class="s2">if not </span><span class="s1">(t.scheme </span><span class="s2">and </span><span class="s1">t.netloc):</span>
                <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'Invalid URL: %s' </span><span class="s1">% uri)</span>
            <span class="s1">remaining = remaining[m.end():].lstrip()</span>
        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">get_versions(ver_remaining):</span>
                <span class="s4">&quot;&quot;&quot; 
                Return a list of operator, version tuples if any are 
                specified, else None. 
                &quot;&quot;&quot;</span>
                <span class="s1">m = COMPARE_OP.match(ver_remaining)</span>
                <span class="s1">versions = </span><span class="s2">None</span>
                <span class="s2">if </span><span class="s1">m:</span>
                    <span class="s1">versions = []</span>
                    <span class="s2">while True</span><span class="s1">:</span>
                        <span class="s1">op = m.groups()[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s1">ver_remaining = ver_remaining[m.end():]</span>
                        <span class="s1">m = VERSION_IDENTIFIER.match(ver_remaining)</span>
                        <span class="s2">if not </span><span class="s1">m:</span>
                            <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'invalid version: %s' </span><span class="s1">% ver_remaining)</span>
                        <span class="s1">v = m.groups()[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s1">versions.append((op</span><span class="s2">, </span><span class="s1">v))</span>
                        <span class="s1">ver_remaining = ver_remaining[m.end():]</span>
                        <span class="s2">if not </span><span class="s1">ver_remaining </span><span class="s2">or </span><span class="s1">ver_remaining[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">','</span><span class="s1">:</span>
                            <span class="s2">break</span>
                        <span class="s1">ver_remaining = ver_remaining[</span><span class="s5">1</span><span class="s1">:].lstrip()</span>
                        <span class="s0"># Some packages have a trailing comma which would break things</span>
                        <span class="s0"># See issue #148</span>
                        <span class="s2">if not </span><span class="s1">ver_remaining:</span>
                            <span class="s2">break</span>
                        <span class="s1">m = COMPARE_OP.match(ver_remaining)</span>
                        <span class="s2">if not </span><span class="s1">m:</span>
                            <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'invalid constraint: %s' </span><span class="s1">% ver_remaining)</span>
                    <span class="s2">if not </span><span class="s1">versions:</span>
                        <span class="s1">versions = </span><span class="s2">None</span>
                <span class="s2">return </span><span class="s1">versions</span><span class="s2">, </span><span class="s1">ver_remaining</span>

            <span class="s2">if </span><span class="s1">remaining[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">'('</span><span class="s1">:</span>
                <span class="s1">versions</span><span class="s2">, </span><span class="s1">remaining = get_versions(remaining)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">i = remaining.find(</span><span class="s3">')'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">i &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'unterminated parenthesis: %s' </span><span class="s1">% remaining)</span>
                <span class="s1">s = remaining[</span><span class="s5">1</span><span class="s1">:i]</span>
                <span class="s1">remaining = remaining[i + </span><span class="s5">1</span><span class="s1">:].lstrip()</span>
                <span class="s0"># As a special diversion from PEP 508, allow a version number</span>
                <span class="s0"># a.b.c in parentheses as a synonym for ~= a.b.c (because this</span>
                <span class="s0"># is allowed in earlier PEPs)</span>
                <span class="s2">if </span><span class="s1">COMPARE_OP.match(s):</span>
                    <span class="s1">versions</span><span class="s2">, </span><span class="s1">_ = get_versions(s)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">m = VERSION_IDENTIFIER.match(s)</span>
                    <span class="s2">if not </span><span class="s1">m:</span>
                        <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'invalid constraint: %s' </span><span class="s1">% s)</span>
                    <span class="s1">v = m.groups()[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">s = s[m.end():].lstrip()</span>
                    <span class="s2">if </span><span class="s1">s:</span>
                        <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'invalid constraint: %s' </span><span class="s1">% s)</span>
                    <span class="s1">versions = [(</span><span class="s3">'~='</span><span class="s2">, </span><span class="s1">v)]</span>

    <span class="s2">if </span><span class="s1">remaining:</span>
        <span class="s2">if </span><span class="s1">remaining[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">';'</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'invalid requirement: %s' </span><span class="s1">% remaining)</span>
        <span class="s1">remaining = remaining[</span><span class="s5">1</span><span class="s1">:].lstrip()</span>

        <span class="s1">mark_expr</span><span class="s2">, </span><span class="s1">remaining = parse_marker(remaining)</span>

    <span class="s2">if </span><span class="s1">remaining </span><span class="s2">and </span><span class="s1">remaining[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">'#'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'unexpected trailing data: %s' </span><span class="s1">% remaining)</span>

    <span class="s2">if not </span><span class="s1">versions:</span>
        <span class="s1">rs = distname</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">rs = </span><span class="s3">'%s %s' </span><span class="s1">% (distname</span><span class="s2">, </span><span class="s3">', '</span><span class="s1">.join([</span><span class="s3">'%s %s' </span><span class="s1">% con </span><span class="s2">for </span><span class="s1">con </span><span class="s2">in </span><span class="s1">versions]))</span>
    <span class="s2">return </span><span class="s1">Container(name=distname</span><span class="s2">, </span><span class="s1">extras=extras</span><span class="s2">, </span><span class="s1">constraints=versions</span><span class="s2">,</span>
                     <span class="s1">marker=mark_expr</span><span class="s2">, </span><span class="s1">url=uri</span><span class="s2">, </span><span class="s1">requirement=rs)</span>


<span class="s2">def </span><span class="s1">get_resources_dests(resources_root</span><span class="s2">, </span><span class="s1">rules):</span>
    <span class="s4">&quot;&quot;&quot;Find destinations for resources files&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">get_rel_path(root</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s0"># normalizes and returns a lstripped-/-separated path</span>
        <span class="s1">root = root.replace(os.path.sep</span><span class="s2">, </span><span class="s3">'/'</span><span class="s1">)</span>
        <span class="s1">path = path.replace(os.path.sep</span><span class="s2">, </span><span class="s3">'/'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">path.startswith(root)</span>
        <span class="s2">return </span><span class="s1">path[len(root):].lstrip(</span><span class="s3">'/'</span><span class="s1">)</span>

    <span class="s1">destinations = {}</span>
    <span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">dest </span><span class="s2">in </span><span class="s1">rules:</span>
        <span class="s1">prefix = os.path.join(resources_root</span><span class="s2">, </span><span class="s1">base)</span>
        <span class="s2">for </span><span class="s1">abs_base </span><span class="s2">in </span><span class="s1">iglob(prefix):</span>
            <span class="s1">abs_glob = os.path.join(abs_base</span><span class="s2">, </span><span class="s1">suffix)</span>
            <span class="s2">for </span><span class="s1">abs_path </span><span class="s2">in </span><span class="s1">iglob(abs_glob):</span>
                <span class="s1">resource_file = get_rel_path(resources_root</span><span class="s2">, </span><span class="s1">abs_path)</span>
                <span class="s2">if </span><span class="s1">dest </span><span class="s2">is None</span><span class="s1">:  </span><span class="s0"># remove the entry if it was here</span>
                    <span class="s1">destinations.pop(resource_file</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">rel_path = get_rel_path(abs_base</span><span class="s2">, </span><span class="s1">abs_path)</span>
                    <span class="s1">rel_dest = dest.replace(os.path.sep</span><span class="s2">, </span><span class="s3">'/'</span><span class="s1">).rstrip(</span><span class="s3">'/'</span><span class="s1">)</span>
                    <span class="s1">destinations[resource_file] = rel_dest + </span><span class="s3">'/' </span><span class="s1">+ rel_path</span>
    <span class="s2">return </span><span class="s1">destinations</span>


<span class="s2">def </span><span class="s1">in_venv():</span>
    <span class="s2">if </span><span class="s1">hasattr(sys</span><span class="s2">, </span><span class="s3">'real_prefix'</span><span class="s1">):</span>
        <span class="s0"># virtualenv venvs</span>
        <span class="s1">result = </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># PEP 405 venvs</span>
        <span class="s1">result = sys.prefix != getattr(sys</span><span class="s2">, </span><span class="s3">'base_prefix'</span><span class="s2">, </span><span class="s1">sys.prefix)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">get_executable():</span>
<span class="s0"># The __PYVENV_LAUNCHER__ dance is apparently no longer needed, as</span>
<span class="s0"># changes to the stub launcher mean that sys.executable always points</span>
<span class="s0"># to the stub on OS X</span>
<span class="s0">#    if sys.platform == 'darwin' and ('__PYVENV_LAUNCHER__'</span>
<span class="s0">#                                     in os.environ):</span>
<span class="s0">#        result =  os.environ['__PYVENV_LAUNCHER__']</span>
<span class="s0">#    else:</span>
<span class="s0">#        result = sys.executable</span>
<span class="s0">#    return result</span>
    <span class="s0"># Avoid normcasing: see issue #143</span>
    <span class="s0"># result = os.path.normcase(sys.executable)</span>
    <span class="s1">result = sys.executable</span>
    <span class="s2">if not </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">text_type):</span>
        <span class="s1">result = fsdecode(result)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">proceed(prompt</span><span class="s2">, </span><span class="s1">allowed_chars</span><span class="s2">, </span><span class="s1">error_prompt=</span><span class="s2">None, </span><span class="s1">default=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">p = prompt</span>
    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">s = raw_input(p)</span>
        <span class="s1">p = prompt</span>
        <span class="s2">if not </span><span class="s1">s </span><span class="s2">and </span><span class="s1">default:</span>
            <span class="s1">s = default</span>
        <span class="s2">if </span><span class="s1">s:</span>
            <span class="s1">c = s[</span><span class="s5">0</span><span class="s1">].lower()</span>
            <span class="s2">if </span><span class="s1">c </span><span class="s2">in </span><span class="s1">allowed_chars:</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">error_prompt:</span>
                <span class="s1">p = </span><span class="s3">'%c: %s</span><span class="s2">\n</span><span class="s3">%s' </span><span class="s1">% (c</span><span class="s2">, </span><span class="s1">error_prompt</span><span class="s2">, </span><span class="s1">prompt)</span>
    <span class="s2">return </span><span class="s1">c</span>


<span class="s2">def </span><span class="s1">extract_by_key(d</span><span class="s2">, </span><span class="s1">keys):</span>
    <span class="s2">if </span><span class="s1">isinstance(keys</span><span class="s2">, </span><span class="s1">string_types):</span>
        <span class="s1">keys = keys.split()</span>
    <span class="s1">result = {}</span>
    <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keys:</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">d:</span>
            <span class="s1">result[key] = d[key]</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s2">def </span><span class="s1">read_exports(stream):</span>
    <span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] &gt;= </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s0"># needs to be a text stream</span>
        <span class="s1">stream = codecs.getreader(</span><span class="s3">'utf-8'</span><span class="s1">)(stream)</span>
    <span class="s0"># Try to load as JSON, falling back on legacy format</span>
    <span class="s1">data = stream.read()</span>
    <span class="s1">stream = StringIO(data)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">jdata = json.load(stream)</span>
        <span class="s1">result = jdata[</span><span class="s3">'extensions'</span><span class="s1">][</span><span class="s3">'python.exports'</span><span class="s1">][</span><span class="s3">'exports'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">group</span><span class="s2">, </span><span class="s1">entries </span><span class="s2">in </span><span class="s1">result.items():</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">entries.items():</span>
                <span class="s1">s = </span><span class="s3">'%s = %s' </span><span class="s1">% (k</span><span class="s2">, </span><span class="s1">v)</span>
                <span class="s1">entry = get_export_entry(s)</span>
                <span class="s2">assert </span><span class="s1">entry </span><span class="s2">is not None</span>
                <span class="s1">entries[k] = entry</span>
        <span class="s2">return </span><span class="s1">result</span>
    <span class="s2">except </span><span class="s1">Exception:</span>
        <span class="s1">stream.seek(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">read_stream(cp</span><span class="s2">, </span><span class="s1">stream):</span>
        <span class="s2">if </span><span class="s1">hasattr(cp</span><span class="s2">, </span><span class="s3">'read_file'</span><span class="s1">):</span>
            <span class="s1">cp.read_file(stream)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cp.readfp(stream)</span>

    <span class="s1">cp = configparser.ConfigParser()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">read_stream(cp</span><span class="s2">, </span><span class="s1">stream)</span>
    <span class="s2">except </span><span class="s1">configparser.MissingSectionHeaderError:</span>
        <span class="s1">stream.close()</span>
        <span class="s1">data = textwrap.dedent(data)</span>
        <span class="s1">stream = StringIO(data)</span>
        <span class="s1">read_stream(cp</span><span class="s2">, </span><span class="s1">stream)</span>

    <span class="s1">result = {}</span>
    <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">cp.sections():</span>
        <span class="s1">result[key] = entries = {}</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">cp.items(key):</span>
            <span class="s1">s = </span><span class="s3">'%s = %s' </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s1">entry = get_export_entry(s)</span>
            <span class="s2">assert </span><span class="s1">entry </span><span class="s2">is not None</span>
            <span class="s0">#entry.dist = self</span>
            <span class="s1">entries[name] = entry</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">write_exports(exports</span><span class="s2">, </span><span class="s1">stream):</span>
    <span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] &gt;= </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s0"># needs to be a text stream</span>
        <span class="s1">stream = codecs.getwriter(</span><span class="s3">'utf-8'</span><span class="s1">)(stream)</span>
    <span class="s1">cp = configparser.ConfigParser()</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">exports.items():</span>
        <span class="s0"># TODO check k, v for valid values</span>
        <span class="s1">cp.add_section(k)</span>
        <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">v.values():</span>
            <span class="s2">if </span><span class="s1">entry.suffix </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">s = entry.prefix</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">s = </span><span class="s3">'%s:%s' </span><span class="s1">% (entry.prefix</span><span class="s2">, </span><span class="s1">entry.suffix)</span>
            <span class="s2">if </span><span class="s1">entry.flags:</span>
                <span class="s1">s = </span><span class="s3">'%s [%s]' </span><span class="s1">% (s</span><span class="s2">, </span><span class="s3">', '</span><span class="s1">.join(entry.flags))</span>
            <span class="s1">cp.set(k</span><span class="s2">, </span><span class="s1">entry.name</span><span class="s2">, </span><span class="s1">s)</span>
    <span class="s1">cp.write(stream)</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">tempdir():</span>
    <span class="s1">td = tempfile.mkdtemp()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">yield </span><span class="s1">td</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">shutil.rmtree(td)</span>

<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">chdir(d):</span>
    <span class="s1">cwd = os.getcwd()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">os.chdir(d)</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">os.chdir(cwd)</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">socket_timeout(seconds=</span><span class="s5">15</span><span class="s1">):</span>
    <span class="s1">cto = socket.getdefaulttimeout()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">socket.setdefaulttimeout(seconds)</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">socket.setdefaulttimeout(cto)</span>


<span class="s2">class </span><span class="s1">cached_property(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s1">self.func = func</span>
        <span class="s0">#for attr in ('__name__', '__module__', '__doc__'):</span>
        <span class="s0">#    setattr(self, attr, getattr(func, attr, None))</span>

    <span class="s2">def </span><span class="s1">__get__(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">cls=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">obj </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s1">value = self.func(obj)</span>
        <span class="s1">object.__setattr__(obj</span><span class="s2">, </span><span class="s1">self.func.__name__</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s0">#obj.__dict__[self.func.__name__] = value = self.func(obj)</span>
        <span class="s2">return </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">convert_path(pathname):</span>
    <span class="s4">&quot;&quot;&quot;Return 'pathname' as a name that will work on the native filesystem. 
 
    The path is split on '/' and put back together again using the current 
    directory separator.  Needed because filenames in the setup script are 
    always supplied in Unix style, and have to be converted to the local 
    convention before we can actually use them in the filesystem.  Raises 
    ValueError on non-Unix-ish systems if 'pathname' either starts or 
    ends with a slash. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">os.sep == </span><span class="s3">'/'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pathname</span>
    <span class="s2">if not </span><span class="s1">pathname:</span>
        <span class="s2">return </span><span class="s1">pathname</span>
    <span class="s2">if </span><span class="s1">pathname[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'/'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;path '%s' cannot be absolute&quot; </span><span class="s1">% pathname)</span>
    <span class="s2">if </span><span class="s1">pathname[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">'/'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;path '%s' cannot end with '/'&quot; </span><span class="s1">% pathname)</span>

    <span class="s1">paths = pathname.split(</span><span class="s3">'/'</span><span class="s1">)</span>
    <span class="s2">while </span><span class="s1">os.curdir </span><span class="s2">in </span><span class="s1">paths:</span>
        <span class="s1">paths.remove(os.curdir)</span>
    <span class="s2">if not </span><span class="s1">paths:</span>
        <span class="s2">return </span><span class="s1">os.curdir</span>
    <span class="s2">return </span><span class="s1">os.path.join(*paths)</span>


<span class="s2">class </span><span class="s1">FileOperator(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dry_run=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.dry_run = dry_run</span>
        <span class="s1">self.ensured = set()</span>
        <span class="s1">self._init_record()</span>

    <span class="s2">def </span><span class="s1">_init_record(self):</span>
        <span class="s1">self.record = </span><span class="s2">False</span>
        <span class="s1">self.files_written = set()</span>
        <span class="s1">self.dirs_created = set()</span>

    <span class="s2">def </span><span class="s1">record_as_written(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s2">if </span><span class="s1">self.record:</span>
            <span class="s1">self.files_written.add(path)</span>

    <span class="s2">def </span><span class="s1">newer(self</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">target):</span>
        <span class="s4">&quot;&quot;&quot;Tell if the target is newer than the source. 
 
        Returns true if 'source' exists and is more recently modified than 
        'target', or if 'source' exists and 'target' doesn't. 
 
        Returns false if both exist and 'target' is the same age or younger 
        than 'source'. Raise PackagingFileError if 'source' does not exist. 
 
        Note that this test is not very accurate: files created in the same 
        second will have the same &quot;age&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(source):</span>
            <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">&quot;file '%r' does not exist&quot; </span><span class="s1">%</span>
                                   <span class="s1">os.path.abspath(source))</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(target):</span>
            <span class="s2">return True</span>

        <span class="s2">return </span><span class="s1">os.stat(source).st_mtime &gt; os.stat(target).st_mtime</span>

    <span class="s2">def </span><span class="s1">copy_file(self</span><span class="s2">, </span><span class="s1">infile</span><span class="s2">, </span><span class="s1">outfile</span><span class="s2">, </span><span class="s1">check=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Copy a file respecting dry-run and force flags. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ensure_dir(os.path.dirname(outfile))</span>
        <span class="s1">logger.info(</span><span class="s3">'Copying %s to %s'</span><span class="s2">, </span><span class="s1">infile</span><span class="s2">, </span><span class="s1">outfile)</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s1">msg = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">check:</span>
                <span class="s2">if </span><span class="s1">os.path.islink(outfile):</span>
                    <span class="s1">msg = </span><span class="s3">'%s is a symlink' </span><span class="s1">% outfile</span>
                <span class="s2">elif </span><span class="s1">os.path.exists(outfile) </span><span class="s2">and not </span><span class="s1">os.path.isfile(outfile):</span>
                    <span class="s1">msg = </span><span class="s3">'%s is a non-regular file' </span><span class="s1">% outfile</span>
            <span class="s2">if </span><span class="s1">msg:</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg + </span><span class="s3">' which would be overwritten'</span><span class="s1">)</span>
            <span class="s1">shutil.copyfile(infile</span><span class="s2">, </span><span class="s1">outfile)</span>
        <span class="s1">self.record_as_written(outfile)</span>

    <span class="s2">def </span><span class="s1">copy_stream(self</span><span class="s2">, </span><span class="s1">instream</span><span class="s2">, </span><span class="s1">outfile</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">assert not </span><span class="s1">os.path.isdir(outfile)</span>
        <span class="s1">self.ensure_dir(os.path.dirname(outfile))</span>
        <span class="s1">logger.info(</span><span class="s3">'Copying stream %s to %s'</span><span class="s2">, </span><span class="s1">instream</span><span class="s2">, </span><span class="s1">outfile)</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">outstream = open(outfile</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">outstream = codecs.open(outfile</span><span class="s2">, </span><span class="s3">'w'</span><span class="s2">, </span><span class="s1">encoding=encoding)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">shutil.copyfileobj(instream</span><span class="s2">, </span><span class="s1">outstream)</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">outstream.close()</span>
        <span class="s1">self.record_as_written(outfile)</span>

    <span class="s2">def </span><span class="s1">write_binary_file(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">self.ensure_dir(os.path.dirname(path))</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s2">if </span><span class="s1">os.path.exists(path):</span>
                <span class="s1">os.remove(path)</span>
            <span class="s2">with </span><span class="s1">open(path</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">f.write(data)</span>
        <span class="s1">self.record_as_written(path)</span>

    <span class="s2">def </span><span class="s1">write_text_file(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">encoding):</span>
        <span class="s1">self.write_binary_file(path</span><span class="s2">, </span><span class="s1">data.encode(encoding))</span>

    <span class="s2">def </span><span class="s1">set_mode(self</span><span class="s2">, </span><span class="s1">bits</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">files):</span>
        <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'posix' </span><span class="s2">or </span><span class="s1">(os.name == </span><span class="s3">'java' </span><span class="s2">and </span><span class="s1">os._name == </span><span class="s3">'posix'</span><span class="s1">):</span>
            <span class="s0"># Set the executable bits (owner, group, and world) on</span>
            <span class="s0"># all the files specified.</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">files:</span>
                <span class="s2">if </span><span class="s1">self.dry_run:</span>
                    <span class="s1">logger.info(</span><span class="s3">&quot;changing mode of %s&quot;</span><span class="s2">, </span><span class="s1">f)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">mode = (os.stat(f).st_mode | bits) &amp; mask</span>
                    <span class="s1">logger.info(</span><span class="s3">&quot;changing mode of %s to %o&quot;</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">mode)</span>
                    <span class="s1">os.chmod(f</span><span class="s2">, </span><span class="s1">mode)</span>

    <span class="s1">set_executable_mode = </span><span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">f: s.set_mode(</span><span class="s5">0o555</span><span class="s2">, </span><span class="s5">0o7777</span><span class="s2">, </span><span class="s1">f)</span>

    <span class="s2">def </span><span class="s1">ensure_dir(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">path = os.path.abspath(path)</span>
        <span class="s2">if </span><span class="s1">path </span><span class="s2">not in </span><span class="s1">self.ensured </span><span class="s2">and not </span><span class="s1">os.path.exists(path):</span>
            <span class="s1">self.ensured.add(path)</span>
            <span class="s1">d</span><span class="s2">, </span><span class="s1">f = os.path.split(path)</span>
            <span class="s1">self.ensure_dir(d)</span>
            <span class="s1">logger.info(</span><span class="s3">'Creating %s' </span><span class="s1">% path)</span>
            <span class="s2">if not </span><span class="s1">self.dry_run:</span>
                <span class="s1">os.mkdir(path)</span>
            <span class="s2">if </span><span class="s1">self.record:</span>
                <span class="s1">self.dirs_created.add(path)</span>

    <span class="s2">def </span><span class="s1">byte_compile(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">optimize=</span><span class="s2">False, </span><span class="s1">force=</span><span class="s2">False, </span><span class="s1">prefix=</span><span class="s2">None, </span><span class="s1">hashed_invalidation=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">dpath = cache_from_source(path</span><span class="s2">, not </span><span class="s1">optimize)</span>
        <span class="s1">logger.info(</span><span class="s3">'Byte-compiling %s to %s'</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">dpath)</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s2">if </span><span class="s1">force </span><span class="s2">or </span><span class="s1">self.newer(path</span><span class="s2">, </span><span class="s1">dpath):</span>
                <span class="s2">if not </span><span class="s1">prefix:</span>
                    <span class="s1">diagpath = </span><span class="s2">None</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">assert </span><span class="s1">path.startswith(prefix)</span>
                    <span class="s1">diagpath = path[len(prefix):]</span>
            <span class="s1">compile_kwargs = {}</span>
            <span class="s2">if </span><span class="s1">hashed_invalidation </span><span class="s2">and </span><span class="s1">hasattr(py_compile</span><span class="s2">, </span><span class="s3">'PycInvalidationMode'</span><span class="s1">):</span>
                <span class="s1">compile_kwargs[</span><span class="s3">'invalidation_mode'</span><span class="s1">] = py_compile.PycInvalidationMode.CHECKED_HASH</span>
            <span class="s1">py_compile.compile(path</span><span class="s2">, </span><span class="s1">dpath</span><span class="s2">, </span><span class="s1">diagpath</span><span class="s2">, True, </span><span class="s1">**compile_kwargs)     </span><span class="s0"># raise error</span>
        <span class="s1">self.record_as_written(dpath)</span>
        <span class="s2">return </span><span class="s1">dpath</span>

    <span class="s2">def </span><span class="s1">ensure_removed(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s2">if </span><span class="s1">os.path.exists(path):</span>
            <span class="s2">if </span><span class="s1">os.path.isdir(path) </span><span class="s2">and not </span><span class="s1">os.path.islink(path):</span>
                <span class="s1">logger.debug(</span><span class="s3">'Removing directory tree at %s'</span><span class="s2">, </span><span class="s1">path)</span>
                <span class="s2">if not </span><span class="s1">self.dry_run:</span>
                    <span class="s1">shutil.rmtree(path)</span>
                <span class="s2">if </span><span class="s1">self.record:</span>
                    <span class="s2">if </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self.dirs_created:</span>
                        <span class="s1">self.dirs_created.remove(path)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">os.path.islink(path):</span>
                    <span class="s1">s = </span><span class="s3">'link'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">s = </span><span class="s3">'file'</span>
                <span class="s1">logger.debug(</span><span class="s3">'Removing %s %s'</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">path)</span>
                <span class="s2">if not </span><span class="s1">self.dry_run:</span>
                    <span class="s1">os.remove(path)</span>
                <span class="s2">if </span><span class="s1">self.record:</span>
                    <span class="s2">if </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self.files_written:</span>
                        <span class="s1">self.files_written.remove(path)</span>

    <span class="s2">def </span><span class="s1">is_writable(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">result = </span><span class="s2">False</span>
        <span class="s2">while not </span><span class="s1">result:</span>
            <span class="s2">if </span><span class="s1">os.path.exists(path):</span>
                <span class="s1">result = os.access(path</span><span class="s2">, </span><span class="s1">os.W_OK)</span>
                <span class="s2">break</span>
            <span class="s1">parent = os.path.dirname(path)</span>
            <span class="s2">if </span><span class="s1">parent == path:</span>
                <span class="s2">break</span>
            <span class="s1">path = parent</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">commit(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Commit recorded changes, turn off recording, return 
        changes. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.record</span>
        <span class="s1">result = self.files_written</span><span class="s2">, </span><span class="s1">self.dirs_created</span>
        <span class="s1">self._init_record()</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">rollback(self):</span>
        <span class="s2">if not </span><span class="s1">self.dry_run:</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">list(self.files_written):</span>
                <span class="s2">if </span><span class="s1">os.path.exists(f):</span>
                    <span class="s1">os.remove(f)</span>
            <span class="s0"># dirs should all be empty now, except perhaps for</span>
            <span class="s0"># __pycache__ subdirs</span>
            <span class="s0"># reverse so that subdirs appear before their parents</span>
            <span class="s1">dirs = sorted(self.dirs_created</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">dirs:</span>
                <span class="s1">flist = os.listdir(d)</span>
                <span class="s2">if </span><span class="s1">flist:</span>
                    <span class="s2">assert </span><span class="s1">flist == [</span><span class="s3">'__pycache__'</span><span class="s1">]</span>
                    <span class="s1">sd = os.path.join(d</span><span class="s2">, </span><span class="s1">flist[</span><span class="s5">0</span><span class="s1">])</span>
                    <span class="s1">os.rmdir(sd)</span>
                <span class="s1">os.rmdir(d)     </span><span class="s0"># should fail if non-empty</span>
        <span class="s1">self._init_record()</span>

<span class="s2">def </span><span class="s1">resolve(module_name</span><span class="s2">, </span><span class="s1">dotted_path):</span>
    <span class="s2">if </span><span class="s1">module_name </span><span class="s2">in </span><span class="s1">sys.modules:</span>
        <span class="s1">mod = sys.modules[module_name]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">mod = __import__(module_name)</span>
    <span class="s2">if </span><span class="s1">dotted_path </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">result = mod</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">parts = dotted_path.split(</span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s1">result = getattr(mod</span><span class="s2">, </span><span class="s1">parts.pop(</span><span class="s5">0</span><span class="s1">))</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">parts:</span>
            <span class="s1">result = getattr(result</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">ExportEntry(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">flags):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.prefix = prefix</span>
        <span class="s1">self.suffix = suffix</span>
        <span class="s1">self.flags = flags</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s2">return </span><span class="s1">resolve(self.prefix</span><span class="s2">, </span><span class="s1">self.suffix)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):  </span><span class="s0"># pragma: no cover</span>
        <span class="s2">return </span><span class="s3">'&lt;ExportEntry %s = %s:%s %s&gt;' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">self.prefix</span><span class="s2">,</span>
                                                <span class="s1">self.suffix</span><span class="s2">, </span><span class="s1">self.flags)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ExportEntry):</span>
            <span class="s1">result = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = (self.name == other.name </span><span class="s2">and</span>
                      <span class="s1">self.prefix == other.prefix </span><span class="s2">and</span>
                      <span class="s1">self.suffix == other.suffix </span><span class="s2">and</span>
                      <span class="s1">self.flags == other.flags)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">__hash__ = object.__hash__</span>


<span class="s1">ENTRY_RE = re.compile(</span><span class="s3">r'''(?P&lt;name&gt;(\w|[-.+])+) 
                      \s*=\s*(?P&lt;callable&gt;(\w+)([:\.]\w+)*) 
                      \s*(\[\s*(?P&lt;flags&gt;[\w-]+(=\w+)?(,\s*\w+(=\w+)?)*)\s*\])? 
                      '''</span><span class="s2">, </span><span class="s1">re.VERBOSE)</span>

<span class="s2">def </span><span class="s1">get_export_entry(specification):</span>
    <span class="s1">m = ENTRY_RE.search(specification)</span>
    <span class="s2">if not </span><span class="s1">m:</span>
        <span class="s1">result = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s3">'[' </span><span class="s2">in </span><span class="s1">specification </span><span class="s2">or </span><span class="s3">']' </span><span class="s2">in </span><span class="s1">specification:</span>
            <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">&quot;Invalid specification &quot;</span>
                                   <span class="s3">&quot;'%s'&quot; </span><span class="s1">% specification)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">d = m.groupdict()</span>
        <span class="s1">name = d[</span><span class="s3">'name'</span><span class="s1">]</span>
        <span class="s1">path = d[</span><span class="s3">'callable'</span><span class="s1">]</span>
        <span class="s1">colons = path.count(</span><span class="s3">':'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">colons == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix = path</span><span class="s2">, None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">colons != </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">&quot;Invalid specification &quot;</span>
                                       <span class="s3">&quot;'%s'&quot; </span><span class="s1">% specification)</span>
            <span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix = path.split(</span><span class="s3">':'</span><span class="s1">)</span>
        <span class="s1">flags = d[</span><span class="s3">'flags'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">flags </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s3">'[' </span><span class="s2">in </span><span class="s1">specification </span><span class="s2">or </span><span class="s3">']' </span><span class="s2">in </span><span class="s1">specification:</span>
                <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">&quot;Invalid specification &quot;</span>
                                       <span class="s3">&quot;'%s'&quot; </span><span class="s1">% specification)</span>
            <span class="s1">flags = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">flags = [f.strip() </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">flags.split(</span><span class="s3">','</span><span class="s1">)]</span>
        <span class="s1">result = ExportEntry(name</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">flags)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">get_cache_base(suffix=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return the default base location for distlib caches. If the directory does 
    not exist, it is created. Use the suffix provided for the base directory, 
    and default to '.distlib' if it isn't provided. 
 
    On Windows, if LOCALAPPDATA is defined in the environment, then it is 
    assumed to be a directory, and will be the parent directory of the result. 
    On POSIX, and on Windows if LOCALAPPDATA is not defined, the user's home 
    directory - using os.expanduser('~') - will be the parent directory of 
    the result. 
 
    The result is just the directory '.distlib' in the parent directory as 
    determined above, or with the name specified with ``suffix``. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">suffix </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">suffix = </span><span class="s3">'.distlib'</span>
    <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'nt' </span><span class="s2">and </span><span class="s3">'LOCALAPPDATA' </span><span class="s2">in </span><span class="s1">os.environ:</span>
        <span class="s1">result = os.path.expandvars(</span><span class="s3">'$localappdata'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># Assume posix, or old Windows</span>
        <span class="s1">result = os.path.expanduser(</span><span class="s3">'~'</span><span class="s1">)</span>
    <span class="s0"># we use 'isdir' instead of 'exists', because we want to</span>
    <span class="s0"># fail if there's a file with that name</span>
    <span class="s2">if </span><span class="s1">os.path.isdir(result):</span>
        <span class="s1">usable = os.access(result</span><span class="s2">, </span><span class="s1">os.W_OK)</span>
        <span class="s2">if not </span><span class="s1">usable:</span>
            <span class="s1">logger.warning(</span><span class="s3">'Directory exists but is not writable: %s'</span><span class="s2">, </span><span class="s1">result)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">os.makedirs(result)</span>
            <span class="s1">usable = </span><span class="s2">True</span>
        <span class="s2">except </span><span class="s1">OSError:</span>
            <span class="s1">logger.warning(</span><span class="s3">'Unable to create %s'</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">exc_info=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">usable = </span><span class="s2">False</span>
    <span class="s2">if not </span><span class="s1">usable:</span>
        <span class="s1">result = tempfile.mkdtemp()</span>
        <span class="s1">logger.warning(</span><span class="s3">'Default location unusable, using %s'</span><span class="s2">, </span><span class="s1">result)</span>
    <span class="s2">return </span><span class="s1">os.path.join(result</span><span class="s2">, </span><span class="s1">suffix)</span>


<span class="s2">def </span><span class="s1">path_to_cache_dir(path):</span>
    <span class="s4">&quot;&quot;&quot; 
    Convert an absolute path to a directory name for use in a cache. 
 
    The algorithm used is: 
 
    #. On Windows, any ``':'`` in the drive is replaced with ``'---'``. 
    #. Any occurrence of ``os.sep`` is replaced with ``'--'``. 
    #. ``'.cache'`` is appended. 
    &quot;&quot;&quot;</span>
    <span class="s1">d</span><span class="s2">, </span><span class="s1">p = os.path.splitdrive(os.path.abspath(path))</span>
    <span class="s2">if </span><span class="s1">d:</span>
        <span class="s1">d = d.replace(</span><span class="s3">':'</span><span class="s2">, </span><span class="s3">'---'</span><span class="s1">)</span>
    <span class="s1">p = p.replace(os.sep</span><span class="s2">, </span><span class="s3">'--'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">d + p + </span><span class="s3">'.cache'</span>


<span class="s2">def </span><span class="s1">ensure_slash(s):</span>
    <span class="s2">if not </span><span class="s1">s.endswith(</span><span class="s3">'/'</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">s + </span><span class="s3">'/'</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">parse_credentials(netloc):</span>
    <span class="s1">username = password = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s3">'@' </span><span class="s2">in </span><span class="s1">netloc:</span>
        <span class="s1">prefix</span><span class="s2">, </span><span class="s1">netloc = netloc.rsplit(</span><span class="s3">'@'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s3">':' </span><span class="s2">not in </span><span class="s1">prefix:</span>
            <span class="s1">username = prefix</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">username</span><span class="s2">, </span><span class="s1">password = prefix.split(</span><span class="s3">':'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">username:</span>
        <span class="s1">username = unquote(username)</span>
    <span class="s2">if </span><span class="s1">password:</span>
        <span class="s1">password = unquote(password)</span>
    <span class="s2">return </span><span class="s1">username</span><span class="s2">, </span><span class="s1">password</span><span class="s2">, </span><span class="s1">netloc</span>


<span class="s2">def </span><span class="s1">get_process_umask():</span>
    <span class="s1">result = os.umask(</span><span class="s5">0o22</span><span class="s1">)</span>
    <span class="s1">os.umask(result)</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s2">def </span><span class="s1">is_string_sequence(seq):</span>
    <span class="s1">result = </span><span class="s2">True</span>
    <span class="s1">i = </span><span class="s2">None</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">enumerate(seq):</span>
        <span class="s2">if not </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">string_types):</span>
            <span class="s1">result = </span><span class="s2">False</span>
            <span class="s2">break</span>
    <span class="s2">assert </span><span class="s1">i </span><span class="s2">is not None</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s1">PROJECT_NAME_AND_VERSION = re.compile(</span><span class="s3">'([a-z0-9_]+([.-][a-z_][a-z0-9_]*)*)-'</span>
                                      <span class="s3">'([a-z0-9_.+-]+)'</span><span class="s2">, </span><span class="s1">re.I)</span>
<span class="s1">PYTHON_VERSION = re.compile(</span><span class="s3">r'-py(\d\.?\d?)'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">split_filename(filename</span><span class="s2">, </span><span class="s1">project_name=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Extract name, version, python version from a filename (no extension) 
 
    Return name, version, pyver or None 
    &quot;&quot;&quot;</span>
    <span class="s1">result = </span><span class="s2">None</span>
    <span class="s1">pyver = </span><span class="s2">None</span>
    <span class="s1">filename = unquote(filename).replace(</span><span class="s3">' '</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">)</span>
    <span class="s1">m = PYTHON_VERSION.search(filename)</span>
    <span class="s2">if </span><span class="s1">m:</span>
        <span class="s1">pyver = m.group(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">filename = filename[:m.start()]</span>
    <span class="s2">if </span><span class="s1">project_name </span><span class="s2">and </span><span class="s1">len(filename) &gt; len(project_name) + </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">m = re.match(re.escape(project_name) + </span><span class="s3">r'\b'</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">n = m.end()</span>
            <span class="s1">result = filename[:n]</span><span class="s2">, </span><span class="s1">filename[n + </span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">pyver</span>
    <span class="s2">if </span><span class="s1">result </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">m = PROJECT_NAME_AND_VERSION.match(filename)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">result = m.group(</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">m.group(</span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pyver</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s0"># Allow spaces in name because of legacy dists like &quot;Twisted Core&quot;</span>
<span class="s1">NAME_VERSION_RE = re.compile(</span><span class="s3">r'(?P&lt;name&gt;[\w .-]+)\s*'</span>
                             <span class="s3">r'\(\s*(?P&lt;ver&gt;[^\s)]+)\)$'</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">parse_name_and_version(p):</span>
    <span class="s4">&quot;&quot;&quot; 
    A utility method used to get name and version from a string. 
 
    From e.g. a Provides-Dist value. 
 
    :param p: A value in a form 'foo (1.0)' 
    :return: The name and version as a tuple. 
    &quot;&quot;&quot;</span>
    <span class="s1">m = NAME_VERSION_RE.match(p)</span>
    <span class="s2">if not </span><span class="s1">m:</span>
        <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'Ill-formed name/version string: </span><span class="s2">\'</span><span class="s3">%s</span><span class="s2">\'</span><span class="s3">' </span><span class="s1">% p)</span>
    <span class="s1">d = m.groupdict()</span>
    <span class="s2">return </span><span class="s1">d[</span><span class="s3">'name'</span><span class="s1">].strip().lower()</span><span class="s2">, </span><span class="s1">d[</span><span class="s3">'ver'</span><span class="s1">]</span>

<span class="s2">def </span><span class="s1">get_extras(requested</span><span class="s2">, </span><span class="s1">available):</span>
    <span class="s1">result = set()</span>
    <span class="s1">requested = set(requested </span><span class="s2">or </span><span class="s1">[])</span>
    <span class="s1">available = set(available </span><span class="s2">or </span><span class="s1">[])</span>
    <span class="s2">if </span><span class="s3">'*' </span><span class="s2">in </span><span class="s1">requested:</span>
        <span class="s1">requested.remove(</span><span class="s3">'*'</span><span class="s1">)</span>
        <span class="s1">result |= available</span>
    <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">requested:</span>
        <span class="s2">if </span><span class="s1">r == </span><span class="s3">'-'</span><span class="s1">:</span>
            <span class="s1">result.add(r)</span>
        <span class="s2">elif </span><span class="s1">r.startswith(</span><span class="s3">'-'</span><span class="s1">):</span>
            <span class="s1">unwanted = r[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s2">if </span><span class="s1">unwanted </span><span class="s2">not in </span><span class="s1">available:</span>
                <span class="s1">logger.warning(</span><span class="s3">'undeclared extra: %s' </span><span class="s1">% unwanted)</span>
            <span class="s2">if </span><span class="s1">unwanted </span><span class="s2">in </span><span class="s1">result:</span>
                <span class="s1">result.remove(unwanted)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">r </span><span class="s2">not in </span><span class="s1">available:</span>
                <span class="s1">logger.warning(</span><span class="s3">'undeclared extra: %s' </span><span class="s1">% r)</span>
            <span class="s1">result.add(r)</span>
    <span class="s2">return </span><span class="s1">result</span>
<span class="s0">#</span>
<span class="s0"># Extended metadata functionality</span>
<span class="s0">#</span>

<span class="s2">def </span><span class="s1">_get_external_data(url):</span>
    <span class="s1">result = {}</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s0"># urlopen might fail if it runs into redirections,</span>
        <span class="s0"># because of Python issue #13696. Fixed in locators</span>
        <span class="s0"># using a custom redirect handler.</span>
        <span class="s1">resp = urlopen(url)</span>
        <span class="s1">headers = resp.info()</span>
        <span class="s1">ct = headers.get(</span><span class="s3">'Content-Type'</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">ct.startswith(</span><span class="s3">'application/json'</span><span class="s1">):</span>
            <span class="s1">logger.debug(</span><span class="s3">'Unexpected response for JSON request: %s'</span><span class="s2">, </span><span class="s1">ct)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">reader = codecs.getreader(</span><span class="s3">'utf-8'</span><span class="s1">)(resp)</span>
            <span class="s0">#data = reader.read().decode('utf-8')</span>
            <span class="s0">#result = json.loads(data)</span>
            <span class="s1">result = json.load(reader)</span>
    <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">logger.exception(</span><span class="s3">'Failed to get external data for %s: %s'</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">e)</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s1">_external_data_base_url = </span><span class="s3">'https://www.red-dove.com/pypi/projects/'</span>

<span class="s2">def </span><span class="s1">get_project_data(name):</span>
    <span class="s1">url = </span><span class="s3">'%s/%s/project.json' </span><span class="s1">% (name[</span><span class="s5">0</span><span class="s1">].upper()</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s1">url = urljoin(_external_data_base_url</span><span class="s2">, </span><span class="s1">url)</span>
    <span class="s1">result = _get_external_data(url)</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s2">def </span><span class="s1">get_package_data(name</span><span class="s2">, </span><span class="s1">version):</span>
    <span class="s1">url = </span><span class="s3">'%s/%s/package-%s.json' </span><span class="s1">% (name[</span><span class="s5">0</span><span class="s1">].upper()</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">version)</span>
    <span class="s1">url = urljoin(_external_data_base_url</span><span class="s2">, </span><span class="s1">url)</span>
    <span class="s2">return </span><span class="s1">_get_external_data(url)</span>


<span class="s2">class </span><span class="s1">Cache(object):</span>
    <span class="s4">&quot;&quot;&quot; 
    A class implementing a cache for resources that need to live in the file system 
    e.g. shared libraries. This class was moved from resources to here because it 
    could be used by other modules, e.g. the wheel module. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base):</span>
        <span class="s4">&quot;&quot;&quot; 
        Initialise an instance. 
 
        :param base: The base directory where the cache should be located. 
        &quot;&quot;&quot;</span>
        <span class="s0"># we use 'isdir' instead of 'exists', because we want to</span>
        <span class="s0"># fail if there's a file with that name</span>
        <span class="s2">if not </span><span class="s1">os.path.isdir(base):  </span><span class="s0"># pragma: no cover</span>
            <span class="s1">os.makedirs(base)</span>
        <span class="s2">if </span><span class="s1">(os.stat(base).st_mode &amp; </span><span class="s5">0o77</span><span class="s1">) != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">logger.warning(</span><span class="s3">'Directory </span><span class="s2">\'</span><span class="s3">%s</span><span class="s2">\' </span><span class="s3">is not private'</span><span class="s2">, </span><span class="s1">base)</span>
        <span class="s1">self.base = os.path.abspath(os.path.normpath(base))</span>

    <span class="s2">def </span><span class="s1">prefix_to_dir(self</span><span class="s2">, </span><span class="s1">prefix):</span>
        <span class="s4">&quot;&quot;&quot; 
        Converts a resource prefix to a directory name in the cache. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">path_to_cache_dir(prefix)</span>

    <span class="s2">def </span><span class="s1">clear(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Clear the cache. 
        &quot;&quot;&quot;</span>
        <span class="s1">not_removed = []</span>
        <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">os.listdir(self.base):</span>
            <span class="s1">fn = os.path.join(self.base</span><span class="s2">, </span><span class="s1">fn)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">os.path.islink(fn) </span><span class="s2">or </span><span class="s1">os.path.isfile(fn):</span>
                    <span class="s1">os.remove(fn)</span>
                <span class="s2">elif </span><span class="s1">os.path.isdir(fn):</span>
                    <span class="s1">shutil.rmtree(fn)</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s1">not_removed.append(fn)</span>
        <span class="s2">return </span><span class="s1">not_removed</span>


<span class="s2">class </span><span class="s1">EventMixin(object):</span>
    <span class="s4">&quot;&quot;&quot; 
    A very simple publish/subscribe system. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._subscribers = {}</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">subscriber</span><span class="s2">, </span><span class="s1">append=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Add a subscriber for an event. 
 
        :param event: The name of an event. 
        :param subscriber: The subscriber to be added (and called when the 
                           event is published). 
        :param append: Whether to append or prepend the subscriber to an 
                       existing subscriber list for the event. 
        &quot;&quot;&quot;</span>
        <span class="s1">subs = self._subscribers</span>
        <span class="s2">if </span><span class="s1">event </span><span class="s2">not in </span><span class="s1">subs:</span>
            <span class="s1">subs[event] = deque([subscriber])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sq = subs[event]</span>
            <span class="s2">if </span><span class="s1">append:</span>
                <span class="s1">sq.append(subscriber)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">sq.appendleft(subscriber)</span>

    <span class="s2">def </span><span class="s1">remove(self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">subscriber):</span>
        <span class="s4">&quot;&quot;&quot; 
        Remove a subscriber for an event. 
 
        :param event: The name of an event. 
        :param subscriber: The subscriber to be removed. 
        &quot;&quot;&quot;</span>
        <span class="s1">subs = self._subscribers</span>
        <span class="s2">if </span><span class="s1">event </span><span class="s2">not in </span><span class="s1">subs:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'No subscribers: %r' </span><span class="s1">% event)</span>
        <span class="s1">subs[event].remove(subscriber)</span>

    <span class="s2">def </span><span class="s1">get_subscribers(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return an iterator for the subscribers for an event. 
        :param event: The event to return subscribers for. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">iter(self._subscribers.get(event</span><span class="s2">, </span><span class="s1">()))</span>

    <span class="s2">def </span><span class="s1">publish(self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4">&quot;&quot;&quot; 
        Publish a event and return a list of values returned by its 
        subscribers. 
 
        :param event: The event to publish. 
        :param args: The positional arguments to pass to the event's 
                     subscribers. 
        :param kwargs: The keyword arguments to pass to the event's 
                       subscribers. 
        &quot;&quot;&quot;</span>
        <span class="s1">result = []</span>
        <span class="s2">for </span><span class="s1">subscriber </span><span class="s2">in </span><span class="s1">self.get_subscribers(event):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">value = subscriber(event</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s1">logger.exception(</span><span class="s3">'Exception during event publication'</span><span class="s1">)</span>
                <span class="s1">value = </span><span class="s2">None</span>
            <span class="s1">result.append(value)</span>
        <span class="s1">logger.debug(</span><span class="s3">'publish %s: args = %s, kwargs = %s, result = %s'</span><span class="s2">,</span>
                     <span class="s1">event</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">result)</span>
        <span class="s2">return </span><span class="s1">result</span>

<span class="s0">#</span>
<span class="s0"># Simple sequencing</span>
<span class="s0">#</span>
<span class="s2">class </span><span class="s1">Sequencer(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._preds = {}</span>
        <span class="s1">self._succs = {}</span>
        <span class="s1">self._nodes = set()     </span><span class="s0"># nodes with no preds/succs</span>

    <span class="s2">def </span><span class="s1">add_node(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s1">self._nodes.add(node)</span>

    <span class="s2">def </span><span class="s1">remove_node(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">edges=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self._nodes:</span>
            <span class="s1">self._nodes.remove(node)</span>
        <span class="s2">if </span><span class="s1">edges:</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">set(self._preds.get(node</span><span class="s2">, </span><span class="s1">())):</span>
                <span class="s1">self.remove(p</span><span class="s2">, </span><span class="s1">node)</span>
            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">set(self._succs.get(node</span><span class="s2">, </span><span class="s1">())):</span>
                <span class="s1">self.remove(node</span><span class="s2">, </span><span class="s1">s)</span>
            <span class="s0"># Remove empties</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">list(self._preds.items()):</span>
                <span class="s2">if not </span><span class="s1">v:</span>
                    <span class="s2">del </span><span class="s1">self._preds[k]</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">list(self._succs.items()):</span>
                <span class="s2">if not </span><span class="s1">v:</span>
                    <span class="s2">del </span><span class="s1">self._succs[k]</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">pred</span><span class="s2">, </span><span class="s1">succ):</span>
        <span class="s2">assert </span><span class="s1">pred != succ</span>
        <span class="s1">self._preds.setdefault(succ</span><span class="s2">, </span><span class="s1">set()).add(pred)</span>
        <span class="s1">self._succs.setdefault(pred</span><span class="s2">, </span><span class="s1">set()).add(succ)</span>

    <span class="s2">def </span><span class="s1">remove(self</span><span class="s2">, </span><span class="s1">pred</span><span class="s2">, </span><span class="s1">succ):</span>
        <span class="s2">assert </span><span class="s1">pred != succ</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">preds = self._preds[succ]</span>
            <span class="s1">succs = self._succs[pred]</span>
        <span class="s2">except </span><span class="s1">KeyError:  </span><span class="s0"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'%r not a successor of anything' </span><span class="s1">% succ)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">preds.remove(pred)</span>
            <span class="s1">succs.remove(succ)</span>
        <span class="s2">except </span><span class="s1">KeyError:  </span><span class="s0"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'%r not a successor of %r' </span><span class="s1">% (succ</span><span class="s2">, </span><span class="s1">pred))</span>

    <span class="s2">def </span><span class="s1">is_step(self</span><span class="s2">, </span><span class="s1">step):</span>
        <span class="s2">return </span><span class="s1">(step </span><span class="s2">in </span><span class="s1">self._preds </span><span class="s2">or </span><span class="s1">step </span><span class="s2">in </span><span class="s1">self._succs </span><span class="s2">or</span>
                <span class="s1">step </span><span class="s2">in </span><span class="s1">self._nodes)</span>

    <span class="s2">def </span><span class="s1">get_steps(self</span><span class="s2">, </span><span class="s1">final):</span>
        <span class="s2">if not </span><span class="s1">self.is_step(final):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown: %r' </span><span class="s1">% final)</span>
        <span class="s1">result = []</span>
        <span class="s1">todo = []</span>
        <span class="s1">seen = set()</span>
        <span class="s1">todo.append(final)</span>
        <span class="s2">while </span><span class="s1">todo:</span>
            <span class="s1">step = todo.pop(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">step </span><span class="s2">in </span><span class="s1">seen:</span>
                <span class="s0"># if a step was already seen,</span>
                <span class="s0"># move it to the end (so it will appear earlier</span>
                <span class="s0"># when reversed on return) ... but not for the</span>
                <span class="s0"># final step, as that would be confusing for</span>
                <span class="s0"># users</span>
                <span class="s2">if </span><span class="s1">step != final:</span>
                    <span class="s1">result.remove(step)</span>
                    <span class="s1">result.append(step)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">seen.add(step)</span>
                <span class="s1">result.append(step)</span>
                <span class="s1">preds = self._preds.get(step</span><span class="s2">, </span><span class="s1">())</span>
                <span class="s1">todo.extend(preds)</span>
        <span class="s2">return </span><span class="s1">reversed(result)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">strong_connections(self):</span>
        <span class="s0">#http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</span>
        <span class="s1">index_counter = [</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">stack = []</span>
        <span class="s1">lowlinks = {}</span>
        <span class="s1">index = {}</span>
        <span class="s1">result = []</span>

        <span class="s1">graph = self._succs</span>

        <span class="s2">def </span><span class="s1">strongconnect(node):</span>
            <span class="s0"># set the depth index for this node to the smallest unused index</span>
            <span class="s1">index[node] = index_counter[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">lowlinks[node] = index_counter[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">index_counter[</span><span class="s5">0</span><span class="s1">] += </span><span class="s5">1</span>
            <span class="s1">stack.append(node)</span>

            <span class="s0"># Consider successors</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">successors = graph[node]</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s1">successors = []</span>
            <span class="s2">for </span><span class="s1">successor </span><span class="s2">in </span><span class="s1">successors:</span>
                <span class="s2">if </span><span class="s1">successor </span><span class="s2">not in </span><span class="s1">lowlinks:</span>
                    <span class="s0"># Successor has not yet been visited</span>
                    <span class="s1">strongconnect(successor)</span>
                    <span class="s1">lowlinks[node] = min(lowlinks[node]</span><span class="s2">,</span><span class="s1">lowlinks[successor])</span>
                <span class="s2">elif </span><span class="s1">successor </span><span class="s2">in </span><span class="s1">stack:</span>
                    <span class="s0"># the successor is in the stack and hence in the current</span>
                    <span class="s0"># strongly connected component (SCC)</span>
                    <span class="s1">lowlinks[node] = min(lowlinks[node]</span><span class="s2">,</span><span class="s1">index[successor])</span>

            <span class="s0"># If `node` is a root node, pop the stack and generate an SCC</span>
            <span class="s2">if </span><span class="s1">lowlinks[node] == index[node]:</span>
                <span class="s1">connected_component = []</span>

                <span class="s2">while True</span><span class="s1">:</span>
                    <span class="s1">successor = stack.pop()</span>
                    <span class="s1">connected_component.append(successor)</span>
                    <span class="s2">if </span><span class="s1">successor == node: </span><span class="s2">break</span>
                <span class="s1">component = tuple(connected_component)</span>
                <span class="s0"># storing the result</span>
                <span class="s1">result.append(component)</span>

        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">graph:</span>
            <span class="s2">if </span><span class="s1">node </span><span class="s2">not in </span><span class="s1">lowlinks:</span>
                <span class="s1">strongconnect(node)</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dot(self):</span>
        <span class="s1">result = [</span><span class="s3">'digraph G {'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">succ </span><span class="s2">in </span><span class="s1">self._preds:</span>
            <span class="s1">preds = self._preds[succ]</span>
            <span class="s2">for </span><span class="s1">pred </span><span class="s2">in </span><span class="s1">preds:</span>
                <span class="s1">result.append(</span><span class="s3">'  %s -&gt; %s;' </span><span class="s1">% (pred</span><span class="s2">, </span><span class="s1">succ))</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self._nodes:</span>
            <span class="s1">result.append(</span><span class="s3">'  %s;' </span><span class="s1">% node)</span>
        <span class="s1">result.append(</span><span class="s3">'}'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(result)</span>

<span class="s0">#</span>
<span class="s0"># Unarchiving functionality for zip, tar, tgz, tbz, whl</span>
<span class="s0">#</span>

<span class="s1">ARCHIVE_EXTENSIONS = (</span><span class="s3">'.tar.gz'</span><span class="s2">, </span><span class="s3">'.tar.bz2'</span><span class="s2">, </span><span class="s3">'.tar'</span><span class="s2">, </span><span class="s3">'.zip'</span><span class="s2">,</span>
                      <span class="s3">'.tgz'</span><span class="s2">, </span><span class="s3">'.tbz'</span><span class="s2">, </span><span class="s3">'.whl'</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">unarchive(archive_filename</span><span class="s2">, </span><span class="s1">dest_dir</span><span class="s2">, </span><span class="s1">format=</span><span class="s2">None, </span><span class="s1">check=</span><span class="s2">True</span><span class="s1">):</span>

    <span class="s2">def </span><span class="s1">check_path(path):</span>
        <span class="s2">if not </span><span class="s1">isinstance(path</span><span class="s2">, </span><span class="s1">text_type):</span>
            <span class="s1">path = path.decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
        <span class="s1">p = os.path.abspath(os.path.join(dest_dir</span><span class="s2">, </span><span class="s1">path))</span>
        <span class="s2">if not </span><span class="s1">p.startswith(dest_dir) </span><span class="s2">or </span><span class="s1">p[plen] != os.sep:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'path outside destination: %r' </span><span class="s1">% p)</span>

    <span class="s1">dest_dir = os.path.abspath(dest_dir)</span>
    <span class="s1">plen = len(dest_dir)</span>
    <span class="s1">archive = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">format </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">archive_filename.endswith((</span><span class="s3">'.zip'</span><span class="s2">, </span><span class="s3">'.whl'</span><span class="s1">)):</span>
            <span class="s1">format = </span><span class="s3">'zip'</span>
        <span class="s2">elif </span><span class="s1">archive_filename.endswith((</span><span class="s3">'.tar.gz'</span><span class="s2">, </span><span class="s3">'.tgz'</span><span class="s1">)):</span>
            <span class="s1">format = </span><span class="s3">'tgz'</span>
            <span class="s1">mode = </span><span class="s3">'r:gz'</span>
        <span class="s2">elif </span><span class="s1">archive_filename.endswith((</span><span class="s3">'.tar.bz2'</span><span class="s2">, </span><span class="s3">'.tbz'</span><span class="s1">)):</span>
            <span class="s1">format = </span><span class="s3">'tbz'</span>
            <span class="s1">mode = </span><span class="s3">'r:bz2'</span>
        <span class="s2">elif </span><span class="s1">archive_filename.endswith(</span><span class="s3">'.tar'</span><span class="s1">):</span>
            <span class="s1">format = </span><span class="s3">'tar'</span>
            <span class="s1">mode = </span><span class="s3">'r'</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s0"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown format for %r' </span><span class="s1">% archive_filename)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">format == </span><span class="s3">'zip'</span><span class="s1">:</span>
            <span class="s1">archive = ZipFile(archive_filename</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">check:</span>
                <span class="s1">names = archive.namelist()</span>
                <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
                    <span class="s1">check_path(name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">archive = tarfile.open(archive_filename</span><span class="s2">, </span><span class="s1">mode)</span>
            <span class="s2">if </span><span class="s1">check:</span>
                <span class="s1">names = archive.getnames()</span>
                <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
                    <span class="s1">check_path(name)</span>
        <span class="s2">if </span><span class="s1">format != </span><span class="s3">'zip' </span><span class="s2">and </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s0"># See Python issue 17153. If the dest path contains Unicode,</span>
            <span class="s0"># tarfile extraction fails on Python 2.x if a member path name</span>
            <span class="s0"># contains non-ASCII characters - it leads to an implicit</span>
            <span class="s0"># bytes -&gt; unicode conversion using ASCII to decode.</span>
            <span class="s2">for </span><span class="s1">tarinfo </span><span class="s2">in </span><span class="s1">archive.getmembers():</span>
                <span class="s2">if not </span><span class="s1">isinstance(tarinfo.name</span><span class="s2">, </span><span class="s1">text_type):</span>
                    <span class="s1">tarinfo.name = tarinfo.name.decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
        <span class="s1">archive.extractall(dest_dir)</span>

    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">archive:</span>
            <span class="s1">archive.close()</span>


<span class="s2">def </span><span class="s1">zip_dir(directory):</span>
    <span class="s4">&quot;&quot;&quot;zip a directory tree into a BytesIO object&quot;&quot;&quot;</span>
    <span class="s1">result = io.BytesIO()</span>
    <span class="s1">dlen = len(directory)</span>
    <span class="s2">with </span><span class="s1">ZipFile(result</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">zf:</span>
        <span class="s2">for </span><span class="s1">root</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">os.walk(directory):</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">files:</span>
                <span class="s1">full = os.path.join(root</span><span class="s2">, </span><span class="s1">name)</span>
                <span class="s1">rel = root[dlen:]</span>
                <span class="s1">dest = os.path.join(rel</span><span class="s2">, </span><span class="s1">name)</span>
                <span class="s1">zf.write(full</span><span class="s2">, </span><span class="s1">dest)</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s0">#</span>
<span class="s0"># Simple progress bar</span>
<span class="s0">#</span>

<span class="s1">UNITS = (</span><span class="s3">''</span><span class="s2">, </span><span class="s3">'K'</span><span class="s2">, </span><span class="s3">'M'</span><span class="s2">, </span><span class="s3">'G'</span><span class="s2">,</span><span class="s3">'T'</span><span class="s2">,</span><span class="s3">'P'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Progress(object):</span>
    <span class="s1">unknown = </span><span class="s3">'UNKNOWN'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">minval=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">maxval=</span><span class="s5">100</span><span class="s1">):</span>
        <span class="s2">assert </span><span class="s1">maxval </span><span class="s2">is None or </span><span class="s1">maxval &gt;= minval</span>
        <span class="s1">self.min = self.cur = minval</span>
        <span class="s1">self.max = maxval</span>
        <span class="s1">self.started = </span><span class="s2">None</span>
        <span class="s1">self.elapsed = </span><span class="s5">0</span>
        <span class="s1">self.done = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">curval):</span>
        <span class="s2">assert </span><span class="s1">self.min &lt;= curval</span>
        <span class="s2">assert </span><span class="s1">self.max </span><span class="s2">is None or </span><span class="s1">curval &lt;= self.max</span>
        <span class="s1">self.cur = curval</span>
        <span class="s1">now = time.time()</span>
        <span class="s2">if </span><span class="s1">self.started </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.started = now</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.elapsed = now - self.started</span>

    <span class="s2">def </span><span class="s1">increment(self</span><span class="s2">, </span><span class="s1">incr):</span>
        <span class="s2">assert </span><span class="s1">incr &gt;= </span><span class="s5">0</span>
        <span class="s1">self.update(self.cur + incr)</span>

    <span class="s2">def </span><span class="s1">start(self):</span>
        <span class="s1">self.update(self.min)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">stop(self):</span>
        <span class="s2">if </span><span class="s1">self.max </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.update(self.max)</span>
        <span class="s1">self.done = </span><span class="s2">True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">maximum(self):</span>
        <span class="s2">return </span><span class="s1">self.unknown </span><span class="s2">if </span><span class="s1">self.max </span><span class="s2">is None else </span><span class="s1">self.max</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">percentage(self):</span>
        <span class="s2">if </span><span class="s1">self.done:</span>
            <span class="s1">result = </span><span class="s3">'100 %'</span>
        <span class="s2">elif </span><span class="s1">self.max </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">result = </span><span class="s3">' ?? %'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">v = </span><span class="s5">100.0 </span><span class="s1">* (self.cur - self.min) / (self.max - self.min)</span>
            <span class="s1">result = </span><span class="s3">'%3d %%' </span><span class="s1">% v</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">format_duration(self</span><span class="s2">, </span><span class="s1">duration):</span>
        <span class="s2">if </span><span class="s1">(duration &lt;= </span><span class="s5">0</span><span class="s1">) </span><span class="s2">and </span><span class="s1">self.max </span><span class="s2">is None or </span><span class="s1">self.cur == self.min:</span>
            <span class="s1">result = </span><span class="s3">'??:??:??'</span>
        <span class="s0">#elif duration &lt; 1:</span>
        <span class="s0">#    result = '--:--:--'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = time.strftime(</span><span class="s3">'%H:%M:%S'</span><span class="s2">, </span><span class="s1">time.gmtime(duration))</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ETA(self):</span>
        <span class="s2">if </span><span class="s1">self.done:</span>
            <span class="s1">prefix = </span><span class="s3">'Done'</span>
            <span class="s1">t = self.elapsed</span>
            <span class="s0">#import pdb; pdb.set_trace()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">prefix = </span><span class="s3">'ETA '</span>
            <span class="s2">if </span><span class="s1">self.max </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">t = -</span><span class="s5">1</span>
            <span class="s2">elif </span><span class="s1">self.elapsed == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">(self.cur == self.min):</span>
                <span class="s1">t = </span><span class="s5">0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0">#import pdb; pdb.set_trace()</span>
                <span class="s1">t = float(self.max - self.min)</span>
                <span class="s1">t /= self.cur - self.min</span>
                <span class="s1">t = (t - </span><span class="s5">1</span><span class="s1">) * self.elapsed</span>
        <span class="s2">return </span><span class="s3">'%s: %s' </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">self.format_duration(t))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">speed(self):</span>
        <span class="s2">if </span><span class="s1">self.elapsed == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">result = </span><span class="s5">0.0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = (self.cur - self.min) / self.elapsed</span>
        <span class="s2">for </span><span class="s1">unit </span><span class="s2">in </span><span class="s1">UNITS:</span>
            <span class="s2">if </span><span class="s1">result &lt; </span><span class="s5">1000</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s1">result /= </span><span class="s5">1000.0</span>
        <span class="s2">return </span><span class="s3">'%d %sB/s' </span><span class="s1">% (result</span><span class="s2">, </span><span class="s1">unit)</span>

<span class="s0">#</span>
<span class="s0"># Glob functionality</span>
<span class="s0">#</span>

<span class="s1">RICH_GLOB = re.compile(</span><span class="s3">r'\{([^}]*)\}'</span><span class="s1">)</span>
<span class="s1">_CHECK_RECURSIVE_GLOB = re.compile(</span><span class="s3">r'[^/\\,{]\*\*|\*\*[^/\\,}]'</span><span class="s1">)</span>
<span class="s1">_CHECK_MISMATCH_SET = re.compile(</span><span class="s3">r'^[^{]*\}|\{[^}]*$'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">iglob(path_glob):</span>
    <span class="s4">&quot;&quot;&quot;Extended globbing function that supports ** and {opt1,opt2,opt3}.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_CHECK_RECURSIVE_GLOB.search(path_glob):</span>
        <span class="s1">msg = </span><span class="s3">&quot;&quot;&quot;invalid glob %r: recursive glob &quot;**&quot; must be used alone&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg % path_glob)</span>
    <span class="s2">if </span><span class="s1">_CHECK_MISMATCH_SET.search(path_glob):</span>
        <span class="s1">msg = </span><span class="s3">&quot;&quot;&quot;invalid glob %r: mismatching set marker '{' or '}'&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg % path_glob)</span>
    <span class="s2">return </span><span class="s1">_iglob(path_glob)</span>


<span class="s2">def </span><span class="s1">_iglob(path_glob):</span>
    <span class="s1">rich_path_glob = RICH_GLOB.split(path_glob</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(rich_path_glob) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">len(rich_path_glob) == </span><span class="s5">3</span><span class="s2">, </span><span class="s1">rich_path_glob</span>
        <span class="s1">prefix</span><span class="s2">, </span><span class="s1">set</span><span class="s2">, </span><span class="s1">suffix = rich_path_glob</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">set.split(</span><span class="s3">','</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">_iglob(</span><span class="s3">''</span><span class="s1">.join((prefix</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">suffix))):</span>
                <span class="s2">yield </span><span class="s1">path</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s3">'**' </span><span class="s2">not in </span><span class="s1">path_glob:</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">std_iglob(path_glob):</span>
                <span class="s2">yield </span><span class="s1">item</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">prefix</span><span class="s2">, </span><span class="s1">radical = path_glob.split(</span><span class="s3">'**'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">prefix == </span><span class="s3">''</span><span class="s1">:</span>
                <span class="s1">prefix = </span><span class="s3">'.'</span>
            <span class="s2">if </span><span class="s1">radical == </span><span class="s3">''</span><span class="s1">:</span>
                <span class="s1">radical = </span><span class="s3">'*'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># we support both</span>
                <span class="s1">radical = radical.lstrip(</span><span class="s3">'/'</span><span class="s1">)</span>
                <span class="s1">radical = radical.lstrip(</span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">path</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">os.walk(prefix):</span>
                <span class="s1">path = os.path.normpath(path)</span>
                <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">_iglob(os.path.join(path</span><span class="s2">, </span><span class="s1">radical)):</span>
                    <span class="s2">yield </span><span class="s1">fn</span>

<span class="s2">if </span><span class="s1">ssl:</span>
    <span class="s2">from </span><span class="s1">.compat </span><span class="s2">import </span><span class="s1">(HTTPSHandler </span><span class="s2">as </span><span class="s1">BaseHTTPSHandler</span><span class="s2">, </span><span class="s1">match_hostname</span><span class="s2">,</span>
                         <span class="s1">CertificateError)</span>


<span class="s0">#</span>
<span class="s0"># HTTPSConnection which verifies certificates/matches domains</span>
<span class="s0">#</span>

    <span class="s2">class </span><span class="s1">HTTPSConnection(httplib.HTTPSConnection):</span>
        <span class="s1">ca_certs = </span><span class="s2">None </span><span class="s0"># set this to the path to the certs file (.pem)</span>
        <span class="s1">check_domain = </span><span class="s2">True </span><span class="s0"># only used if ca_certs is not None</span>

        <span class="s0"># noinspection PyPropertyAccess</span>
        <span class="s2">def </span><span class="s1">connect(self):</span>
            <span class="s1">sock = socket.create_connection((self.host</span><span class="s2">, </span><span class="s1">self.port)</span><span class="s2">, </span><span class="s1">self.timeout)</span>
            <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">'_tunnel_host'</span><span class="s2">, False</span><span class="s1">):</span>
                <span class="s1">self.sock = sock</span>
                <span class="s1">self._tunnel()</span>

            <span class="s1">context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)</span>
            <span class="s2">if </span><span class="s1">hasattr(ssl</span><span class="s2">, </span><span class="s3">'OP_NO_SSLv2'</span><span class="s1">):</span>
                <span class="s1">context.options |= ssl.OP_NO_SSLv2</span>
            <span class="s2">if </span><span class="s1">self.cert_file:</span>
                <span class="s1">context.load_cert_chain(self.cert_file</span><span class="s2">, </span><span class="s1">self.key_file)</span>
            <span class="s1">kwargs = {}</span>
            <span class="s2">if </span><span class="s1">self.ca_certs:</span>
                <span class="s1">context.verify_mode = ssl.CERT_REQUIRED</span>
                <span class="s1">context.load_verify_locations(cafile=self.ca_certs)</span>
                <span class="s2">if </span><span class="s1">getattr(ssl</span><span class="s2">, </span><span class="s3">'HAS_SNI'</span><span class="s2">, False</span><span class="s1">):</span>
                    <span class="s1">kwargs[</span><span class="s3">'server_hostname'</span><span class="s1">] = self.host</span>

            <span class="s1">self.sock = context.wrap_socket(sock</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">if </span><span class="s1">self.ca_certs </span><span class="s2">and </span><span class="s1">self.check_domain:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">match_hostname(self.sock.getpeercert()</span><span class="s2">, </span><span class="s1">self.host)</span>
                    <span class="s1">logger.debug(</span><span class="s3">'Host verified: %s'</span><span class="s2">, </span><span class="s1">self.host)</span>
                <span class="s2">except </span><span class="s1">CertificateError:  </span><span class="s0"># pragma: no cover</span>
                    <span class="s1">self.sock.shutdown(socket.SHUT_RDWR)</span>
                    <span class="s1">self.sock.close()</span>
                    <span class="s2">raise</span>

    <span class="s2">class </span><span class="s1">HTTPSHandler(BaseHTTPSHandler):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ca_certs</span><span class="s2">, </span><span class="s1">check_domain=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">BaseHTTPSHandler.__init__(self)</span>
            <span class="s1">self.ca_certs = ca_certs</span>
            <span class="s1">self.check_domain = check_domain</span>

        <span class="s2">def </span><span class="s1">_conn_maker(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s4">&quot;&quot;&quot; 
            This is called to create a connection instance. Normally you'd 
            pass a connection class to do_open, but it doesn't actually check for 
            a class, and just expects a callable. As long as we behave just as a 
            constructor would have, we should be OK. If it ever changes so that 
            we *must* pass a class, we'll create an UnsafeHTTPSConnection class 
            which just sets check_domain to False in the class definition, and 
            choose which one to pass to do_open. 
            &quot;&quot;&quot;</span>
            <span class="s1">result = HTTPSConnection(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">if </span><span class="s1">self.ca_certs:</span>
                <span class="s1">result.ca_certs = self.ca_certs</span>
                <span class="s1">result.check_domain = self.check_domain</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">def </span><span class="s1">https_open(self</span><span class="s2">, </span><span class="s1">req):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.do_open(self._conn_maker</span><span class="s2">, </span><span class="s1">req)</span>
            <span class="s2">except </span><span class="s1">URLError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">if </span><span class="s3">'certificate verify failed' </span><span class="s2">in </span><span class="s1">str(e.reason):</span>
                    <span class="s2">raise </span><span class="s1">CertificateError(</span><span class="s3">'Unable to verify server certificate '</span>
                                           <span class="s3">'for %s' </span><span class="s1">% req.host)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise</span>

    <span class="s0">#</span>
    <span class="s0"># To prevent against mixing HTTP traffic with HTTPS (examples: A Man-In-The-</span>
    <span class="s0"># Middle proxy using HTTP listens on port 443, or an index mistakenly serves</span>
    <span class="s0"># HTML containing a http://xyz link when it should be https://xyz),</span>
    <span class="s0"># you can use the following handler class, which does not allow HTTP traffic.</span>
    <span class="s0">#</span>
    <span class="s0"># It works by inheriting from HTTPHandler - so build_opener won't add a</span>
    <span class="s0"># handler for HTTP itself.</span>
    <span class="s0">#</span>
    <span class="s2">class </span><span class="s1">HTTPSOnlyHandler(HTTPSHandler</span><span class="s2">, </span><span class="s1">HTTPHandler):</span>
        <span class="s2">def </span><span class="s1">http_open(self</span><span class="s2">, </span><span class="s1">req):</span>
            <span class="s2">raise </span><span class="s1">URLError(</span><span class="s3">'Unexpected HTTP request on what should be a secure '</span>
                           <span class="s3">'connection: %s' </span><span class="s1">% req)</span>

<span class="s0">#</span>
<span class="s0"># XML-RPC with timeouts</span>
<span class="s0">#</span>
<span class="s2">class </span><span class="s1">Transport(xmlrpclib.Transport):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">, </span><span class="s1">use_datetime=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self.timeout = timeout</span>
        <span class="s1">xmlrpclib.Transport.__init__(self</span><span class="s2">, </span><span class="s1">use_datetime)</span>

    <span class="s2">def </span><span class="s1">make_connection(self</span><span class="s2">, </span><span class="s1">host):</span>
        <span class="s1">h</span><span class="s2">, </span><span class="s1">eh</span><span class="s2">, </span><span class="s1">x509 = self.get_host_info(host)</span>
        <span class="s2">if not </span><span class="s1">self._connection </span><span class="s2">or </span><span class="s1">host != self._connection[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">self._extra_headers = eh</span>
            <span class="s1">self._connection = host</span><span class="s2">, </span><span class="s1">httplib.HTTPConnection(h)</span>
        <span class="s2">return </span><span class="s1">self._connection[</span><span class="s5">1</span><span class="s1">]</span>

<span class="s2">if </span><span class="s1">ssl:</span>
    <span class="s2">class </span><span class="s1">SafeTransport(xmlrpclib.SafeTransport):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">, </span><span class="s1">use_datetime=</span><span class="s5">0</span><span class="s1">):</span>
            <span class="s1">self.timeout = timeout</span>
            <span class="s1">xmlrpclib.SafeTransport.__init__(self</span><span class="s2">, </span><span class="s1">use_datetime)</span>

        <span class="s2">def </span><span class="s1">make_connection(self</span><span class="s2">, </span><span class="s1">host):</span>
            <span class="s1">h</span><span class="s2">, </span><span class="s1">eh</span><span class="s2">, </span><span class="s1">kwargs = self.get_host_info(host)</span>
            <span class="s2">if not </span><span class="s1">kwargs:</span>
                <span class="s1">kwargs = {}</span>
            <span class="s1">kwargs[</span><span class="s3">'timeout'</span><span class="s1">] = self.timeout</span>
            <span class="s2">if not </span><span class="s1">self._connection </span><span class="s2">or </span><span class="s1">host != self._connection[</span><span class="s5">0</span><span class="s1">]:</span>
                <span class="s1">self._extra_headers = eh</span>
                <span class="s1">self._connection = host</span><span class="s2">, </span><span class="s1">httplib.HTTPSConnection(h</span><span class="s2">, None,</span>
                                                                 <span class="s1">**kwargs)</span>
            <span class="s2">return </span><span class="s1">self._connection[</span><span class="s5">1</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">ServerProxy(xmlrpclib.ServerProxy):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">uri</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.timeout = timeout = kwargs.pop(</span><span class="s3">'timeout'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s0"># The above classes only come into play if a timeout</span>
        <span class="s0"># is specified</span>
        <span class="s2">if </span><span class="s1">timeout </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># scheme = splittype(uri)  # deprecated as of Python 3.8</span>
            <span class="s1">scheme = urlparse(uri)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">use_datetime = kwargs.get(</span><span class="s3">'use_datetime'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">scheme == </span><span class="s3">'https'</span><span class="s1">:</span>
                <span class="s1">tcls = SafeTransport</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">tcls = Transport</span>
            <span class="s1">kwargs[</span><span class="s3">'transport'</span><span class="s1">] = t = tcls(timeout</span><span class="s2">, </span><span class="s1">use_datetime=use_datetime)</span>
            <span class="s1">self.transport = t</span>
        <span class="s1">xmlrpclib.ServerProxy.__init__(self</span><span class="s2">, </span><span class="s1">uri</span><span class="s2">, </span><span class="s1">**kwargs)</span>

<span class="s0">#</span>
<span class="s0"># CSV functionality. This is provided because on 2.x, the csv module can't</span>
<span class="s0"># handle Unicode. However, we need to deal with Unicode in e.g. RECORD files.</span>
<span class="s0">#</span>

<span class="s2">def </span><span class="s1">_csv_open(fn</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s1">mode += </span><span class="s3">'b'</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">kwargs[</span><span class="s3">'newline'</span><span class="s1">] = </span><span class="s3">''</span>
        <span class="s0"># Python 3 determines encoding from locale. Force 'utf-8'</span>
        <span class="s0"># file encoding to match other forced utf-8 encoding</span>
        <span class="s1">kwargs[</span><span class="s3">'encoding'</span><span class="s1">] = </span><span class="s3">'utf-8'</span>
    <span class="s2">return </span><span class="s1">open(fn</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">CSVBase(object):</span>
    <span class="s1">defaults = {</span>
        <span class="s3">'delimiter'</span><span class="s1">: str(</span><span class="s3">','</span><span class="s1">)</span><span class="s2">,      </span><span class="s0"># The strs are used because we need native</span>
        <span class="s3">'quotechar'</span><span class="s1">: str(</span><span class="s3">'&quot;'</span><span class="s1">)</span><span class="s2">,      </span><span class="s0"># str in the csv API (2.x won't take</span>
        <span class="s3">'lineterminator'</span><span class="s1">: str(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) </span><span class="s0"># Unicode)</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">*exc_info):</span>
        <span class="s1">self.stream.close()</span>


<span class="s2">class </span><span class="s1">CSVReader(CSVBase):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s3">'stream' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">stream = kwargs[</span><span class="s3">'stream'</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] &gt;= </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s0"># needs to be a text stream</span>
                <span class="s1">stream = codecs.getreader(</span><span class="s3">'utf-8'</span><span class="s1">)(stream)</span>
            <span class="s1">self.stream = stream</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.stream = _csv_open(kwargs[</span><span class="s3">'path'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">)</span>
        <span class="s1">self.reader = csv.reader(self.stream</span><span class="s2">, </span><span class="s1">**self.defaults)</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">next(self):</span>
        <span class="s1">result = next(self.reader)</span>
        <span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">item </span><span class="s2">in </span><span class="s1">enumerate(result):</span>
                <span class="s2">if not </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">text_type):</span>
                    <span class="s1">result[i] = item.decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">__next__ = next</span>

<span class="s2">class </span><span class="s1">CSVWriter(CSVBase):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.stream = _csv_open(fn</span><span class="s2">, </span><span class="s3">'w'</span><span class="s1">)</span>
        <span class="s1">self.writer = csv.writer(self.stream</span><span class="s2">, </span><span class="s1">**self.defaults)</span>

    <span class="s2">def </span><span class="s1">writerow(self</span><span class="s2">, </span><span class="s1">row):</span>
        <span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">r = []</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">row:</span>
                <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">text_type):</span>
                    <span class="s1">item = item.encode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
                <span class="s1">r.append(item)</span>
            <span class="s1">row = r</span>
        <span class="s1">self.writer.writerow(row)</span>

<span class="s0">#</span>
<span class="s0">#   Configurator functionality</span>
<span class="s0">#</span>

<span class="s2">class </span><span class="s1">Configurator(BaseConfigurator):</span>

    <span class="s1">value_converters = dict(BaseConfigurator.value_converters)</span>
    <span class="s1">value_converters[</span><span class="s3">'inc'</span><span class="s1">] = </span><span class="s3">'inc_convert'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">config</span><span class="s2">, </span><span class="s1">base=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super(Configurator</span><span class="s2">, </span><span class="s1">self).__init__(config)</span>
        <span class="s1">self.base = base </span><span class="s2">or </span><span class="s1">os.getcwd()</span>

    <span class="s2">def </span><span class="s1">configure_custom(self</span><span class="s2">, </span><span class="s1">config):</span>
        <span class="s2">def </span><span class="s1">convert(o):</span>
            <span class="s2">if </span><span class="s1">isinstance(o</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                <span class="s1">result = type(o)([convert(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">o])</span>
            <span class="s2">elif </span><span class="s1">isinstance(o</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s2">if </span><span class="s3">'()' </span><span class="s2">in </span><span class="s1">o:</span>
                    <span class="s1">result = self.configure_custom(o)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">result = {}</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">o:</span>
                        <span class="s1">result[k] = convert(o[k])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">result = self.convert(o)</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s1">c = config.pop(</span><span class="s3">'()'</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">callable(c):</span>
            <span class="s1">c = self.resolve(c)</span>
        <span class="s1">props = config.pop(</span><span class="s3">'.'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s0"># Check for valid identifiers</span>
        <span class="s1">args = config.pop(</span><span class="s3">'[]'</span><span class="s2">, </span><span class="s1">())</span>
        <span class="s2">if </span><span class="s1">args:</span>
            <span class="s1">args = tuple([convert(o) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">args])</span>
        <span class="s1">items = [(k</span><span class="s2">, </span><span class="s1">convert(config[k])) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">config </span><span class="s2">if </span><span class="s1">valid_ident(k)]</span>
        <span class="s1">kwargs = dict(items)</span>
        <span class="s1">result = c(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">if </span><span class="s1">props:</span>
            <span class="s2">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">props.items():</span>
                <span class="s1">setattr(result</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">convert(v))</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s1">result = self.config[key]</span>
        <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">and </span><span class="s3">'()' </span><span class="s2">in </span><span class="s1">result:</span>
            <span class="s1">self.config[key] = result = self.configure_custom(result)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">inc_convert(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s4">&quot;&quot;&quot;Default converter for the inc:// protocol.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">os.path.isabs(value):</span>
            <span class="s1">value = os.path.join(self.base</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">with </span><span class="s1">codecs.open(value</span><span class="s2">, </span><span class="s3">'r'</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s3">'utf-8'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">result = json.load(f)</span>
        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">SubprocessMixin(object):</span>
    <span class="s4">&quot;&quot;&quot; 
    Mixin for running subprocesses and capturing their output 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s2">False, </span><span class="s1">progress=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.verbose = verbose</span>
        <span class="s1">self.progress = progress</span>

    <span class="s2">def </span><span class="s1">reader(self</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">context):</span>
        <span class="s4">&quot;&quot;&quot; 
        Read lines from a subprocess' output stream and either pass to a progress 
        callable (if specified) or write progress information to sys.stderr. 
        &quot;&quot;&quot;</span>
        <span class="s1">progress = self.progress</span>
        <span class="s1">verbose = self.verbose</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">s = stream.readline()</span>
            <span class="s2">if not </span><span class="s1">s:</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">progress </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">progress(s</span><span class="s2">, </span><span class="s1">context)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">verbose:</span>
                    <span class="s1">sys.stderr.write(</span><span class="s3">'.'</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">sys.stderr.write(s.decode(</span><span class="s3">'utf-8'</span><span class="s1">))</span>
                <span class="s1">sys.stderr.flush()</span>
        <span class="s1">stream.close()</span>

    <span class="s2">def </span><span class="s1">run_command(self</span><span class="s2">, </span><span class="s1">cmd</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">p = subprocess.Popen(cmd</span><span class="s2">, </span><span class="s1">stdout=subprocess.PIPE</span><span class="s2">,</span>
                             <span class="s1">stderr=subprocess.PIPE</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">t1 = threading.Thread(target=self.reader</span><span class="s2">, </span><span class="s1">args=(p.stdout</span><span class="s2">, </span><span class="s3">'stdout'</span><span class="s1">))</span>
        <span class="s1">t1.start()</span>
        <span class="s1">t2 = threading.Thread(target=self.reader</span><span class="s2">, </span><span class="s1">args=(p.stderr</span><span class="s2">, </span><span class="s3">'stderr'</span><span class="s1">))</span>
        <span class="s1">t2.start()</span>
        <span class="s1">p.wait()</span>
        <span class="s1">t1.join()</span>
        <span class="s1">t2.join()</span>
        <span class="s2">if </span><span class="s1">self.progress </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.progress(</span><span class="s3">'done.'</span><span class="s2">, </span><span class="s3">'main'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.verbose:</span>
            <span class="s1">sys.stderr.write(</span><span class="s3">'done.</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">p</span>


<span class="s2">def </span><span class="s1">normalize_name(name):</span>
    <span class="s4">&quot;&quot;&quot;Normalize a python package name a la PEP 503&quot;&quot;&quot;</span>
    <span class="s0"># https://www.python.org/dev/peps/pep-0503/#normalized-names</span>
    <span class="s2">return </span><span class="s1">re.sub(</span><span class="s3">'[-_.]+'</span><span class="s2">, </span><span class="s3">'-'</span><span class="s2">, </span><span class="s1">name).lower()</span>

<span class="s0"># def _get_pypirc_command():</span>
    <span class="s0"># &quot;&quot;&quot;</span>
    <span class="s0"># Get the distutils command for interacting with PyPI configurations.</span>
    <span class="s0"># :return: the command.</span>
    <span class="s0"># &quot;&quot;&quot;</span>
    <span class="s0"># from distutils.core import Distribution</span>
    <span class="s0"># from distutils.config import PyPIRCCommand</span>
    <span class="s0"># d = Distribution()</span>
    <span class="s0"># return PyPIRCCommand(d)</span>

<span class="s2">class </span><span class="s1">PyPIRCFile(object):</span>

    <span class="s1">DEFAULT_REPOSITORY = </span><span class="s3">'https://upload.pypi.org/legacy/'</span>
    <span class="s1">DEFAULT_REALM = </span><span class="s3">'pypi'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fn=</span><span class="s2">None, </span><span class="s1">url=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">fn </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fn = os.path.join(os.path.expanduser(</span><span class="s3">'~'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'.pypirc'</span><span class="s1">)</span>
        <span class="s1">self.filename = fn</span>
        <span class="s1">self.url = url</span>

    <span class="s2">def </span><span class="s1">read(self):</span>
        <span class="s1">result = {}</span>

        <span class="s2">if </span><span class="s1">os.path.exists(self.filename):</span>
            <span class="s1">repository = self.url </span><span class="s2">or </span><span class="s1">self.DEFAULT_REPOSITORY</span>

            <span class="s1">config = configparser.RawConfigParser()</span>
            <span class="s1">config.read(self.filename)</span>
            <span class="s1">sections = config.sections()</span>
            <span class="s2">if </span><span class="s3">'distutils' </span><span class="s2">in </span><span class="s1">sections:</span>
                <span class="s0"># let's get the list of servers</span>
                <span class="s1">index_servers = config.get(</span><span class="s3">'distutils'</span><span class="s2">, </span><span class="s3">'index-servers'</span><span class="s1">)</span>
                <span class="s1">_servers = [server.strip() </span><span class="s2">for </span><span class="s1">server </span><span class="s2">in</span>
                            <span class="s1">index_servers.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
                            <span class="s2">if </span><span class="s1">server.strip() != </span><span class="s3">''</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">_servers == []:</span>
                    <span class="s0"># nothing set, let's try to get the default pypi</span>
                    <span class="s2">if </span><span class="s3">'pypi' </span><span class="s2">in </span><span class="s1">sections:</span>
                        <span class="s1">_servers = [</span><span class="s3">'pypi'</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">for </span><span class="s1">server </span><span class="s2">in </span><span class="s1">_servers:</span>
                        <span class="s1">result = {</span><span class="s3">'server'</span><span class="s1">: server}</span>
                        <span class="s1">result[</span><span class="s3">'username'</span><span class="s1">] = config.get(server</span><span class="s2">, </span><span class="s3">'username'</span><span class="s1">)</span>

                        <span class="s0"># optional params</span>
                        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">default </span><span class="s2">in </span><span class="s1">((</span><span class="s3">'repository'</span><span class="s2">, </span><span class="s1">self.DEFAULT_REPOSITORY)</span><span class="s2">,</span>
                                             <span class="s1">(</span><span class="s3">'realm'</span><span class="s2">, </span><span class="s1">self.DEFAULT_REALM)</span><span class="s2">,</span>
                                             <span class="s1">(</span><span class="s3">'password'</span><span class="s2">, None</span><span class="s1">)):</span>
                            <span class="s2">if </span><span class="s1">config.has_option(server</span><span class="s2">, </span><span class="s1">key):</span>
                                <span class="s1">result[key] = config.get(server</span><span class="s2">, </span><span class="s1">key)</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">result[key] = default</span>

                        <span class="s0"># work around people having &quot;repository&quot; for the &quot;pypi&quot;</span>
                        <span class="s0"># section of their config set to the HTTP (rather than</span>
                        <span class="s0"># HTTPS) URL</span>
                        <span class="s2">if </span><span class="s1">(server == </span><span class="s3">'pypi' </span><span class="s2">and</span>
                            <span class="s1">repository </span><span class="s2">in </span><span class="s1">(self.DEFAULT_REPOSITORY</span><span class="s2">, </span><span class="s3">'pypi'</span><span class="s1">)):</span>
                            <span class="s1">result[</span><span class="s3">'repository'</span><span class="s1">] = self.DEFAULT_REPOSITORY</span>
                        <span class="s2">elif </span><span class="s1">(result[</span><span class="s3">'server'</span><span class="s1">] != repository </span><span class="s2">and</span>
                              <span class="s1">result[</span><span class="s3">'repository'</span><span class="s1">] != repository):</span>
                            <span class="s1">result = {}</span>
            <span class="s2">elif </span><span class="s3">'server-login' </span><span class="s2">in </span><span class="s1">sections:</span>
                <span class="s0"># old format</span>
                <span class="s1">server = </span><span class="s3">'server-login'</span>
                <span class="s2">if </span><span class="s1">config.has_option(server</span><span class="s2">, </span><span class="s3">'repository'</span><span class="s1">):</span>
                    <span class="s1">repository = config.get(server</span><span class="s2">, </span><span class="s3">'repository'</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">repository = self.DEFAULT_REPOSITORY</span>
                <span class="s1">result = {</span>
                    <span class="s3">'username'</span><span class="s1">: config.get(server</span><span class="s2">, </span><span class="s3">'username'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s3">'password'</span><span class="s1">: config.get(server</span><span class="s2">, </span><span class="s3">'password'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s3">'repository'</span><span class="s1">: repository</span><span class="s2">,</span>
                    <span class="s3">'server'</span><span class="s1">: server</span><span class="s2">,</span>
                    <span class="s3">'realm'</span><span class="s1">: self.DEFAULT_REALM</span>
                <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">username</span><span class="s2">, </span><span class="s1">password):</span>
        <span class="s0"># import pdb; pdb.set_trace()</span>
        <span class="s1">config = configparser.RawConfigParser()</span>
        <span class="s1">fn = self.filename</span>
        <span class="s1">config.read(fn)</span>
        <span class="s2">if not </span><span class="s1">config.has_section(</span><span class="s3">'pypi'</span><span class="s1">):</span>
            <span class="s1">config.add_section(</span><span class="s3">'pypi'</span><span class="s1">)</span>
        <span class="s1">config.set(</span><span class="s3">'pypi'</span><span class="s2">, </span><span class="s3">'username'</span><span class="s2">, </span><span class="s1">username)</span>
        <span class="s1">config.set(</span><span class="s3">'pypi'</span><span class="s2">, </span><span class="s3">'password'</span><span class="s2">, </span><span class="s1">password)</span>
        <span class="s2">with </span><span class="s1">open(fn</span><span class="s2">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">config.write(f)</span>

<span class="s2">def </span><span class="s1">_load_pypirc(index):</span>
    <span class="s4">&quot;&quot;&quot; 
    Read the PyPI access configuration as supported by distutils. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">PyPIRCFile(url=index.url).read()</span>

<span class="s2">def </span><span class="s1">_store_pypirc(index):</span>
    <span class="s1">PyPIRCFile().update(index.username</span><span class="s2">, </span><span class="s1">index.password)</span>

<span class="s0">#</span>
<span class="s0"># get_platform()/get_host_platform() copied from Python 3.10.a0 source, with some minor</span>
<span class="s0"># tweaks</span>
<span class="s0">#</span>

<span class="s2">def </span><span class="s1">get_host_platform():</span>
    <span class="s4">&quot;&quot;&quot;Return a string that identifies the current platform.  This is used mainly to 
    distinguish platform-specific build directories and platform-specific built 
    distributions.  Typically includes the OS name and version and the 
    architecture (as supplied by 'os.uname()'), although the exact information 
    included depends on the OS; eg. on Linux, the kernel version isn't 
    particularly important. 
 
    Examples of returned values: 
       linux-i586 
       linux-alpha (?) 
       solaris-2.6-sun4u 
 
    Windows will return one of: 
       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc) 
       win32 (all others - specifically, sys.platform is returned) 
 
    For other non-POSIX platforms, currently just returns 'sys.platform'. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'nt'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s3">'amd64' </span><span class="s2">in </span><span class="s1">sys.version.lower():</span>
            <span class="s2">return </span><span class="s3">'win-amd64'</span>
        <span class="s2">if </span><span class="s3">'(arm)' </span><span class="s2">in </span><span class="s1">sys.version.lower():</span>
            <span class="s2">return </span><span class="s3">'win-arm32'</span>
        <span class="s2">if </span><span class="s3">'(arm64)' </span><span class="s2">in </span><span class="s1">sys.version.lower():</span>
            <span class="s2">return </span><span class="s3">'win-arm64'</span>
        <span class="s2">return </span><span class="s1">sys.platform</span>

    <span class="s0"># Set for cross builds explicitly</span>
    <span class="s2">if </span><span class="s3">&quot;_PYTHON_HOST_PLATFORM&quot; </span><span class="s2">in </span><span class="s1">os.environ:</span>
        <span class="s2">return </span><span class="s1">os.environ[</span><span class="s3">&quot;_PYTHON_HOST_PLATFORM&quot;</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">os.name != </span><span class="s3">'posix' </span><span class="s2">or not </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">'uname'</span><span class="s1">):</span>
        <span class="s0"># XXX what about the architecture? NT is Intel or Alpha,</span>
        <span class="s0"># Mac OS is M68k or PPC, etc.</span>
        <span class="s2">return </span><span class="s1">sys.platform</span>

    <span class="s0"># Try to distinguish various flavours of Unix</span>

    <span class="s1">(osname</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">release</span><span class="s2">, </span><span class="s1">version</span><span class="s2">, </span><span class="s1">machine) = os.uname()</span>

    <span class="s0"># Convert the OS name to lowercase, remove '/' characters, and translate</span>
    <span class="s0"># spaces (for &quot;Power Macintosh&quot;)</span>
    <span class="s1">osname = osname.lower().replace(</span><span class="s3">'/'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
    <span class="s1">machine = machine.replace(</span><span class="s3">' '</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">).replace(</span><span class="s3">'/'</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">osname[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s3">'linux'</span><span class="s1">:</span>
        <span class="s0"># At least on Linux/Intel, 'machine' is the processor --</span>
        <span class="s0"># i386, etc.</span>
        <span class="s0"># XXX what about Alpha, SPARC, etc?</span>
        <span class="s2">return  </span><span class="s3">&quot;%s-%s&quot; </span><span class="s1">% (osname</span><span class="s2">, </span><span class="s1">machine)</span>

    <span class="s2">elif </span><span class="s1">osname[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s3">'sunos'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">release[</span><span class="s5">0</span><span class="s1">] &gt;= </span><span class="s3">'5'</span><span class="s1">:           </span><span class="s0"># SunOS 5 == Solaris 2</span>
            <span class="s1">osname = </span><span class="s3">'solaris'</span>
            <span class="s1">release = </span><span class="s3">'%d.%s' </span><span class="s1">% (int(release[</span><span class="s5">0</span><span class="s1">]) - </span><span class="s5">3</span><span class="s2">, </span><span class="s1">release[</span><span class="s5">2</span><span class="s1">:])</span>
            <span class="s0"># We can't use 'platform.architecture()[0]' because a</span>
            <span class="s0"># bootstrap problem. We use a dict to get an error</span>
            <span class="s0"># if some suspicious happens.</span>
            <span class="s1">bitness = {</span><span class="s5">2147483647</span><span class="s1">:</span><span class="s3">'32bit'</span><span class="s2">, </span><span class="s5">9223372036854775807</span><span class="s1">:</span><span class="s3">'64bit'</span><span class="s1">}</span>
            <span class="s1">machine += </span><span class="s3">'.%s' </span><span class="s1">% bitness[sys.maxsize]</span>
        <span class="s0"># fall through to standard osname-release-machine representation</span>
    <span class="s2">elif </span><span class="s1">osname[:</span><span class="s5">3</span><span class="s1">] == </span><span class="s3">'aix'</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">_aix_support </span><span class="s2">import </span><span class="s1">aix_platform</span>
        <span class="s2">return </span><span class="s1">aix_platform()</span>
    <span class="s2">elif </span><span class="s1">osname[:</span><span class="s5">6</span><span class="s1">] == </span><span class="s3">'cygwin'</span><span class="s1">:</span>
        <span class="s1">osname = </span><span class="s3">'cygwin'</span>
        <span class="s1">rel_re = re.compile (</span><span class="s3">r'[\d.]+'</span><span class="s2">, </span><span class="s1">re.ASCII)</span>
        <span class="s1">m = rel_re.match(release)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">release = m.group()</span>
    <span class="s2">elif </span><span class="s1">osname[:</span><span class="s5">6</span><span class="s1">] == </span><span class="s3">'darwin'</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">_osx_support</span><span class="s2">, </span><span class="s1">distutils.sysconfig</span>
        <span class="s1">osname</span><span class="s2">, </span><span class="s1">release</span><span class="s2">, </span><span class="s1">machine = _osx_support.get_platform_osx(</span>
                                        <span class="s1">distutils.sysconfig.get_config_vars()</span><span class="s2">,</span>
                                        <span class="s1">osname</span><span class="s2">, </span><span class="s1">release</span><span class="s2">, </span><span class="s1">machine)</span>

    <span class="s2">return </span><span class="s3">'%s-%s-%s' </span><span class="s1">% (osname</span><span class="s2">, </span><span class="s1">release</span><span class="s2">, </span><span class="s1">machine)</span>


<span class="s1">_TARGET_TO_PLAT = {</span>
    <span class="s3">'x86' </span><span class="s1">: </span><span class="s3">'win32'</span><span class="s2">,</span>
    <span class="s3">'x64' </span><span class="s1">: </span><span class="s3">'win-amd64'</span><span class="s2">,</span>
    <span class="s3">'arm' </span><span class="s1">: </span><span class="s3">'win-arm32'</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">get_platform():</span>
    <span class="s2">if </span><span class="s1">os.name != </span><span class="s3">'nt'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">get_host_platform()</span>
    <span class="s1">cross_compilation_target = os.environ.get(</span><span class="s3">'VSCMD_ARG_TGT_ARCH'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">cross_compilation_target </span><span class="s2">not in </span><span class="s1">_TARGET_TO_PLAT:</span>
        <span class="s2">return </span><span class="s1">get_host_platform()</span>
    <span class="s2">return </span><span class="s1">_TARGET_TO_PLAT[cross_compilation_target]</span>
</pre>
</body>
</html>