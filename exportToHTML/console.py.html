<html>
<head>
<title>console.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
console.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">io</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">zlib</span>
<span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABC</span><span class="s0">, </span><span class="s1">abstractmethod</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span><span class="s0">, </span><span class="s1">field</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">wraps</span>
<span class="s0">from </span><span class="s1">getpass </span><span class="s0">import </span><span class="s1">getpass</span>
<span class="s0">from </span><span class="s1">html </span><span class="s0">import </span><span class="s1">escape</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">isclass</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">islice</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">ceil</span>
<span class="s0">from </span><span class="s1">time </span><span class="s0">import </span><span class="s1">monotonic</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">FrameType</span><span class="s0">, </span><span class="s1">ModuleType</span><span class="s0">, </span><span class="s1">TracebackType</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">IO</span><span class="s0">,</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Dict</span><span class="s0">,</span>
    <span class="s1">Iterable</span><span class="s0">,</span>
    <span class="s1">List</span><span class="s0">,</span>
    <span class="s1">Mapping</span><span class="s0">,</span>
    <span class="s1">NamedTuple</span><span class="s0">,</span>
    <span class="s1">Optional</span><span class="s0">,</span>
    <span class="s1">TextIO</span><span class="s0">,</span>
    <span class="s1">Tuple</span><span class="s0">,</span>
    <span class="s1">Type</span><span class="s0">,</span>
    <span class="s1">Union</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s1">):</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Literal</span><span class="s0">, </span><span class="s1">Protocol</span><span class="s0">, </span><span class="s1">runtime_checkable</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">pip._vendor.typing_extensions </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">Literal</span><span class="s0">,</span>
        <span class="s1">Protocol</span><span class="s0">,</span>
        <span class="s1">runtime_checkable</span><span class="s0">,</span>
    <span class="s1">)  </span><span class="s3"># pragma: no cover</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">errors</span><span class="s0">, </span><span class="s1">themes</span>
<span class="s0">from </span><span class="s1">._emoji_replace </span><span class="s0">import </span><span class="s1">_emoji_replace</span>
<span class="s0">from </span><span class="s1">._export_format </span><span class="s0">import </span><span class="s1">CONSOLE_HTML_FORMAT</span><span class="s0">, </span><span class="s1">CONSOLE_SVG_FORMAT</span>
<span class="s0">from </span><span class="s1">._log_render </span><span class="s0">import </span><span class="s1">FormatTimeCallable</span><span class="s0">, </span><span class="s1">LogRender</span>
<span class="s0">from </span><span class="s1">.align </span><span class="s0">import </span><span class="s1">Align</span><span class="s0">, </span><span class="s1">AlignMethod</span>
<span class="s0">from </span><span class="s1">.color </span><span class="s0">import </span><span class="s1">ColorSystem</span><span class="s0">, </span><span class="s1">blend_rgb</span>
<span class="s0">from </span><span class="s1">.control </span><span class="s0">import </span><span class="s1">Control</span>
<span class="s0">from </span><span class="s1">.emoji </span><span class="s0">import </span><span class="s1">EmojiVariant</span>
<span class="s0">from </span><span class="s1">.highlighter </span><span class="s0">import </span><span class="s1">NullHighlighter</span><span class="s0">, </span><span class="s1">ReprHighlighter</span>
<span class="s0">from </span><span class="s1">.markup </span><span class="s0">import </span><span class="s1">render </span><span class="s0">as </span><span class="s1">render_markup</span>
<span class="s0">from </span><span class="s1">.measure </span><span class="s0">import </span><span class="s1">Measurement</span><span class="s0">, </span><span class="s1">measure_renderables</span>
<span class="s0">from </span><span class="s1">.pager </span><span class="s0">import </span><span class="s1">Pager</span><span class="s0">, </span><span class="s1">SystemPager</span>
<span class="s0">from </span><span class="s1">.pretty </span><span class="s0">import </span><span class="s1">Pretty</span><span class="s0">, </span><span class="s1">is_expandable</span>
<span class="s0">from </span><span class="s1">.protocol </span><span class="s0">import </span><span class="s1">rich_cast</span>
<span class="s0">from </span><span class="s1">.region </span><span class="s0">import </span><span class="s1">Region</span>
<span class="s0">from </span><span class="s1">.scope </span><span class="s0">import </span><span class="s1">render_scope</span>
<span class="s0">from </span><span class="s1">.screen </span><span class="s0">import </span><span class="s1">Screen</span>
<span class="s0">from </span><span class="s1">.segment </span><span class="s0">import </span><span class="s1">Segment</span>
<span class="s0">from </span><span class="s1">.style </span><span class="s0">import </span><span class="s1">Style</span><span class="s0">, </span><span class="s1">StyleType</span>
<span class="s0">from </span><span class="s1">.styled </span><span class="s0">import </span><span class="s1">Styled</span>
<span class="s0">from </span><span class="s1">.terminal_theme </span><span class="s0">import </span><span class="s1">DEFAULT_TERMINAL_THEME</span><span class="s0">, </span><span class="s1">SVG_EXPORT_THEME</span><span class="s0">, </span><span class="s1">TerminalTheme</span>
<span class="s0">from </span><span class="s1">.text </span><span class="s0">import </span><span class="s1">Text</span><span class="s0">, </span><span class="s1">TextType</span>
<span class="s0">from </span><span class="s1">.theme </span><span class="s0">import </span><span class="s1">Theme</span><span class="s0">, </span><span class="s1">ThemeStack</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">._windows </span><span class="s0">import </span><span class="s1">WindowsConsoleFeatures</span>
    <span class="s0">from </span><span class="s1">.live </span><span class="s0">import </span><span class="s1">Live</span>
    <span class="s0">from </span><span class="s1">.status </span><span class="s0">import </span><span class="s1">Status</span>

<span class="s1">JUPYTER_DEFAULT_COLUMNS = </span><span class="s2">115</span>
<span class="s1">JUPYTER_DEFAULT_LINES = </span><span class="s2">100</span>
<span class="s1">WINDOWS = platform.system() == </span><span class="s4">&quot;Windows&quot;</span>

<span class="s1">HighlighterType = Callable[[Union[str</span><span class="s0">, </span><span class="s4">&quot;Text&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s4">&quot;Text&quot;</span><span class="s1">]</span>
<span class="s1">JustifyMethod = Literal[</span><span class="s4">&quot;default&quot;</span><span class="s0">, </span><span class="s4">&quot;left&quot;</span><span class="s0">, </span><span class="s4">&quot;center&quot;</span><span class="s0">, </span><span class="s4">&quot;right&quot;</span><span class="s0">, </span><span class="s4">&quot;full&quot;</span><span class="s1">]</span>
<span class="s1">OverflowMethod = Literal[</span><span class="s4">&quot;fold&quot;</span><span class="s0">, </span><span class="s4">&quot;crop&quot;</span><span class="s0">, </span><span class="s4">&quot;ellipsis&quot;</span><span class="s0">, </span><span class="s4">&quot;ignore&quot;</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">NoChange:</span>
    <span class="s0">pass</span>


<span class="s1">NO_CHANGE = NoChange()</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s1">_STDIN_FILENO = sys.__stdin__.fileno()</span>
<span class="s0">except </span><span class="s1">Exception:</span>
    <span class="s1">_STDIN_FILENO = </span><span class="s2">0</span>
<span class="s0">try</span><span class="s1">:</span>
    <span class="s1">_STDOUT_FILENO = sys.__stdout__.fileno()</span>
<span class="s0">except </span><span class="s1">Exception:</span>
    <span class="s1">_STDOUT_FILENO = </span><span class="s2">1</span>
<span class="s0">try</span><span class="s1">:</span>
    <span class="s1">_STDERR_FILENO = sys.__stderr__.fileno()</span>
<span class="s0">except </span><span class="s1">Exception:</span>
    <span class="s1">_STDERR_FILENO = </span><span class="s2">2</span>

<span class="s1">_STD_STREAMS = (_STDIN_FILENO</span><span class="s0">, </span><span class="s1">_STDOUT_FILENO</span><span class="s0">, </span><span class="s1">_STDERR_FILENO)</span>
<span class="s1">_STD_STREAMS_OUTPUT = (_STDOUT_FILENO</span><span class="s0">, </span><span class="s1">_STDERR_FILENO)</span>


<span class="s1">_TERM_COLORS = {</span><span class="s4">&quot;256color&quot;</span><span class="s1">: ColorSystem.EIGHT_BIT</span><span class="s0">, </span><span class="s4">&quot;16color&quot;</span><span class="s1">: ColorSystem.STANDARD}</span>


<span class="s0">class </span><span class="s1">ConsoleDimensions(NamedTuple):</span>
    <span class="s5">&quot;&quot;&quot;Size of the terminal.&quot;&quot;&quot;</span>

    <span class="s1">width: int</span>
    <span class="s4">&quot;&quot;&quot;The width of the console in 'cells'.&quot;&quot;&quot;</span>
    <span class="s1">height: int</span>
    <span class="s4">&quot;&quot;&quot;The height of the console in lines.&quot;&quot;&quot;</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">ConsoleOptions:</span>
    <span class="s5">&quot;&quot;&quot;Options for __rich_console__ method.&quot;&quot;&quot;</span>

    <span class="s1">size: ConsoleDimensions</span>
    <span class="s4">&quot;&quot;&quot;Size of console.&quot;&quot;&quot;</span>
    <span class="s1">legacy_windows: bool</span>
    <span class="s4">&quot;&quot;&quot;legacy_windows: flag for legacy windows.&quot;&quot;&quot;</span>
    <span class="s1">min_width: int</span>
    <span class="s4">&quot;&quot;&quot;Minimum width of renderable.&quot;&quot;&quot;</span>
    <span class="s1">max_width: int</span>
    <span class="s4">&quot;&quot;&quot;Maximum width of renderable.&quot;&quot;&quot;</span>
    <span class="s1">is_terminal: bool</span>
    <span class="s4">&quot;&quot;&quot;True if the target is a terminal, otherwise False.&quot;&quot;&quot;</span>
    <span class="s1">encoding: str</span>
    <span class="s4">&quot;&quot;&quot;Encoding of terminal.&quot;&quot;&quot;</span>
    <span class="s1">max_height: int</span>
    <span class="s4">&quot;&quot;&quot;Height of container (starts as terminal)&quot;&quot;&quot;</span>
    <span class="s1">justify: Optional[JustifyMethod] = </span><span class="s0">None</span>
    <span class="s4">&quot;&quot;&quot;Justify value override for renderable.&quot;&quot;&quot;</span>
    <span class="s1">overflow: Optional[OverflowMethod] = </span><span class="s0">None</span>
    <span class="s4">&quot;&quot;&quot;Overflow value override for renderable.&quot;&quot;&quot;</span>
    <span class="s1">no_wrap: Optional[bool] = </span><span class="s0">False</span>
    <span class="s4">&quot;&quot;&quot;Disable wrapping for text.&quot;&quot;&quot;</span>
    <span class="s1">highlight: Optional[bool] = </span><span class="s0">None</span>
    <span class="s4">&quot;&quot;&quot;Highlight override for render_str.&quot;&quot;&quot;</span>
    <span class="s1">markup: Optional[bool] = </span><span class="s0">None</span>
    <span class="s4">&quot;&quot;&quot;Enable markup when rendering strings.&quot;&quot;&quot;</span>
    <span class="s1">height: Optional[int] = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">ascii_only(self) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Check if renderables should use ascii only.&quot;&quot;&quot;</span>
        <span class="s0">return not </span><span class="s1">self.encoding.startswith(</span><span class="s4">&quot;utf&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">copy(self) -&gt; </span><span class="s4">&quot;ConsoleOptions&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Return a copy of the options. 
 
        Returns: 
            ConsoleOptions: a copy of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">options: ConsoleOptions = ConsoleOptions.__new__(ConsoleOptions)</span>
        <span class="s1">options.__dict__ = self.__dict__.copy()</span>
        <span class="s0">return </span><span class="s1">options</span>

    <span class="s0">def </span><span class="s1">update(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">width: Union[int</span><span class="s0">, </span><span class="s1">NoChange] = NO_CHANGE</span><span class="s0">,</span>
        <span class="s1">min_width: Union[int</span><span class="s0">, </span><span class="s1">NoChange] = NO_CHANGE</span><span class="s0">,</span>
        <span class="s1">max_width: Union[int</span><span class="s0">, </span><span class="s1">NoChange] = NO_CHANGE</span><span class="s0">,</span>
        <span class="s1">justify: Union[Optional[JustifyMethod]</span><span class="s0">, </span><span class="s1">NoChange] = NO_CHANGE</span><span class="s0">,</span>
        <span class="s1">overflow: Union[Optional[OverflowMethod]</span><span class="s0">, </span><span class="s1">NoChange] = NO_CHANGE</span><span class="s0">,</span>
        <span class="s1">no_wrap: Union[Optional[bool]</span><span class="s0">, </span><span class="s1">NoChange] = NO_CHANGE</span><span class="s0">,</span>
        <span class="s1">highlight: Union[Optional[bool]</span><span class="s0">, </span><span class="s1">NoChange] = NO_CHANGE</span><span class="s0">,</span>
        <span class="s1">markup: Union[Optional[bool]</span><span class="s0">, </span><span class="s1">NoChange] = NO_CHANGE</span><span class="s0">,</span>
        <span class="s1">height: Union[Optional[int]</span><span class="s0">, </span><span class="s1">NoChange] = NO_CHANGE</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;ConsoleOptions&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Update values, return a copy.&quot;&quot;&quot;</span>
        <span class="s1">options = self.copy()</span>
        <span class="s0">if not </span><span class="s1">isinstance(width</span><span class="s0">, </span><span class="s1">NoChange):</span>
            <span class="s1">options.min_width = options.max_width = max(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">width)</span>
        <span class="s0">if not </span><span class="s1">isinstance(min_width</span><span class="s0">, </span><span class="s1">NoChange):</span>
            <span class="s1">options.min_width = min_width</span>
        <span class="s0">if not </span><span class="s1">isinstance(max_width</span><span class="s0">, </span><span class="s1">NoChange):</span>
            <span class="s1">options.max_width = max_width</span>
        <span class="s0">if not </span><span class="s1">isinstance(justify</span><span class="s0">, </span><span class="s1">NoChange):</span>
            <span class="s1">options.justify = justify</span>
        <span class="s0">if not </span><span class="s1">isinstance(overflow</span><span class="s0">, </span><span class="s1">NoChange):</span>
            <span class="s1">options.overflow = overflow</span>
        <span class="s0">if not </span><span class="s1">isinstance(no_wrap</span><span class="s0">, </span><span class="s1">NoChange):</span>
            <span class="s1">options.no_wrap = no_wrap</span>
        <span class="s0">if not </span><span class="s1">isinstance(highlight</span><span class="s0">, </span><span class="s1">NoChange):</span>
            <span class="s1">options.highlight = highlight</span>
        <span class="s0">if not </span><span class="s1">isinstance(markup</span><span class="s0">, </span><span class="s1">NoChange):</span>
            <span class="s1">options.markup = markup</span>
        <span class="s0">if not </span><span class="s1">isinstance(height</span><span class="s0">, </span><span class="s1">NoChange):</span>
            <span class="s0">if </span><span class="s1">height </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">options.max_height = height</span>
            <span class="s1">options.height = </span><span class="s0">None if </span><span class="s1">height </span><span class="s0">is None else </span><span class="s1">max(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s0">return </span><span class="s1">options</span>

    <span class="s0">def </span><span class="s1">update_width(self</span><span class="s0">, </span><span class="s1">width: int) -&gt; </span><span class="s4">&quot;ConsoleOptions&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Update just the width, return a copy. 
 
        Args: 
            width (int): New width (sets both min_width and max_width) 
 
        Returns: 
            ~ConsoleOptions: New console options instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">options = self.copy()</span>
        <span class="s1">options.min_width = options.max_width = max(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">width)</span>
        <span class="s0">return </span><span class="s1">options</span>

    <span class="s0">def </span><span class="s1">update_height(self</span><span class="s0">, </span><span class="s1">height: int) -&gt; </span><span class="s4">&quot;ConsoleOptions&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Update the height, and return a copy. 
 
        Args: 
            height (int): New height 
 
        Returns: 
            ~ConsoleOptions: New Console options instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">options = self.copy()</span>
        <span class="s1">options.max_height = options.height = height</span>
        <span class="s0">return </span><span class="s1">options</span>

    <span class="s0">def </span><span class="s1">reset_height(self) -&gt; </span><span class="s4">&quot;ConsoleOptions&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Return a copy of the options with height set to ``None``. 
 
        Returns: 
            ~ConsoleOptions: New console options instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">options = self.copy()</span>
        <span class="s1">options.height = </span><span class="s0">None</span>
        <span class="s0">return </span><span class="s1">options</span>

    <span class="s0">def </span><span class="s1">update_dimensions(self</span><span class="s0">, </span><span class="s1">width: int</span><span class="s0">, </span><span class="s1">height: int) -&gt; </span><span class="s4">&quot;ConsoleOptions&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Update the width and height, and return a copy. 
 
        Args: 
            width (int): New width (sets both min_width and max_width). 
            height (int): New height. 
 
        Returns: 
            ~ConsoleOptions: New console options instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">options = self.copy()</span>
        <span class="s1">options.min_width = options.max_width = max(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">width)</span>
        <span class="s1">options.height = options.max_height = height</span>
        <span class="s0">return </span><span class="s1">options</span>


<span class="s1">@runtime_checkable</span>
<span class="s0">class </span><span class="s1">RichCast(Protocol):</span>
    <span class="s5">&quot;&quot;&quot;An object that may be 'cast' to a console renderable.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__rich__(</span>
        <span class="s1">self</span><span class="s0">,</span>
    <span class="s1">) -&gt; Union[</span><span class="s4">&quot;ConsoleRenderable&quot;</span><span class="s0">, </span><span class="s4">&quot;RichCast&quot;</span><span class="s0">, </span><span class="s1">str]:  </span><span class="s3"># pragma: no cover</span>
        <span class="s1">...</span>


<span class="s1">@runtime_checkable</span>
<span class="s0">class </span><span class="s1">ConsoleRenderable(Protocol):</span>
    <span class="s5">&quot;&quot;&quot;An object that supports the console protocol.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__rich_console__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">console: </span><span class="s4">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">options: </span><span class="s4">&quot;ConsoleOptions&quot;</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;RenderResult&quot;</span><span class="s1">:  </span><span class="s3"># pragma: no cover</span>
        <span class="s1">...</span>


<span class="s3"># A type that may be rendered by Console.</span>
<span class="s1">RenderableType = Union[ConsoleRenderable</span><span class="s0">, </span><span class="s1">RichCast</span><span class="s0">, </span><span class="s1">str]</span>

<span class="s3"># The result of calling a __rich_console__ method.</span>
<span class="s1">RenderResult = Iterable[Union[RenderableType</span><span class="s0">, </span><span class="s1">Segment]]</span>

<span class="s1">_null_highlighter = NullHighlighter()</span>


<span class="s0">class </span><span class="s1">CaptureError(Exception):</span>
    <span class="s5">&quot;&quot;&quot;An error in the Capture context manager.&quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">NewLine:</span>
    <span class="s5">&quot;&quot;&quot;A renderable to generate new line(s)&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">count: int = </span><span class="s2">1</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.count = count</span>

    <span class="s0">def </span><span class="s1">__rich_console__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">console: </span><span class="s4">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">options: </span><span class="s4">&quot;ConsoleOptions&quot;</span>
    <span class="s1">) -&gt; Iterable[Segment]:</span>
        <span class="s0">yield </span><span class="s1">Segment(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">* self.count)</span>


<span class="s0">class </span><span class="s1">ScreenUpdate:</span>
    <span class="s5">&quot;&quot;&quot;Render a list of lines at a given offset.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">lines: List[List[Segment]]</span><span class="s0">, </span><span class="s1">x: int</span><span class="s0">, </span><span class="s1">y: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._lines = lines</span>
        <span class="s1">self.x = x</span>
        <span class="s1">self.y = y</span>

    <span class="s0">def </span><span class="s1">__rich_console__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">console: </span><span class="s4">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">options: ConsoleOptions</span>
    <span class="s1">) -&gt; RenderResult:</span>
        <span class="s1">x = self.x</span>
        <span class="s1">move_to = Control.move_to</span>
        <span class="s0">for </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">line </span><span class="s0">in </span><span class="s1">enumerate(self._lines</span><span class="s0">, </span><span class="s1">self.y):</span>
            <span class="s0">yield </span><span class="s1">move_to(x</span><span class="s0">, </span><span class="s1">offset)</span>
            <span class="s0">yield from </span><span class="s1">line</span>


<span class="s0">class </span><span class="s1">Capture:</span>
    <span class="s5">&quot;&quot;&quot;Context manager to capture the result of printing to the console. 
    See :meth:`~rich.console.Console.capture` for how to use. 
 
    Args: 
        console (Console): A console instance to capture output. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">console: </span><span class="s4">&quot;Console&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._console = console</span>
        <span class="s1">self._result: Optional[str] = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__enter__(self) -&gt; </span><span class="s4">&quot;Capture&quot;</span><span class="s1">:</span>
        <span class="s1">self._console.begin_capture()</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">exc_type: Optional[Type[BaseException]]</span><span class="s0">,</span>
        <span class="s1">exc_val: Optional[BaseException]</span><span class="s0">,</span>
        <span class="s1">exc_tb: Optional[TracebackType]</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._result = self._console.end_capture()</span>

    <span class="s0">def </span><span class="s1">get(self) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot;Get the result of the capture.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._result </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">CaptureError(</span>
                <span class="s4">&quot;Capture result is not available until context manager exits.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._result</span>


<span class="s0">class </span><span class="s1">ThemeContext:</span>
    <span class="s5">&quot;&quot;&quot;A context manager to use a temporary theme. See :meth:`~rich.console.Console.use_theme` for usage.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">console: </span><span class="s4">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">theme: Theme</span><span class="s0">, </span><span class="s1">inherit: bool = </span><span class="s0">True</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.console = console</span>
        <span class="s1">self.theme = theme</span>
        <span class="s1">self.inherit = inherit</span>

    <span class="s0">def </span><span class="s1">__enter__(self) -&gt; </span><span class="s4">&quot;ThemeContext&quot;</span><span class="s1">:</span>
        <span class="s1">self.console.push_theme(self.theme)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">exc_type: Optional[Type[BaseException]]</span><span class="s0">,</span>
        <span class="s1">exc_val: Optional[BaseException]</span><span class="s0">,</span>
        <span class="s1">exc_tb: Optional[TracebackType]</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.console.pop_theme()</span>


<span class="s0">class </span><span class="s1">PagerContext:</span>
    <span class="s5">&quot;&quot;&quot;A context manager that 'pages' content. See :meth:`~rich.console.Console.pager` for usage.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">console: </span><span class="s4">&quot;Console&quot;</span><span class="s0">,</span>
        <span class="s1">pager: Optional[Pager] = </span><span class="s0">None,</span>
        <span class="s1">styles: bool = </span><span class="s0">False,</span>
        <span class="s1">links: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._console = console</span>
        <span class="s1">self.pager = SystemPager() </span><span class="s0">if </span><span class="s1">pager </span><span class="s0">is None else </span><span class="s1">pager</span>
        <span class="s1">self.styles = styles</span>
        <span class="s1">self.links = links</span>

    <span class="s0">def </span><span class="s1">__enter__(self) -&gt; </span><span class="s4">&quot;PagerContext&quot;</span><span class="s1">:</span>
        <span class="s1">self._console._enter_buffer()</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">exc_type: Optional[Type[BaseException]]</span><span class="s0">,</span>
        <span class="s1">exc_val: Optional[BaseException]</span><span class="s0">,</span>
        <span class="s1">exc_tb: Optional[TracebackType]</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">exc_type </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">self._console._lock:</span>
                <span class="s1">buffer: List[Segment] = self._console._buffer[:]</span>
                <span class="s0">del </span><span class="s1">self._console._buffer[:]</span>
                <span class="s1">segments: Iterable[Segment] = buffer</span>
                <span class="s0">if not </span><span class="s1">self.styles:</span>
                    <span class="s1">segments = Segment.strip_styles(segments)</span>
                <span class="s0">elif not </span><span class="s1">self.links:</span>
                    <span class="s1">segments = Segment.strip_links(segments)</span>
                <span class="s1">content = self._console._render_buffer(segments)</span>
            <span class="s1">self.pager.show(content)</span>
        <span class="s1">self._console._exit_buffer()</span>


<span class="s0">class </span><span class="s1">ScreenContext:</span>
    <span class="s5">&quot;&quot;&quot;A context manager that enables an alternative screen. See :meth:`~rich.console.Console.screen` for usage.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">console: </span><span class="s4">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">hide_cursor: bool</span><span class="s0">, </span><span class="s1">style: StyleType = </span><span class="s4">&quot;&quot;</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.console = console</span>
        <span class="s1">self.hide_cursor = hide_cursor</span>
        <span class="s1">self.screen = Screen(style=style)</span>
        <span class="s1">self._changed = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">update(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">*renderables: RenderableType</span><span class="s0">, </span><span class="s1">style: Optional[StyleType] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Update the screen. 
 
        Args: 
            renderable (RenderableType, optional): Optional renderable to replace current renderable, 
                or None for no change. Defaults to None. 
            style: (Style, optional): Replacement style, or None for no change. Defaults to None. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">renderables:</span>
            <span class="s1">self.screen.renderable = (</span>
                <span class="s1">Group(*renderables) </span><span class="s0">if </span><span class="s1">len(renderables) &gt; </span><span class="s2">1 </span><span class="s0">else </span><span class="s1">renderables[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">style </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.screen.style = style</span>
        <span class="s1">self.console.print(self.screen</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__enter__(self) -&gt; </span><span class="s4">&quot;ScreenContext&quot;</span><span class="s1">:</span>
        <span class="s1">self._changed = self.console.set_alt_screen(</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self._changed </span><span class="s0">and </span><span class="s1">self.hide_cursor:</span>
            <span class="s1">self.console.show_cursor(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">exc_type: Optional[Type[BaseException]]</span><span class="s0">,</span>
        <span class="s1">exc_val: Optional[BaseException]</span><span class="s0">,</span>
        <span class="s1">exc_tb: Optional[TracebackType]</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">self._changed:</span>
            <span class="s1">self.console.set_alt_screen(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">self.hide_cursor:</span>
                <span class="s1">self.console.show_cursor(</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">Group:</span>
    <span class="s5">&quot;&quot;&quot;Takes a group of renderables and returns a renderable object that renders the group. 
 
    Args: 
        renderables (Iterable[RenderableType]): An iterable of renderable objects. 
        fit (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*renderables: </span><span class="s4">&quot;RenderableType&quot;</span><span class="s0">, </span><span class="s1">fit: bool = </span><span class="s0">True</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._renderables = renderables</span>
        <span class="s1">self.fit = fit</span>
        <span class="s1">self._render: Optional[List[RenderableType]] = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">renderables(self) -&gt; List[</span><span class="s4">&quot;RenderableType&quot;</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">self._render </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._render = list(self._renderables)</span>
        <span class="s0">return </span><span class="s1">self._render</span>

    <span class="s0">def </span><span class="s1">__rich_measure__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">console: </span><span class="s4">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">options: </span><span class="s4">&quot;ConsoleOptions&quot;</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;Measurement&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">self.fit:</span>
            <span class="s0">return </span><span class="s1">measure_renderables(console</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">self.renderables)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Measurement(options.max_width</span><span class="s0">, </span><span class="s1">options.max_width)</span>

    <span class="s0">def </span><span class="s1">__rich_console__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">console: </span><span class="s4">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">options: </span><span class="s4">&quot;ConsoleOptions&quot;</span>
    <span class="s1">) -&gt; RenderResult:</span>
        <span class="s0">yield from </span><span class="s1">self.renderables</span>


<span class="s0">def </span><span class="s1">group(fit: bool = </span><span class="s0">True</span><span class="s1">) -&gt; Callable[...</span><span class="s0">, </span><span class="s1">Callable[...</span><span class="s0">, </span><span class="s1">Group]]:</span>
    <span class="s5">&quot;&quot;&quot;A decorator that turns an iterable of renderables in to a group. 
 
    Args: 
        fit (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">decorator(</span>
        <span class="s1">method: Callable[...</span><span class="s0">, </span><span class="s1">Iterable[RenderableType]]</span>
    <span class="s1">) -&gt; Callable[...</span><span class="s0">, </span><span class="s1">Group]:</span>
        <span class="s5">&quot;&quot;&quot;Convert a method that returns an iterable of renderables in to a Group.&quot;&quot;&quot;</span>

        <span class="s1">@wraps(method)</span>
        <span class="s0">def </span><span class="s1">_replace(*args: Any</span><span class="s0">, </span><span class="s1">**kwargs: Any) -&gt; Group:</span>
            <span class="s1">renderables = method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">return </span><span class="s1">Group(*renderables</span><span class="s0">, </span><span class="s1">fit=fit)</span>

        <span class="s0">return </span><span class="s1">_replace</span>

    <span class="s0">return </span><span class="s1">decorator</span>


<span class="s0">def </span><span class="s1">_is_jupyter() -&gt; bool:  </span><span class="s3"># pragma: no cover</span>
    <span class="s5">&quot;&quot;&quot;Check if we're running in a Jupyter notebook.&quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">get_ipython  </span><span class="s3"># type: ignore[name-defined]</span>
    <span class="s0">except </span><span class="s1">NameError:</span>
        <span class="s0">return False</span>
    <span class="s1">ipython = get_ipython()  </span><span class="s3"># type: ignore[name-defined]</span>
    <span class="s1">shell = ipython.__class__.__name__</span>
    <span class="s0">if </span><span class="s4">&quot;google.colab&quot; </span><span class="s0">in </span><span class="s1">str(ipython.__class__) </span><span class="s0">or </span><span class="s1">shell == </span><span class="s4">&quot;ZMQInteractiveShell&quot;</span><span class="s1">:</span>
        <span class="s0">return True  </span><span class="s3"># Jupyter notebook or qtconsole</span>
    <span class="s0">elif </span><span class="s1">shell == </span><span class="s4">&quot;TerminalInteractiveShell&quot;</span><span class="s1">:</span>
        <span class="s0">return False  </span><span class="s3"># Terminal running IPython</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return False  </span><span class="s3"># Other type (?)</span>


<span class="s1">COLOR_SYSTEMS = {</span>
    <span class="s4">&quot;standard&quot;</span><span class="s1">: ColorSystem.STANDARD</span><span class="s0">,</span>
    <span class="s4">&quot;256&quot;</span><span class="s1">: ColorSystem.EIGHT_BIT</span><span class="s0">,</span>
    <span class="s4">&quot;truecolor&quot;</span><span class="s1">: ColorSystem.TRUECOLOR</span><span class="s0">,</span>
    <span class="s4">&quot;windows&quot;</span><span class="s1">: ColorSystem.WINDOWS</span><span class="s0">,</span>
<span class="s1">}</span>

<span class="s1">_COLOR_SYSTEMS_NAMES = {system: name </span><span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">system </span><span class="s0">in </span><span class="s1">COLOR_SYSTEMS.items()}</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">ConsoleThreadLocals(threading.local):</span>
    <span class="s5">&quot;&quot;&quot;Thread local values for Console context.&quot;&quot;&quot;</span>

    <span class="s1">theme_stack: ThemeStack</span>
    <span class="s1">buffer: List[Segment] = field(default_factory=list)</span>
    <span class="s1">buffer_index: int = </span><span class="s2">0</span>


<span class="s0">class </span><span class="s1">RenderHook(ABC):</span>
    <span class="s5">&quot;&quot;&quot;Provides hooks in to the render process.&quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">process_renderables(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">renderables: List[ConsoleRenderable]</span>
    <span class="s1">) -&gt; List[ConsoleRenderable]:</span>
        <span class="s5">&quot;&quot;&quot;Called with a list of objects to render. 
 
        This method can return a new list of renderables, or modify and return the same list. 
 
        Args: 
            renderables (List[ConsoleRenderable]): A number of renderable objects. 
 
        Returns: 
            List[ConsoleRenderable]: A replacement list of renderables. 
        &quot;&quot;&quot;</span>


<span class="s1">_windows_console_features: Optional[</span><span class="s4">&quot;WindowsConsoleFeatures&quot;</span><span class="s1">] = </span><span class="s0">None</span>


<span class="s0">def </span><span class="s1">get_windows_console_features() -&gt; </span><span class="s4">&quot;WindowsConsoleFeatures&quot;</span><span class="s1">:  </span><span class="s3"># pragma: no cover</span>
    <span class="s0">global </span><span class="s1">_windows_console_features</span>
    <span class="s0">if </span><span class="s1">_windows_console_features </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_windows_console_features</span>
    <span class="s0">from </span><span class="s1">._windows </span><span class="s0">import </span><span class="s1">get_windows_console_features</span>

    <span class="s1">_windows_console_features = get_windows_console_features()</span>
    <span class="s0">return </span><span class="s1">_windows_console_features</span>


<span class="s0">def </span><span class="s1">detect_legacy_windows() -&gt; bool:</span>
    <span class="s5">&quot;&quot;&quot;Detect legacy Windows.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">WINDOWS </span><span class="s0">and not </span><span class="s1">get_windows_console_features().vt</span>


<span class="s0">class </span><span class="s1">Console:</span>
    <span class="s5">&quot;&quot;&quot;A high level console interface. 
 
    Args: 
        color_system (str, optional): The color system supported by your terminal, 
            either ``&quot;standard&quot;``, ``&quot;256&quot;`` or ``&quot;truecolor&quot;``. Leave as ``&quot;auto&quot;`` to autodetect. 
        force_terminal (Optional[bool], optional): Enable/disable terminal control codes, or None to auto-detect terminal. Defaults to None. 
        force_jupyter (Optional[bool], optional): Enable/disable Jupyter rendering, or None to auto-detect Jupyter. Defaults to None. 
        force_interactive (Optional[bool], optional): Enable/disable interactive mode, or None to auto detect. Defaults to None. 
        soft_wrap (Optional[bool], optional): Set soft wrap default on print method. Defaults to False. 
        theme (Theme, optional): An optional style theme object, or ``None`` for default theme. 
        stderr (bool, optional): Use stderr rather than stdout if ``file`` is not specified. Defaults to False. 
        file (IO, optional): A file object where the console should write to. Defaults to stdout. 
        quiet (bool, Optional): Boolean to suppress all output. Defaults to False. 
        width (int, optional): The width of the terminal. Leave as default to auto-detect width. 
        height (int, optional): The height of the terminal. Leave as default to auto-detect height. 
        style (StyleType, optional): Style to apply to all output, or None for no style. Defaults to None. 
        no_color (Optional[bool], optional): Enabled no color mode, or None to auto detect. Defaults to None. 
        tab_size (int, optional): Number of spaces used to replace a tab character. Defaults to 8. 
        record (bool, optional): Boolean to enable recording of terminal output, 
            required to call :meth:`export_html`, :meth:`export_svg`, and :meth:`export_text`. Defaults to False. 
        markup (bool, optional): Boolean to enable :ref:`console_markup`. Defaults to True. 
        emoji (bool, optional): Enable emoji code. Defaults to True. 
        emoji_variant (str, optional): Optional emoji variant, either &quot;text&quot; or &quot;emoji&quot;. Defaults to None. 
        highlight (bool, optional): Enable automatic highlighting. Defaults to True. 
        log_time (bool, optional): Boolean to enable logging of time by :meth:`log` methods. Defaults to True. 
        log_path (bool, optional): Boolean to enable the logging of the caller by :meth:`log`. Defaults to True. 
        log_time_format (Union[str, TimeFormatterCallable], optional): If ``log_time`` is enabled, either string for strftime or callable that formats the time. Defaults to &quot;[%X] &quot;. 
        highlighter (HighlighterType, optional): Default highlighter. 
        legacy_windows (bool, optional): Enable legacy Windows mode, or ``None`` to auto detect. Defaults to ``None``. 
        safe_box (bool, optional): Restrict box options that don't render on legacy Windows. 
        get_datetime (Callable[[], datetime], optional): Callable that gets the current time as a datetime.datetime object (used by Console.log), 
            or None for datetime.now. 
        get_time (Callable[[], time], optional): Callable that gets the current time in seconds, default uses time.monotonic. 
    &quot;&quot;&quot;</span>

    <span class="s1">_environ: Mapping[str</span><span class="s0">, </span><span class="s1">str] = os.environ</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">color_system: Optional[</span>
            <span class="s1">Literal[</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s4">&quot;standard&quot;</span><span class="s0">, </span><span class="s4">&quot;256&quot;</span><span class="s0">, </span><span class="s4">&quot;truecolor&quot;</span><span class="s0">, </span><span class="s4">&quot;windows&quot;</span><span class="s1">]</span>
        <span class="s1">] = </span><span class="s4">&quot;auto&quot;</span><span class="s0">,</span>
        <span class="s1">force_terminal: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">force_jupyter: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">force_interactive: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">soft_wrap: bool = </span><span class="s0">False,</span>
        <span class="s1">theme: Optional[Theme] = </span><span class="s0">None,</span>
        <span class="s1">stderr: bool = </span><span class="s0">False,</span>
        <span class="s1">file: Optional[IO[str]] = </span><span class="s0">None,</span>
        <span class="s1">quiet: bool = </span><span class="s0">False,</span>
        <span class="s1">width: Optional[int] = </span><span class="s0">None,</span>
        <span class="s1">height: Optional[int] = </span><span class="s0">None,</span>
        <span class="s1">style: Optional[StyleType] = </span><span class="s0">None,</span>
        <span class="s1">no_color: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">tab_size: int = </span><span class="s2">8</span><span class="s0">,</span>
        <span class="s1">record: bool = </span><span class="s0">False,</span>
        <span class="s1">markup: bool = </span><span class="s0">True,</span>
        <span class="s1">emoji: bool = </span><span class="s0">True,</span>
        <span class="s1">emoji_variant: Optional[EmojiVariant] = </span><span class="s0">None,</span>
        <span class="s1">highlight: bool = </span><span class="s0">True,</span>
        <span class="s1">log_time: bool = </span><span class="s0">True,</span>
        <span class="s1">log_path: bool = </span><span class="s0">True,</span>
        <span class="s1">log_time_format: Union[str</span><span class="s0">, </span><span class="s1">FormatTimeCallable] = </span><span class="s4">&quot;[%X]&quot;</span><span class="s0">,</span>
        <span class="s1">highlighter: Optional[</span><span class="s4">&quot;HighlighterType&quot;</span><span class="s1">] = ReprHighlighter()</span><span class="s0">,</span>
        <span class="s1">legacy_windows: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">safe_box: bool = </span><span class="s0">True,</span>
        <span class="s1">get_datetime: Optional[Callable[[]</span><span class="s0">, </span><span class="s1">datetime]] = </span><span class="s0">None,</span>
        <span class="s1">get_time: Optional[Callable[[]</span><span class="s0">, </span><span class="s1">float]] = </span><span class="s0">None,</span>
        <span class="s1">_environ: Optional[Mapping[str</span><span class="s0">, </span><span class="s1">str]] = </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s3"># Copy of os.environ allows us to replace it for testing</span>
        <span class="s0">if </span><span class="s1">_environ </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._environ = _environ</span>

        <span class="s1">self.is_jupyter = _is_jupyter() </span><span class="s0">if </span><span class="s1">force_jupyter </span><span class="s0">is None else </span><span class="s1">force_jupyter</span>
        <span class="s0">if </span><span class="s1">self.is_jupyter:</span>
            <span class="s0">if </span><span class="s1">width </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">jupyter_columns = self._environ.get(</span><span class="s4">&quot;JUPYTER_COLUMNS&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">jupyter_columns </span><span class="s0">is not None and </span><span class="s1">jupyter_columns.isdigit():</span>
                    <span class="s1">width = int(jupyter_columns)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">width = JUPYTER_DEFAULT_COLUMNS</span>
            <span class="s0">if </span><span class="s1">height </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">jupyter_lines = self._environ.get(</span><span class="s4">&quot;JUPYTER_LINES&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">jupyter_lines </span><span class="s0">is not None and </span><span class="s1">jupyter_lines.isdigit():</span>
                    <span class="s1">height = int(jupyter_lines)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">height = JUPYTER_DEFAULT_LINES</span>

        <span class="s1">self.tab_size = tab_size</span>
        <span class="s1">self.record = record</span>
        <span class="s1">self._markup = markup</span>
        <span class="s1">self._emoji = emoji</span>
        <span class="s1">self._emoji_variant: Optional[EmojiVariant] = emoji_variant</span>
        <span class="s1">self._highlight = highlight</span>
        <span class="s1">self.legacy_windows: bool = (</span>
            <span class="s1">(detect_legacy_windows() </span><span class="s0">and not </span><span class="s1">self.is_jupyter)</span>
            <span class="s0">if </span><span class="s1">legacy_windows </span><span class="s0">is None</span>
            <span class="s0">else </span><span class="s1">legacy_windows</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">width </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">columns = self._environ.get(</span><span class="s4">&quot;COLUMNS&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">columns </span><span class="s0">is not None and </span><span class="s1">columns.isdigit():</span>
                <span class="s1">width = int(columns) - self.legacy_windows</span>
        <span class="s0">if </span><span class="s1">height </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">lines = self._environ.get(</span><span class="s4">&quot;LINES&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">lines </span><span class="s0">is not None and </span><span class="s1">lines.isdigit():</span>
                <span class="s1">height = int(lines)</span>

        <span class="s1">self.soft_wrap = soft_wrap</span>
        <span class="s1">self._width = width</span>
        <span class="s1">self._height = height</span>

        <span class="s1">self._color_system: Optional[ColorSystem]</span>
        <span class="s1">self._force_terminal = force_terminal</span>
        <span class="s1">self._file = file</span>
        <span class="s1">self.quiet = quiet</span>
        <span class="s1">self.stderr = stderr</span>

        <span class="s0">if </span><span class="s1">color_system </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._color_system = </span><span class="s0">None</span>
        <span class="s0">elif </span><span class="s1">color_system == </span><span class="s4">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">self._color_system = self._detect_color_system()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._color_system = COLOR_SYSTEMS[color_system]</span>

        <span class="s1">self._lock = threading.RLock()</span>
        <span class="s1">self._log_render = LogRender(</span>
            <span class="s1">show_time=log_time</span><span class="s0">,</span>
            <span class="s1">show_path=log_path</span><span class="s0">,</span>
            <span class="s1">time_format=log_time_format</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">self.highlighter: HighlighterType = highlighter </span><span class="s0">or </span><span class="s1">_null_highlighter</span>
        <span class="s1">self.safe_box = safe_box</span>
        <span class="s1">self.get_datetime = get_datetime </span><span class="s0">or </span><span class="s1">datetime.now</span>
        <span class="s1">self.get_time = get_time </span><span class="s0">or </span><span class="s1">monotonic</span>
        <span class="s1">self.style = style</span>
        <span class="s1">self.no_color = (</span>
            <span class="s1">no_color </span><span class="s0">if </span><span class="s1">no_color </span><span class="s0">is not None else </span><span class="s4">&quot;NO_COLOR&quot; </span><span class="s0">in </span><span class="s1">self._environ</span>
        <span class="s1">)</span>
        <span class="s1">self.is_interactive = (</span>
            <span class="s1">(self.is_terminal </span><span class="s0">and not </span><span class="s1">self.is_dumb_terminal)</span>
            <span class="s0">if </span><span class="s1">force_interactive </span><span class="s0">is None</span>
            <span class="s0">else </span><span class="s1">force_interactive</span>
        <span class="s1">)</span>

        <span class="s1">self._record_buffer_lock = threading.RLock()</span>
        <span class="s1">self._thread_locals = ConsoleThreadLocals(</span>
            <span class="s1">theme_stack=ThemeStack(themes.DEFAULT </span><span class="s0">if </span><span class="s1">theme </span><span class="s0">is None else </span><span class="s1">theme)</span>
        <span class="s1">)</span>
        <span class="s1">self._record_buffer: List[Segment] = []</span>
        <span class="s1">self._render_hooks: List[RenderHook] = []</span>
        <span class="s1">self._live: Optional[</span><span class="s4">&quot;Live&quot;</span><span class="s1">] = </span><span class="s0">None</span>
        <span class="s1">self._is_alt_screen = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s4">f&quot;&lt;console width=</span><span class="s0">{</span><span class="s1">self.width</span><span class="s0">} {</span><span class="s1">str(self._color_system)</span><span class="s0">}</span><span class="s4">&gt;&quot;</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">file(self) -&gt; IO[str]:</span>
        <span class="s5">&quot;&quot;&quot;Get the file object to write to.&quot;&quot;&quot;</span>
        <span class="s1">file = self._file </span><span class="s0">or </span><span class="s1">(sys.stderr </span><span class="s0">if </span><span class="s1">self.stderr </span><span class="s0">else </span><span class="s1">sys.stdout)</span>
        <span class="s1">file = getattr(file</span><span class="s0">, </span><span class="s4">&quot;rich_proxied_file&quot;</span><span class="s0">, </span><span class="s1">file)</span>
        <span class="s0">return </span><span class="s1">file</span>

    <span class="s1">@file.setter</span>
    <span class="s0">def </span><span class="s1">file(self</span><span class="s0">, </span><span class="s1">new_file: IO[str]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Set a new file object.&quot;&quot;&quot;</span>
        <span class="s1">self._file = new_file</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_buffer(self) -&gt; List[Segment]:</span>
        <span class="s5">&quot;&quot;&quot;Get a thread local buffer.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._thread_locals.buffer</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_buffer_index(self) -&gt; int:</span>
        <span class="s5">&quot;&quot;&quot;Get a thread local buffer.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._thread_locals.buffer_index</span>

    <span class="s1">@_buffer_index.setter</span>
    <span class="s0">def </span><span class="s1">_buffer_index(self</span><span class="s0">, </span><span class="s1">value: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._thread_locals.buffer_index = value</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_theme_stack(self) -&gt; ThemeStack:</span>
        <span class="s5">&quot;&quot;&quot;Get the thread local theme stack.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._thread_locals.theme_stack</span>

    <span class="s0">def </span><span class="s1">_detect_color_system(self) -&gt; Optional[ColorSystem]:</span>
        <span class="s5">&quot;&quot;&quot;Detect color system from env vars.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_jupyter:</span>
            <span class="s0">return </span><span class="s1">ColorSystem.TRUECOLOR</span>
        <span class="s0">if not </span><span class="s1">self.is_terminal </span><span class="s0">or </span><span class="s1">self.is_dumb_terminal:</span>
            <span class="s0">return None</span>
        <span class="s0">if </span><span class="s1">WINDOWS:  </span><span class="s3"># pragma: no cover</span>
            <span class="s0">if </span><span class="s1">self.legacy_windows:  </span><span class="s3"># pragma: no cover</span>
                <span class="s0">return </span><span class="s1">ColorSystem.WINDOWS</span>
            <span class="s1">windows_console_features = get_windows_console_features()</span>
            <span class="s0">return </span><span class="s1">(</span>
                <span class="s1">ColorSystem.TRUECOLOR</span>
                <span class="s0">if </span><span class="s1">windows_console_features.truecolor</span>
                <span class="s0">else </span><span class="s1">ColorSystem.EIGHT_BIT</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">color_term = self._environ.get(</span><span class="s4">&quot;COLORTERM&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">).strip().lower()</span>
            <span class="s0">if </span><span class="s1">color_term </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;truecolor&quot;</span><span class="s0">, </span><span class="s4">&quot;24bit&quot;</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">ColorSystem.TRUECOLOR</span>
            <span class="s1">term = self._environ.get(</span><span class="s4">&quot;TERM&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">).strip().lower()</span>
            <span class="s1">_term_name</span><span class="s0">, </span><span class="s1">_hyphen</span><span class="s0">, </span><span class="s1">colors = term.rpartition(</span><span class="s4">&quot;-&quot;</span><span class="s1">)</span>
            <span class="s1">color_system = _TERM_COLORS.get(colors</span><span class="s0">, </span><span class="s1">ColorSystem.STANDARD)</span>
            <span class="s0">return </span><span class="s1">color_system</span>

    <span class="s0">def </span><span class="s1">_enter_buffer(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Enter in to a buffer context, and buffer all output.&quot;&quot;&quot;</span>
        <span class="s1">self._buffer_index += </span><span class="s2">1</span>

    <span class="s0">def </span><span class="s1">_exit_buffer(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Leave buffer context, and render content if required.&quot;&quot;&quot;</span>
        <span class="s1">self._buffer_index -= </span><span class="s2">1</span>
        <span class="s1">self._check_buffer()</span>

    <span class="s0">def </span><span class="s1">set_live(self</span><span class="s0">, </span><span class="s1">live: </span><span class="s4">&quot;Live&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Set Live instance. Used by Live context manager. 
 
        Args: 
            live (Live): Live instance using this Console. 
 
        Raises: 
            errors.LiveError: If this Console has a Live context currently active. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self._lock:</span>
            <span class="s0">if </span><span class="s1">self._live </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">errors.LiveError(</span><span class="s4">&quot;Only one live display may be active at once&quot;</span><span class="s1">)</span>
            <span class="s1">self._live = live</span>

    <span class="s0">def </span><span class="s1">clear_live(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Clear the Live instance.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self._lock:</span>
            <span class="s1">self._live = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">push_render_hook(self</span><span class="s0">, </span><span class="s1">hook: RenderHook) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Add a new render hook to the stack. 
 
        Args: 
            hook (RenderHook): Render hook instance. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self._lock:</span>
            <span class="s1">self._render_hooks.append(hook)</span>

    <span class="s0">def </span><span class="s1">pop_render_hook(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Pop the last renderhook from the stack.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self._lock:</span>
            <span class="s1">self._render_hooks.pop()</span>

    <span class="s0">def </span><span class="s1">__enter__(self) -&gt; </span><span class="s4">&quot;Console&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Own context manager to enter buffer context.&quot;&quot;&quot;</span>
        <span class="s1">self._enter_buffer()</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type: Any</span><span class="s0">, </span><span class="s1">exc_value: Any</span><span class="s0">, </span><span class="s1">traceback: Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Exit buffer context.&quot;&quot;&quot;</span>
        <span class="s1">self._exit_buffer()</span>

    <span class="s0">def </span><span class="s1">begin_capture(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Begin capturing console output. Call :meth:`end_capture` to exit capture mode and return output.&quot;&quot;&quot;</span>
        <span class="s1">self._enter_buffer()</span>

    <span class="s0">def </span><span class="s1">end_capture(self) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot;End capture mode and return captured string. 
 
        Returns: 
            str: Console output. 
        &quot;&quot;&quot;</span>
        <span class="s1">render_result = self._render_buffer(self._buffer)</span>
        <span class="s0">del </span><span class="s1">self._buffer[:]</span>
        <span class="s1">self._exit_buffer()</span>
        <span class="s0">return </span><span class="s1">render_result</span>

    <span class="s0">def </span><span class="s1">push_theme(self</span><span class="s0">, </span><span class="s1">theme: Theme</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">inherit: bool = </span><span class="s0">True</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Push a new theme on to the top of the stack, replacing the styles from the previous theme. 
        Generally speaking, you should call :meth:`~rich.console.Console.use_theme` to get a context manager, rather 
        than calling this method directly. 
 
        Args: 
            theme (Theme): A theme instance. 
            inherit (bool, optional): Inherit existing styles. Defaults to True. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._theme_stack.push_theme(theme</span><span class="s0">, </span><span class="s1">inherit=inherit)</span>

    <span class="s0">def </span><span class="s1">pop_theme(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Remove theme from top of stack, restoring previous theme.&quot;&quot;&quot;</span>
        <span class="s1">self._theme_stack.pop_theme()</span>

    <span class="s0">def </span><span class="s1">use_theme(self</span><span class="s0">, </span><span class="s1">theme: Theme</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">inherit: bool = </span><span class="s0">True</span><span class="s1">) -&gt; ThemeContext:</span>
        <span class="s5">&quot;&quot;&quot;Use a different theme for the duration of the context manager. 
 
        Args: 
            theme (Theme): Theme instance to user. 
            inherit (bool, optional): Inherit existing console styles. Defaults to True. 
 
        Returns: 
            ThemeContext: [description] 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">ThemeContext(self</span><span class="s0">, </span><span class="s1">theme</span><span class="s0">, </span><span class="s1">inherit)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">color_system(self) -&gt; Optional[str]:</span>
        <span class="s5">&quot;&quot;&quot;Get color system string. 
 
        Returns: 
            Optional[str]: &quot;standard&quot;, &quot;256&quot; or &quot;truecolor&quot;. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">self._color_system </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">_COLOR_SYSTEMS_NAMES[self._color_system]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">encoding(self) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot;Get the encoding of the console file, e.g. ``&quot;utf-8&quot;``. 
 
        Returns: 
            str: A standard encoding string. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(getattr(self.file</span><span class="s0">, </span><span class="s4">&quot;encoding&quot;</span><span class="s0">, </span><span class="s4">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">&quot;utf-8&quot;</span><span class="s1">).lower()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_terminal(self) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Check if the console is writing to a terminal. 
 
        Returns: 
            bool: True if the console writing to a device capable of 
            understanding terminal codes, otherwise False. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._force_terminal </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._force_terminal</span>

        <span class="s0">if </span><span class="s1">hasattr(sys.stdin</span><span class="s0">, </span><span class="s4">&quot;__module__&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">sys.stdin.__module__.startswith(</span>
            <span class="s4">&quot;idlelib&quot;</span>
        <span class="s1">):</span>
            <span class="s3"># Return False for Idle which claims to be a tty but can't handle ansi codes</span>
            <span class="s0">return False</span>

        <span class="s1">isatty: Optional[Callable[[]</span><span class="s0">, </span><span class="s1">bool]] = getattr(self.file</span><span class="s0">, </span><span class="s4">&quot;isatty&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return False if </span><span class="s1">isatty </span><span class="s0">is None else </span><span class="s1">isatty()</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s3"># in some situation (at the end of a pytest run for example) isatty() can raise</span>
            <span class="s3"># ValueError: I/O operation on closed file</span>
            <span class="s3"># return False because we aren't in a terminal anymore</span>
            <span class="s0">return False</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_dumb_terminal(self) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Detect dumb terminal. 
 
        Returns: 
            bool: True if writing to a dumb terminal, otherwise False. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_term = self._environ.get(</span><span class="s4">&quot;TERM&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">is_dumb = _term.lower() </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;dumb&quot;</span><span class="s0">, </span><span class="s4">&quot;unknown&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self.is_terminal </span><span class="s0">and </span><span class="s1">is_dumb</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">options(self) -&gt; ConsoleOptions:</span>
        <span class="s5">&quot;&quot;&quot;Get default console options.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">ConsoleOptions(</span>
            <span class="s1">max_height=self.size.height</span><span class="s0">,</span>
            <span class="s1">size=self.size</span><span class="s0">,</span>
            <span class="s1">legacy_windows=self.legacy_windows</span><span class="s0">,</span>
            <span class="s1">min_width=</span><span class="s2">1</span><span class="s0">,</span>
            <span class="s1">max_width=self.width</span><span class="s0">,</span>
            <span class="s1">encoding=self.encoding</span><span class="s0">,</span>
            <span class="s1">is_terminal=self.is_terminal</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">size(self) -&gt; ConsoleDimensions:</span>
        <span class="s5">&quot;&quot;&quot;Get the size of the console. 
 
        Returns: 
            ConsoleDimensions: A named tuple containing the dimensions. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">self._width </span><span class="s0">is not None and </span><span class="s1">self._height </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">ConsoleDimensions(self._width - self.legacy_windows</span><span class="s0">, </span><span class="s1">self._height)</span>

        <span class="s0">if </span><span class="s1">self.is_dumb_terminal:</span>
            <span class="s0">return </span><span class="s1">ConsoleDimensions(</span><span class="s2">80</span><span class="s0">, </span><span class="s2">25</span><span class="s1">)</span>

        <span class="s1">width: Optional[int] = </span><span class="s0">None</span>
        <span class="s1">height: Optional[int] = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">WINDOWS:  </span><span class="s3"># pragma: no cover</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">width</span><span class="s0">, </span><span class="s1">height = os.get_terminal_size()</span>
            <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s1">OSError):  </span><span class="s3"># Probably not a terminal</span>
                <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">file_descriptor </span><span class="s0">in </span><span class="s1">_STD_STREAMS:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">width</span><span class="s0">, </span><span class="s1">height = os.get_terminal_size(file_descriptor)</span>
                <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s1">OSError):</span>
                    <span class="s0">pass</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">break</span>

        <span class="s1">columns = self._environ.get(</span><span class="s4">&quot;COLUMNS&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">columns </span><span class="s0">is not None and </span><span class="s1">columns.isdigit():</span>
            <span class="s1">width = int(columns)</span>
        <span class="s1">lines = self._environ.get(</span><span class="s4">&quot;LINES&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">lines </span><span class="s0">is not None and </span><span class="s1">lines.isdigit():</span>
            <span class="s1">height = int(lines)</span>

        <span class="s3"># get_terminal_size can report 0, 0 if run from pseudo-terminal</span>
        <span class="s1">width = width </span><span class="s0">or </span><span class="s2">80</span>
        <span class="s1">height = height </span><span class="s0">or </span><span class="s2">25</span>
        <span class="s0">return </span><span class="s1">ConsoleDimensions(</span>
            <span class="s1">width - self.legacy_windows </span><span class="s0">if </span><span class="s1">self._width </span><span class="s0">is None else </span><span class="s1">self._width</span><span class="s0">,</span>
            <span class="s1">height </span><span class="s0">if </span><span class="s1">self._height </span><span class="s0">is None else </span><span class="s1">self._height</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@size.setter</span>
    <span class="s0">def </span><span class="s1">size(self</span><span class="s0">, </span><span class="s1">new_size: Tuple[int</span><span class="s0">, </span><span class="s1">int]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Set a new size for the terminal. 
 
        Args: 
            new_size (Tuple[int, int]): New width and height. 
        &quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = new_size</span>
        <span class="s1">self._width = width</span>
        <span class="s1">self._height = height</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">width(self) -&gt; int:</span>
        <span class="s5">&quot;&quot;&quot;Get the width of the console. 
 
        Returns: 
            int: The width (in characters) of the console. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.size.width</span>

    <span class="s1">@width.setter</span>
    <span class="s0">def </span><span class="s1">width(self</span><span class="s0">, </span><span class="s1">width: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Set width. 
 
        Args: 
            width (int): New width. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._width = width</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">height(self) -&gt; int:</span>
        <span class="s5">&quot;&quot;&quot;Get the height of the console. 
 
        Returns: 
            int: The height (in lines) of the console. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.size.height</span>

    <span class="s1">@height.setter</span>
    <span class="s0">def </span><span class="s1">height(self</span><span class="s0">, </span><span class="s1">height: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Set height. 
 
        Args: 
            height (int): new height. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._height = height</span>

    <span class="s0">def </span><span class="s1">bell(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Play a 'bell' sound (if supported by the terminal).&quot;&quot;&quot;</span>
        <span class="s1">self.control(Control.bell())</span>

    <span class="s0">def </span><span class="s1">capture(self) -&gt; Capture:</span>
        <span class="s5">&quot;&quot;&quot;A context manager to *capture* the result of print() or log() in a string, 
        rather than writing it to the console. 
 
        Example: 
            &gt;&gt;&gt; from rich.console import Console 
            &gt;&gt;&gt; console = Console() 
            &gt;&gt;&gt; with console.capture() as capture: 
            ...     console.print(&quot;[bold magenta]Hello World[/]&quot;) 
            &gt;&gt;&gt; print(capture.get()) 
 
        Returns: 
            Capture: Context manager with disables writing to the terminal. 
        &quot;&quot;&quot;</span>
        <span class="s1">capture = Capture(self)</span>
        <span class="s0">return </span><span class="s1">capture</span>

    <span class="s0">def </span><span class="s1">pager(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">pager: Optional[Pager] = </span><span class="s0">None, </span><span class="s1">styles: bool = </span><span class="s0">False, </span><span class="s1">links: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; PagerContext:</span>
        <span class="s5">&quot;&quot;&quot;A context manager to display anything printed within a &quot;pager&quot;. The pager application 
        is defined by the system and will typically support at least pressing a key to scroll. 
 
        Args: 
            pager (Pager, optional): A pager object, or None to use :class:`~rich.pager.SystemPager`. Defaults to None. 
            styles (bool, optional): Show styles in pager. Defaults to False. 
            links (bool, optional): Show links in pager. Defaults to False. 
 
        Example: 
            &gt;&gt;&gt; from rich.console import Console 
            &gt;&gt;&gt; from rich.__main__ import make_test_card 
            &gt;&gt;&gt; console = Console() 
            &gt;&gt;&gt; with console.pager(): 
                    console.print(make_test_card()) 
 
        Returns: 
            PagerContext: A context manager. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">PagerContext(self</span><span class="s0">, </span><span class="s1">pager=pager</span><span class="s0">, </span><span class="s1">styles=styles</span><span class="s0">, </span><span class="s1">links=links)</span>

    <span class="s0">def </span><span class="s1">line(self</span><span class="s0">, </span><span class="s1">count: int = </span><span class="s2">1</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Write new line(s). 
 
        Args: 
            count (int, optional): Number of new lines. Defaults to 1. 
        &quot;&quot;&quot;</span>

        <span class="s0">assert </span><span class="s1">count &gt;= </span><span class="s2">0</span><span class="s0">, </span><span class="s4">&quot;count must be &gt;= 0&quot;</span>
        <span class="s1">self.print(NewLine(count))</span>

    <span class="s0">def </span><span class="s1">clear(self</span><span class="s0">, </span><span class="s1">home: bool = </span><span class="s0">True</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Clear the screen. 
 
        Args: 
            home (bool, optional): Also move the cursor to 'home' position. Defaults to True. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">home:</span>
            <span class="s1">self.control(Control.clear()</span><span class="s0">, </span><span class="s1">Control.home())</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.control(Control.clear())</span>

    <span class="s0">def </span><span class="s1">status(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">status: RenderableType</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">spinner: str = </span><span class="s4">&quot;dots&quot;</span><span class="s0">,</span>
        <span class="s1">spinner_style: str = </span><span class="s4">&quot;status.spinner&quot;</span><span class="s0">,</span>
        <span class="s1">speed: float = </span><span class="s2">1.0</span><span class="s0">,</span>
        <span class="s1">refresh_per_second: float = </span><span class="s2">12.5</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;Status&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Display a status and spinner. 
 
        Args: 
            status (RenderableType): A status renderable (str or Text typically). 
            spinner (str, optional): Name of spinner animation (see python -m rich.spinner). Defaults to &quot;dots&quot;. 
            spinner_style (StyleType, optional): Style of spinner. Defaults to &quot;status.spinner&quot;. 
            speed (float, optional): Speed factor for spinner animation. Defaults to 1.0. 
            refresh_per_second (float, optional): Number of refreshes per second. Defaults to 12.5. 
 
        Returns: 
            Status: A Status object that may be used as a context manager. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.status </span><span class="s0">import </span><span class="s1">Status</span>

        <span class="s1">status_renderable = Status(</span>
            <span class="s1">status</span><span class="s0">,</span>
            <span class="s1">console=self</span><span class="s0">,</span>
            <span class="s1">spinner=spinner</span><span class="s0">,</span>
            <span class="s1">spinner_style=spinner_style</span><span class="s0">,</span>
            <span class="s1">speed=speed</span><span class="s0">,</span>
            <span class="s1">refresh_per_second=refresh_per_second</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">status_renderable</span>

    <span class="s0">def </span><span class="s1">show_cursor(self</span><span class="s0">, </span><span class="s1">show: bool = </span><span class="s0">True</span><span class="s1">) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Show or hide the cursor. 
 
        Args: 
            show (bool, optional): Set visibility of the cursor. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_terminal:</span>
            <span class="s1">self.control(Control.show_cursor(show))</span>
            <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">set_alt_screen(self</span><span class="s0">, </span><span class="s1">enable: bool = </span><span class="s0">True</span><span class="s1">) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Enables alternative screen mode. 
 
        Note, if you enable this mode, you should ensure that is disabled before 
        the application exits. See :meth:`~rich.Console.screen` for a context manager 
        that handles this for you. 
 
        Args: 
            enable (bool, optional): Enable (True) or disable (False) alternate screen. Defaults to True. 
 
        Returns: 
            bool: True if the control codes were written. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">changed = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">self.is_terminal </span><span class="s0">and not </span><span class="s1">self.legacy_windows:</span>
            <span class="s1">self.control(Control.alt_screen(enable))</span>
            <span class="s1">changed = </span><span class="s0">True</span>
            <span class="s1">self._is_alt_screen = enable</span>
        <span class="s0">return </span><span class="s1">changed</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_alt_screen(self) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Check if the alt screen was enabled. 
 
        Returns: 
            bool: True if the alt screen was enabled, otherwise False. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._is_alt_screen</span>

    <span class="s0">def </span><span class="s1">set_window_title(self</span><span class="s0">, </span><span class="s1">title: str) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Set the title of the console terminal window. 
 
        Warning: There is no means within Rich of &quot;resetting&quot; the window title to its 
        previous value, meaning the title you set will persist even after your application 
        exits. 
 
        ``fish`` shell resets the window title before and after each command by default, 
        negating this issue. Windows Terminal and command prompt will also reset the title for you. 
        Most other shells and terminals, however, do not do this. 
 
        Some terminals may require configuration changes before you can set the title. 
        Some terminals may not support setting the title at all. 
 
        Other software (including the terminal itself, the shell, custom prompts, plugins, etc.) 
        may also set the terminal window title. This could result in whatever value you write 
        using this method being overwritten. 
 
        Args: 
            title (str): The new title of the terminal window. 
 
        Returns: 
            bool: True if the control code to change the terminal title was 
                written, otherwise False. Note that a return value of True 
                does not guarantee that the window title has actually changed, 
                since the feature may be unsupported/disabled in some terminals. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.is_terminal:</span>
            <span class="s1">self.control(Control.title(title))</span>
            <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">screen(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">hide_cursor: bool = </span><span class="s0">True, </span><span class="s1">style: Optional[StyleType] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;ScreenContext&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Context manager to enable and disable 'alternative screen' mode. 
 
        Args: 
            hide_cursor (bool, optional): Also hide the cursor. Defaults to False. 
            style (Style, optional): Optional style for screen. Defaults to None. 
 
        Returns: 
            ~ScreenContext: Context which enables alternate screen on enter, and disables it on exit. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">ScreenContext(self</span><span class="s0">, </span><span class="s1">hide_cursor=hide_cursor</span><span class="s0">, </span><span class="s1">style=style </span><span class="s0">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">measure(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">renderable: RenderableType</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">options: Optional[ConsoleOptions] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; Measurement:</span>
        <span class="s5">&quot;&quot;&quot;Measure a renderable. Returns a :class:`~rich.measure.Measurement` object which contains 
        information regarding the number of characters required to print the renderable. 
 
        Args: 
            renderable (RenderableType): Any renderable or string. 
            options (Optional[ConsoleOptions], optional): Options to use when measuring, or None 
                to use default options. Defaults to None. 
 
        Returns: 
            Measurement: A measurement of the renderable. 
        &quot;&quot;&quot;</span>
        <span class="s1">measurement = Measurement.get(self</span><span class="s0">, </span><span class="s1">options </span><span class="s0">or </span><span class="s1">self.options</span><span class="s0">, </span><span class="s1">renderable)</span>
        <span class="s0">return </span><span class="s1">measurement</span>

    <span class="s0">def </span><span class="s1">render(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">renderable: RenderableType</span><span class="s0">, </span><span class="s1">options: Optional[ConsoleOptions] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; Iterable[Segment]:</span>
        <span class="s5">&quot;&quot;&quot;Render an object in to an iterable of `Segment` instances. 
 
        This method contains the logic for rendering objects with the console protocol. 
        You are unlikely to need to use it directly, unless you are extending the library. 
 
        Args: 
            renderable (RenderableType): An object supporting the console protocol, or 
                an object that may be converted to a string. 
            options (ConsoleOptions, optional): An options object, or None to use self.options. Defaults to None. 
 
        Returns: 
            Iterable[Segment]: An iterable of segments that may be rendered. 
        &quot;&quot;&quot;</span>

        <span class="s1">_options = options </span><span class="s0">or </span><span class="s1">self.options</span>
        <span class="s0">if </span><span class="s1">_options.max_width &lt; </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s3"># No space to render anything. This prevents potential recursion errors.</span>
            <span class="s0">return</span>
        <span class="s1">render_iterable: RenderResult</span>

        <span class="s1">renderable = rich_cast(renderable)</span>
        <span class="s0">if </span><span class="s1">hasattr(renderable</span><span class="s0">, </span><span class="s4">&quot;__rich_console__&quot;</span><span class="s1">) </span><span class="s0">and not </span><span class="s1">isclass(renderable):</span>
            <span class="s1">render_iterable = renderable.__rich_console__(self</span><span class="s0">, </span><span class="s1">_options)  </span><span class="s3"># type: ignore[union-attr]</span>
        <span class="s0">elif </span><span class="s1">isinstance(renderable</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">text_renderable = self.render_str(</span>
                <span class="s1">renderable</span><span class="s0">, </span><span class="s1">highlight=_options.highlight</span><span class="s0">, </span><span class="s1">markup=_options.markup</span>
            <span class="s1">)</span>
            <span class="s1">render_iterable = text_renderable.__rich_console__(self</span><span class="s0">, </span><span class="s1">_options)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">errors.NotRenderableError(</span>
                <span class="s4">f&quot;Unable to render </span><span class="s0">{</span><span class="s1">renderable</span><span class="s0">!r}</span><span class="s4">; &quot;</span>
                <span class="s4">&quot;A str, Segment or object with __rich_console__ method is required&quot;</span>
            <span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">iter_render = iter(render_iterable)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">raise </span><span class="s1">errors.NotRenderableError(</span>
                <span class="s4">f&quot;object </span><span class="s0">{</span><span class="s1">render_iterable</span><span class="s0">!r} </span><span class="s4">is not renderable&quot;</span>
            <span class="s1">)</span>
        <span class="s1">_Segment = Segment</span>
        <span class="s1">_options = _options.reset_height()</span>
        <span class="s0">for </span><span class="s1">render_output </span><span class="s0">in </span><span class="s1">iter_render:</span>
            <span class="s0">if </span><span class="s1">isinstance(render_output</span><span class="s0">, </span><span class="s1">_Segment):</span>
                <span class="s0">yield </span><span class="s1">render_output</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">yield from </span><span class="s1">self.render(render_output</span><span class="s0">, </span><span class="s1">_options)</span>

    <span class="s0">def </span><span class="s1">render_lines(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">renderable: RenderableType</span><span class="s0">,</span>
        <span class="s1">options: Optional[ConsoleOptions] = </span><span class="s0">None,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">style: Optional[Style] = </span><span class="s0">None,</span>
        <span class="s1">pad: bool = </span><span class="s0">True,</span>
        <span class="s1">new_lines: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; List[List[Segment]]:</span>
        <span class="s5">&quot;&quot;&quot;Render objects in to a list of lines. 
 
        The output of render_lines is useful when further formatting of rendered console text 
        is required, such as the Panel class which draws a border around any renderable object. 
 
        Args: 
            renderable (RenderableType): Any object renderable in the console. 
            options (Optional[ConsoleOptions], optional): Console options, or None to use self.options. Default to ``None``. 
            style (Style, optional): Optional style to apply to renderables. Defaults to ``None``. 
            pad (bool, optional): Pad lines shorter than render width. Defaults to ``True``. 
            new_lines (bool, optional): Include &quot;\n&quot; characters at end of lines. 
 
        Returns: 
            List[List[Segment]]: A list of lines, where a line is a list of Segment objects. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self._lock:</span>
            <span class="s1">render_options = options </span><span class="s0">or </span><span class="s1">self.options</span>
            <span class="s1">_rendered = self.render(renderable</span><span class="s0">, </span><span class="s1">render_options)</span>
            <span class="s0">if </span><span class="s1">style:</span>
                <span class="s1">_rendered = Segment.apply_style(_rendered</span><span class="s0">, </span><span class="s1">style)</span>

            <span class="s1">render_height = render_options.height</span>
            <span class="s0">if </span><span class="s1">render_height </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">render_height = max(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">render_height)</span>

            <span class="s1">lines = list(</span>
                <span class="s1">islice(</span>
                    <span class="s1">Segment.split_and_crop_lines(</span>
                        <span class="s1">_rendered</span><span class="s0">,</span>
                        <span class="s1">render_options.max_width</span><span class="s0">,</span>
                        <span class="s1">include_new_lines=new_lines</span><span class="s0">,</span>
                        <span class="s1">pad=pad</span><span class="s0">,</span>
                        <span class="s1">style=style</span><span class="s0">,</span>
                    <span class="s1">)</span><span class="s0">,</span>
                    <span class="s0">None,</span>
                    <span class="s1">render_height</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">render_options.height </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">extra_lines = render_options.height - len(lines)</span>
                <span class="s0">if </span><span class="s1">extra_lines &gt; </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">pad_line = [</span>
                        <span class="s1">[Segment(</span><span class="s4">&quot; &quot; </span><span class="s1">* render_options.max_width</span><span class="s0">, </span><span class="s1">style)</span><span class="s0">, </span><span class="s1">Segment(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">)]</span>
                        <span class="s0">if </span><span class="s1">new_lines</span>
                        <span class="s0">else </span><span class="s1">[Segment(</span><span class="s4">&quot; &quot; </span><span class="s1">* render_options.max_width</span><span class="s0">, </span><span class="s1">style)]</span>
                    <span class="s1">]</span>
                    <span class="s1">lines.extend(pad_line * extra_lines)</span>

            <span class="s0">return </span><span class="s1">lines</span>

    <span class="s0">def </span><span class="s1">render_str(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">text: str</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">style: Union[str</span><span class="s0">, </span><span class="s1">Style] = </span><span class="s4">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">justify: Optional[JustifyMethod] = </span><span class="s0">None,</span>
        <span class="s1">overflow: Optional[OverflowMethod] = </span><span class="s0">None,</span>
        <span class="s1">emoji: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">markup: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">highlight: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">highlighter: Optional[HighlighterType] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Convert a string to a Text instance. This is called automatically if 
        you print or log a string. 
 
        Args: 
            text (str): Text to render. 
            style (Union[str, Style], optional): Style to apply to rendered text. 
            justify (str, optional): Justify method: &quot;default&quot;, &quot;left&quot;, &quot;center&quot;, &quot;full&quot;, or &quot;right&quot;. Defaults to ``None``. 
            overflow (str, optional): Overflow method: &quot;crop&quot;, &quot;fold&quot;, or &quot;ellipsis&quot;. Defaults to ``None``. 
            emoji (Optional[bool], optional): Enable emoji, or ``None`` to use Console default. 
            markup (Optional[bool], optional): Enable markup, or ``None`` to use Console default. 
            highlight (Optional[bool], optional): Enable highlighting, or ``None`` to use Console default. 
            highlighter (HighlighterType, optional): Optional highlighter to apply. 
        Returns: 
            ConsoleRenderable: Renderable object. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">emoji_enabled = emoji </span><span class="s0">or </span><span class="s1">(emoji </span><span class="s0">is None and </span><span class="s1">self._emoji)</span>
        <span class="s1">markup_enabled = markup </span><span class="s0">or </span><span class="s1">(markup </span><span class="s0">is None and </span><span class="s1">self._markup)</span>
        <span class="s1">highlight_enabled = highlight </span><span class="s0">or </span><span class="s1">(highlight </span><span class="s0">is None and </span><span class="s1">self._highlight)</span>

        <span class="s0">if </span><span class="s1">markup_enabled:</span>
            <span class="s1">rich_text = render_markup(</span>
                <span class="s1">text</span><span class="s0">,</span>
                <span class="s1">style=style</span><span class="s0">,</span>
                <span class="s1">emoji=emoji_enabled</span><span class="s0">,</span>
                <span class="s1">emoji_variant=self._emoji_variant</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">rich_text.justify = justify</span>
            <span class="s1">rich_text.overflow = overflow</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">rich_text = Text(</span>
                <span class="s1">_emoji_replace(text</span><span class="s0">, </span><span class="s1">default_variant=self._emoji_variant)</span>
                <span class="s0">if </span><span class="s1">emoji_enabled</span>
                <span class="s0">else </span><span class="s1">text</span><span class="s0">,</span>
                <span class="s1">justify=justify</span><span class="s0">,</span>
                <span class="s1">overflow=overflow</span><span class="s0">,</span>
                <span class="s1">style=style</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">_highlighter = (highlighter </span><span class="s0">or </span><span class="s1">self.highlighter) </span><span class="s0">if </span><span class="s1">highlight_enabled </span><span class="s0">else None</span>
        <span class="s0">if </span><span class="s1">_highlighter </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">highlight_text = _highlighter(str(rich_text))</span>
            <span class="s1">highlight_text.copy_styles(rich_text)</span>
            <span class="s0">return </span><span class="s1">highlight_text</span>

        <span class="s0">return </span><span class="s1">rich_text</span>

    <span class="s0">def </span><span class="s1">get_style(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: Union[str</span><span class="s0">, </span><span class="s1">Style]</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">default: Optional[Union[Style</span><span class="s0">, </span><span class="s1">str]] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; Style:</span>
        <span class="s5">&quot;&quot;&quot;Get a Style instance by its theme name or parse a definition. 
 
        Args: 
            name (str): The name of a style or a style definition. 
 
        Returns: 
            Style: A Style object. 
 
        Raises: 
            MissingStyle: If no style could be parsed from name. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(name</span><span class="s0">, </span><span class="s1">Style):</span>
            <span class="s0">return </span><span class="s1">name</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">style = self._theme_stack.get(name)</span>
            <span class="s0">if </span><span class="s1">style </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">style = Style.parse(name)</span>
            <span class="s0">return </span><span class="s1">style.copy() </span><span class="s0">if </span><span class="s1">style.link </span><span class="s0">else </span><span class="s1">style</span>
        <span class="s0">except </span><span class="s1">errors.StyleSyntaxError </span><span class="s0">as </span><span class="s1">error:</span>
            <span class="s0">if </span><span class="s1">default </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.get_style(default)</span>
            <span class="s0">raise </span><span class="s1">errors.MissingStyle(</span>
                <span class="s4">f&quot;Failed to get style </span><span class="s0">{</span><span class="s1">name</span><span class="s0">!r}</span><span class="s4">; </span><span class="s0">{</span><span class="s1">error</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s1">) </span><span class="s0">from None</span>

    <span class="s0">def </span><span class="s1">_collect_renderables(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">objects: Iterable[Any]</span><span class="s0">,</span>
        <span class="s1">sep: str</span><span class="s0">,</span>
        <span class="s1">end: str</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">justify: Optional[JustifyMethod] = </span><span class="s0">None,</span>
        <span class="s1">emoji: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">markup: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">highlight: Optional[bool] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; List[ConsoleRenderable]:</span>
        <span class="s5">&quot;&quot;&quot;Combine a number of renderables and text into one renderable. 
 
        Args: 
            objects (Iterable[Any]): Anything that Rich can render. 
            sep (str): String to write between print data. 
            end (str): String to write at end of print data. 
            justify (str, optional): One of &quot;left&quot;, &quot;right&quot;, &quot;center&quot;, or &quot;full&quot;. Defaults to ``None``. 
            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. 
            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. 
            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. 
 
        Returns: 
            List[ConsoleRenderable]: A list of things to render. 
        &quot;&quot;&quot;</span>
        <span class="s1">renderables: List[ConsoleRenderable] = []</span>
        <span class="s1">_append = renderables.append</span>
        <span class="s1">text: List[Text] = []</span>
        <span class="s1">append_text = text.append</span>

        <span class="s1">append = _append</span>
        <span class="s0">if </span><span class="s1">justify </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;left&quot;</span><span class="s0">, </span><span class="s4">&quot;center&quot;</span><span class="s0">, </span><span class="s4">&quot;right&quot;</span><span class="s1">):</span>

            <span class="s0">def </span><span class="s1">align_append(renderable: RenderableType) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
                <span class="s1">_append(Align(renderable</span><span class="s0">, </span><span class="s1">cast(AlignMethod</span><span class="s0">, </span><span class="s1">justify)))</span>

            <span class="s1">append = align_append</span>

        <span class="s1">_highlighter: HighlighterType = _null_highlighter</span>
        <span class="s0">if </span><span class="s1">highlight </span><span class="s0">or </span><span class="s1">(highlight </span><span class="s0">is None and </span><span class="s1">self._highlight):</span>
            <span class="s1">_highlighter = self.highlighter</span>

        <span class="s0">def </span><span class="s1">check_text() -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">text:</span>
                <span class="s1">sep_text = Text(sep</span><span class="s0">, </span><span class="s1">justify=justify</span><span class="s0">, </span><span class="s1">end=end)</span>
                <span class="s1">append(sep_text.join(text))</span>
                <span class="s0">del </span><span class="s1">text[:]</span>

        <span class="s0">for </span><span class="s1">renderable </span><span class="s0">in </span><span class="s1">objects:</span>
            <span class="s1">renderable = rich_cast(renderable)</span>
            <span class="s0">if </span><span class="s1">isinstance(renderable</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">append_text(</span>
                    <span class="s1">self.render_str(</span>
                        <span class="s1">renderable</span><span class="s0">, </span><span class="s1">emoji=emoji</span><span class="s0">, </span><span class="s1">markup=markup</span><span class="s0">, </span><span class="s1">highlighter=_highlighter</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">isinstance(renderable</span><span class="s0">, </span><span class="s1">Text):</span>
                <span class="s1">append_text(renderable)</span>
            <span class="s0">elif </span><span class="s1">isinstance(renderable</span><span class="s0">, </span><span class="s1">ConsoleRenderable):</span>
                <span class="s1">check_text()</span>
                <span class="s1">append(renderable)</span>
            <span class="s0">elif </span><span class="s1">is_expandable(renderable):</span>
                <span class="s1">check_text()</span>
                <span class="s1">append(Pretty(renderable</span><span class="s0">, </span><span class="s1">highlighter=_highlighter))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">append_text(_highlighter(str(renderable)))</span>

        <span class="s1">check_text()</span>

        <span class="s0">if </span><span class="s1">self.style </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">style = self.get_style(self.style)</span>
            <span class="s1">renderables = [Styled(renderable</span><span class="s0">, </span><span class="s1">style) </span><span class="s0">for </span><span class="s1">renderable </span><span class="s0">in </span><span class="s1">renderables]</span>

        <span class="s0">return </span><span class="s1">renderables</span>

    <span class="s0">def </span><span class="s1">rule(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">title: TextType = </span><span class="s4">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">characters: str = </span><span class="s4">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">style: Union[str</span><span class="s0">, </span><span class="s1">Style] = </span><span class="s4">&quot;rule.line&quot;</span><span class="s0">,</span>
        <span class="s1">align: AlignMethod = </span><span class="s4">&quot;center&quot;</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Draw a line with optional centered title. 
 
        Args: 
            title (str, optional): Text to render over the rule. Defaults to &quot;&quot;. 
            characters (str, optional): Character(s) to form the line. Defaults to &quot;&quot;. 
            style (str, optional): Style of line. Defaults to &quot;rule.line&quot;. 
            align (str, optional): How to align the title, one of &quot;left&quot;, &quot;center&quot;, or &quot;right&quot;. Defaults to &quot;center&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.rule </span><span class="s0">import </span><span class="s1">Rule</span>

        <span class="s1">rule = Rule(title=title</span><span class="s0">, </span><span class="s1">characters=characters</span><span class="s0">, </span><span class="s1">style=style</span><span class="s0">, </span><span class="s1">align=align)</span>
        <span class="s1">self.print(rule)</span>

    <span class="s0">def </span><span class="s1">control(self</span><span class="s0">, </span><span class="s1">*control: Control) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Insert non-printing control codes. 
 
        Args: 
            control_codes (str): Control codes, such as those that may move the cursor. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.is_dumb_terminal:</span>
            <span class="s0">with </span><span class="s1">self:</span>
                <span class="s1">self._buffer.extend(_control.segment </span><span class="s0">for </span><span class="s1">_control </span><span class="s0">in </span><span class="s1">control)</span>

    <span class="s0">def </span><span class="s1">out(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*objects: Any</span><span class="s0">,</span>
        <span class="s1">sep: str = </span><span class="s4">&quot; &quot;</span><span class="s0">,</span>
        <span class="s1">end: str = </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s0">,</span>
        <span class="s1">style: Optional[Union[str</span><span class="s0">, </span><span class="s1">Style]] = </span><span class="s0">None,</span>
        <span class="s1">highlight: Optional[bool] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Output to the terminal. This is a low-level way of writing to the terminal which unlike 
        :meth:`~rich.console.Console.print` won't pretty print, wrap text, or apply markup, but will 
        optionally apply highlighting and a basic style. 
 
        Args: 
            sep (str, optional): String to write between print data. Defaults to &quot; &quot;. 
            end (str, optional): String to write at end of print data. Defaults to &quot;\\\\n&quot;. 
            style (Union[str, Style], optional): A style to apply to output. Defaults to None. 
            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use 
                console default. Defaults to ``None``. 
        &quot;&quot;&quot;</span>
        <span class="s1">raw_output: str = sep.join(str(_object) </span><span class="s0">for </span><span class="s1">_object </span><span class="s0">in </span><span class="s1">objects)</span>
        <span class="s1">self.print(</span>
            <span class="s1">raw_output</span><span class="s0">,</span>
            <span class="s1">style=style</span><span class="s0">,</span>
            <span class="s1">highlight=highlight</span><span class="s0">,</span>
            <span class="s1">emoji=</span><span class="s0">False,</span>
            <span class="s1">markup=</span><span class="s0">False,</span>
            <span class="s1">no_wrap=</span><span class="s0">True,</span>
            <span class="s1">overflow=</span><span class="s4">&quot;ignore&quot;</span><span class="s0">,</span>
            <span class="s1">crop=</span><span class="s0">False,</span>
            <span class="s1">end=end</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">print(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*objects: Any</span><span class="s0">,</span>
        <span class="s1">sep: str = </span><span class="s4">&quot; &quot;</span><span class="s0">,</span>
        <span class="s1">end: str = </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s0">,</span>
        <span class="s1">style: Optional[Union[str</span><span class="s0">, </span><span class="s1">Style]] = </span><span class="s0">None,</span>
        <span class="s1">justify: Optional[JustifyMethod] = </span><span class="s0">None,</span>
        <span class="s1">overflow: Optional[OverflowMethod] = </span><span class="s0">None,</span>
        <span class="s1">no_wrap: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">emoji: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">markup: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">highlight: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">width: Optional[int] = </span><span class="s0">None,</span>
        <span class="s1">height: Optional[int] = </span><span class="s0">None,</span>
        <span class="s1">crop: bool = </span><span class="s0">True,</span>
        <span class="s1">soft_wrap: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">new_line_start: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Print to the console. 
 
        Args: 
            objects (positional args): Objects to log to the terminal. 
            sep (str, optional): String to write between print data. Defaults to &quot; &quot;. 
            end (str, optional): String to write at end of print data. Defaults to &quot;\\\\n&quot;. 
            style (Union[str, Style], optional): A style to apply to output. Defaults to None. 
            justify (str, optional): Justify method: &quot;default&quot;, &quot;left&quot;, &quot;right&quot;, &quot;center&quot;, or &quot;full&quot;. Defaults to ``None``. 
            overflow (str, optional): Overflow method: &quot;ignore&quot;, &quot;crop&quot;, &quot;fold&quot;, or &quot;ellipsis&quot;. Defaults to None. 
            no_wrap (Optional[bool], optional): Disable word wrapping. Defaults to None. 
            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to ``None``. 
            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to ``None``. 
            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to ``None``. 
            width (Optional[int], optional): Width of output, or ``None`` to auto-detect. Defaults to ``None``. 
            crop (Optional[bool], optional): Crop output to width of terminal. Defaults to True. 
            soft_wrap (bool, optional): Enable soft wrap mode which disables word wrapping and cropping of text or ``None`` for 
                Console default. Defaults to ``None``. 
            new_line_start (bool, False): Insert a new line at the start if the output contains more than one line. Defaults to ``False``. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">objects:</span>
            <span class="s1">objects = (NewLine()</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">soft_wrap </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">soft_wrap = self.soft_wrap</span>
        <span class="s0">if </span><span class="s1">soft_wrap:</span>
            <span class="s0">if </span><span class="s1">no_wrap </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">no_wrap = </span><span class="s0">True</span>
            <span class="s0">if </span><span class="s1">overflow </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">overflow = </span><span class="s4">&quot;ignore&quot;</span>
            <span class="s1">crop = </span><span class="s0">False</span>
        <span class="s1">render_hooks = self._render_hooks[:]</span>
        <span class="s0">with </span><span class="s1">self:</span>
            <span class="s1">renderables = self._collect_renderables(</span>
                <span class="s1">objects</span><span class="s0">,</span>
                <span class="s1">sep</span><span class="s0">,</span>
                <span class="s1">end</span><span class="s0">,</span>
                <span class="s1">justify=justify</span><span class="s0">,</span>
                <span class="s1">emoji=emoji</span><span class="s0">,</span>
                <span class="s1">markup=markup</span><span class="s0">,</span>
                <span class="s1">highlight=highlight</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">hook </span><span class="s0">in </span><span class="s1">render_hooks:</span>
                <span class="s1">renderables = hook.process_renderables(renderables)</span>
            <span class="s1">render_options = self.options.update(</span>
                <span class="s1">justify=justify</span><span class="s0">,</span>
                <span class="s1">overflow=overflow</span><span class="s0">,</span>
                <span class="s1">width=min(width</span><span class="s0">, </span><span class="s1">self.width) </span><span class="s0">if </span><span class="s1">width </span><span class="s0">is not None else </span><span class="s1">NO_CHANGE</span><span class="s0">,</span>
                <span class="s1">height=height</span><span class="s0">,</span>
                <span class="s1">no_wrap=no_wrap</span><span class="s0">,</span>
                <span class="s1">markup=markup</span><span class="s0">,</span>
                <span class="s1">highlight=highlight</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">new_segments: List[Segment] = []</span>
            <span class="s1">extend = new_segments.extend</span>
            <span class="s1">render = self.render</span>
            <span class="s0">if </span><span class="s1">style </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">renderable </span><span class="s0">in </span><span class="s1">renderables:</span>
                    <span class="s1">extend(render(renderable</span><span class="s0">, </span><span class="s1">render_options))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">renderable </span><span class="s0">in </span><span class="s1">renderables:</span>
                    <span class="s1">extend(</span>
                        <span class="s1">Segment.apply_style(</span>
                            <span class="s1">render(renderable</span><span class="s0">, </span><span class="s1">render_options)</span><span class="s0">, </span><span class="s1">self.get_style(style)</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">new_line_start:</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">len(</span><span class="s4">&quot;&quot;</span><span class="s1">.join(segment.text </span><span class="s0">for </span><span class="s1">segment </span><span class="s0">in </span><span class="s1">new_segments).splitlines())</span>
                    <span class="s1">&gt; </span><span class="s2">1</span>
                <span class="s1">):</span>
                    <span class="s1">new_segments.insert(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">Segment.line())</span>
            <span class="s0">if </span><span class="s1">crop:</span>
                <span class="s1">buffer_extend = self._buffer.extend</span>
                <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">Segment.split_and_crop_lines(</span>
                    <span class="s1">new_segments</span><span class="s0">, </span><span class="s1">self.width</span><span class="s0">, </span><span class="s1">pad=</span><span class="s0">False</span>
                <span class="s1">):</span>
                    <span class="s1">buffer_extend(line)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._buffer.extend(new_segments)</span>

    <span class="s0">def </span><span class="s1">print_json(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">json: Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">data: Any = </span><span class="s0">None,</span>
        <span class="s1">indent: Union[</span><span class="s0">None, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">str] = </span><span class="s2">2</span><span class="s0">,</span>
        <span class="s1">highlight: bool = </span><span class="s0">True,</span>
        <span class="s1">skip_keys: bool = </span><span class="s0">False,</span>
        <span class="s1">ensure_ascii: bool = </span><span class="s0">True,</span>
        <span class="s1">check_circular: bool = </span><span class="s0">True,</span>
        <span class="s1">allow_nan: bool = </span><span class="s0">True,</span>
        <span class="s1">default: Optional[Callable[[Any]</span><span class="s0">, </span><span class="s1">Any]] = </span><span class="s0">None,</span>
        <span class="s1">sort_keys: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Pretty prints JSON. Output will be valid JSON. 
 
        Args: 
            json (Optional[str]): A string containing JSON. 
            data (Any): If json is not supplied, then encode this data. 
            indent (Union[None, int, str], optional): Number of spaces to indent. Defaults to 2. 
            highlight (bool, optional): Enable highlighting of output: Defaults to True. 
            skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False. 
            ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False. 
            check_circular (bool, optional): Check for circular references. Defaults to True. 
            allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True. 
            default (Callable, optional): A callable that converts values that can not be encoded 
                in to something that can be JSON encoded. Defaults to None. 
            sort_keys (bool, optional): Sort dictionary keys. Defaults to False. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pip._vendor.rich.json </span><span class="s0">import </span><span class="s1">JSON</span>

        <span class="s0">if </span><span class="s1">json </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">json_renderable = JSON.from_data(</span>
                <span class="s1">data</span><span class="s0">,</span>
                <span class="s1">indent=indent</span><span class="s0">,</span>
                <span class="s1">highlight=highlight</span><span class="s0">,</span>
                <span class="s1">skip_keys=skip_keys</span><span class="s0">,</span>
                <span class="s1">ensure_ascii=ensure_ascii</span><span class="s0">,</span>
                <span class="s1">check_circular=check_circular</span><span class="s0">,</span>
                <span class="s1">allow_nan=allow_nan</span><span class="s0">,</span>
                <span class="s1">default=default</span><span class="s0">,</span>
                <span class="s1">sort_keys=sort_keys</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(json</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">f&quot;json must be str. Did you mean print_json(data=</span><span class="s0">{</span><span class="s1">json</span><span class="s0">!r}</span><span class="s4">) ?&quot;</span>
                <span class="s1">)</span>
            <span class="s1">json_renderable = JSON(</span>
                <span class="s1">json</span><span class="s0">,</span>
                <span class="s1">indent=indent</span><span class="s0">,</span>
                <span class="s1">highlight=highlight</span><span class="s0">,</span>
                <span class="s1">skip_keys=skip_keys</span><span class="s0">,</span>
                <span class="s1">ensure_ascii=ensure_ascii</span><span class="s0">,</span>
                <span class="s1">check_circular=check_circular</span><span class="s0">,</span>
                <span class="s1">allow_nan=allow_nan</span><span class="s0">,</span>
                <span class="s1">default=default</span><span class="s0">,</span>
                <span class="s1">sort_keys=sort_keys</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">self.print(json_renderable</span><span class="s0">, </span><span class="s1">soft_wrap=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">update_screen(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">renderable: RenderableType</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">region: Optional[Region] = </span><span class="s0">None,</span>
        <span class="s1">options: Optional[ConsoleOptions] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Update the screen at a given offset. 
 
        Args: 
            renderable (RenderableType): A Rich renderable. 
            region (Region, optional): Region of screen to update, or None for entire screen. Defaults to None. 
            x (int, optional): x offset. Defaults to 0. 
            y (int, optional): y offset. Defaults to 0. 
 
        Raises: 
            errors.NoAltScreen: If the Console isn't in alt screen mode. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.is_alt_screen:</span>
            <span class="s0">raise </span><span class="s1">errors.NoAltScreen(</span><span class="s4">&quot;Alt screen must be enabled to call update_screen&quot;</span><span class="s1">)</span>
        <span class="s1">render_options = options </span><span class="s0">or </span><span class="s1">self.options</span>
        <span class="s0">if </span><span class="s1">region </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">x = y = </span><span class="s2">0</span>
            <span class="s1">render_options = render_options.update_dimensions(</span>
                <span class="s1">render_options.max_width</span><span class="s0">, </span><span class="s1">render_options.height </span><span class="s0">or </span><span class="s1">self.height</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height = region</span>
            <span class="s1">render_options = render_options.update_dimensions(width</span><span class="s0">, </span><span class="s1">height)</span>

        <span class="s1">lines = self.render_lines(renderable</span><span class="s0">, </span><span class="s1">options=render_options)</span>
        <span class="s1">self.update_screen_lines(lines</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">update_screen_lines(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">lines: List[List[Segment]]</span><span class="s0">, </span><span class="s1">x: int = </span><span class="s2">0</span><span class="s0">, </span><span class="s1">y: int = </span><span class="s2">0</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Update lines of the screen at a given offset. 
 
        Args: 
            lines (List[List[Segment]]): Rendered lines (as produced by :meth:`~rich.Console.render_lines`). 
            x (int, optional): x offset (column no). Defaults to 0. 
            y (int, optional): y offset (column no). Defaults to 0. 
 
        Raises: 
            errors.NoAltScreen: If the Console isn't in alt screen mode. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.is_alt_screen:</span>
            <span class="s0">raise </span><span class="s1">errors.NoAltScreen(</span><span class="s4">&quot;Alt screen must be enabled to call update_screen&quot;</span><span class="s1">)</span>
        <span class="s1">screen_update = ScreenUpdate(lines</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">segments = self.render(screen_update)</span>
        <span class="s1">self._buffer.extend(segments)</span>
        <span class="s1">self._check_buffer()</span>

    <span class="s0">def </span><span class="s1">print_exception(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">width: Optional[int] = </span><span class="s2">100</span><span class="s0">,</span>
        <span class="s1">extra_lines: int = </span><span class="s2">3</span><span class="s0">,</span>
        <span class="s1">theme: Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">word_wrap: bool = </span><span class="s0">False,</span>
        <span class="s1">show_locals: bool = </span><span class="s0">False,</span>
        <span class="s1">suppress: Iterable[Union[str</span><span class="s0">, </span><span class="s1">ModuleType]] = ()</span><span class="s0">,</span>
        <span class="s1">max_frames: int = </span><span class="s2">100</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Prints a rich render of the last exception and traceback. 
 
        Args: 
            width (Optional[int], optional): Number of characters used to render code. Defaults to 100. 
            extra_lines (int, optional): Additional lines of code to render. Defaults to 3. 
            theme (str, optional): Override pygments theme used in traceback 
            word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False. 
            show_locals (bool, optional): Enable display of local variables. Defaults to False. 
            suppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback. 
            max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.traceback </span><span class="s0">import </span><span class="s1">Traceback</span>

        <span class="s1">traceback = Traceback(</span>
            <span class="s1">width=width</span><span class="s0">,</span>
            <span class="s1">extra_lines=extra_lines</span><span class="s0">,</span>
            <span class="s1">theme=theme</span><span class="s0">,</span>
            <span class="s1">word_wrap=word_wrap</span><span class="s0">,</span>
            <span class="s1">show_locals=show_locals</span><span class="s0">,</span>
            <span class="s1">suppress=suppress</span><span class="s0">,</span>
            <span class="s1">max_frames=max_frames</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">self.print(traceback)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_caller_frame_info(</span>
        <span class="s1">offset: int</span><span class="s0">,</span>
        <span class="s1">currentframe: Callable[[]</span><span class="s0">, </span><span class="s1">Optional[FrameType]] = inspect.currentframe</span><span class="s0">,</span>
    <span class="s1">) -&gt; Tuple[str</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">Dict[str</span><span class="s0">, </span><span class="s1">Any]]:</span>
        <span class="s5">&quot;&quot;&quot;Get caller frame information. 
 
        Args: 
            offset (int): the caller offset within the current frame stack. 
            currentframe (Callable[[], Optional[FrameType]], optional): the callable to use to 
                retrieve the current frame. Defaults to ``inspect.currentframe``. 
 
        Returns: 
            Tuple[str, int, Dict[str, Any]]: A tuple containing the filename, the line number and 
                the dictionary of local variables associated with the caller frame. 
 
        Raises: 
            RuntimeError: If the stack offset is invalid. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Ignore the frame of this local helper</span>
        <span class="s1">offset += </span><span class="s2">1</span>

        <span class="s1">frame = currentframe()</span>
        <span class="s0">if </span><span class="s1">frame </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s3"># Use the faster currentframe where implemented</span>
            <span class="s0">while </span><span class="s1">offset </span><span class="s0">and </span><span class="s1">frame </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">frame = frame.f_back</span>
                <span class="s1">offset -= </span><span class="s2">1</span>
            <span class="s0">assert </span><span class="s1">frame </span><span class="s0">is not None</span>
            <span class="s0">return </span><span class="s1">frame.f_code.co_filename</span><span class="s0">, </span><span class="s1">frame.f_lineno</span><span class="s0">, </span><span class="s1">frame.f_locals</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Fallback to the slower stack</span>
            <span class="s1">frame_info = inspect.stack()[offset]</span>
            <span class="s0">return </span><span class="s1">frame_info.filename</span><span class="s0">, </span><span class="s1">frame_info.lineno</span><span class="s0">, </span><span class="s1">frame_info.frame.f_locals</span>

    <span class="s0">def </span><span class="s1">log(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*objects: Any</span><span class="s0">,</span>
        <span class="s1">sep: str = </span><span class="s4">&quot; &quot;</span><span class="s0">,</span>
        <span class="s1">end: str = </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s0">,</span>
        <span class="s1">style: Optional[Union[str</span><span class="s0">, </span><span class="s1">Style]] = </span><span class="s0">None,</span>
        <span class="s1">justify: Optional[JustifyMethod] = </span><span class="s0">None,</span>
        <span class="s1">emoji: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">markup: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">highlight: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">log_locals: bool = </span><span class="s0">False,</span>
        <span class="s1">_stack_offset: int = </span><span class="s2">1</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Log rich content to the terminal. 
 
        Args: 
            objects (positional args): Objects to log to the terminal. 
            sep (str, optional): String to write between print data. Defaults to &quot; &quot;. 
            end (str, optional): String to write at end of print data. Defaults to &quot;\\\\n&quot;. 
            style (Union[str, Style], optional): A style to apply to output. Defaults to None. 
            justify (str, optional): One of &quot;left&quot;, &quot;right&quot;, &quot;center&quot;, or &quot;full&quot;. Defaults to ``None``. 
            overflow (str, optional): Overflow method: &quot;crop&quot;, &quot;fold&quot;, or &quot;ellipsis&quot;. Defaults to None. 
            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to None. 
            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to None. 
            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to None. 
            log_locals (bool, optional): Boolean to enable logging of locals where ``log()`` 
                was called. Defaults to False. 
            _stack_offset (int, optional): Offset of caller from end of call stack. Defaults to 1. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">objects:</span>
            <span class="s1">objects = (NewLine()</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s1">render_hooks = self._render_hooks[:]</span>

        <span class="s0">with </span><span class="s1">self:</span>
            <span class="s1">renderables = self._collect_renderables(</span>
                <span class="s1">objects</span><span class="s0">,</span>
                <span class="s1">sep</span><span class="s0">,</span>
                <span class="s1">end</span><span class="s0">,</span>
                <span class="s1">justify=justify</span><span class="s0">,</span>
                <span class="s1">emoji=emoji</span><span class="s0">,</span>
                <span class="s1">markup=markup</span><span class="s0">,</span>
                <span class="s1">highlight=highlight</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">style </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">renderables = [Styled(renderable</span><span class="s0">, </span><span class="s1">style) </span><span class="s0">for </span><span class="s1">renderable </span><span class="s0">in </span><span class="s1">renderables]</span>

            <span class="s1">filename</span><span class="s0">, </span><span class="s1">line_no</span><span class="s0">, </span><span class="s1">locals = self._caller_frame_info(_stack_offset)</span>
            <span class="s1">link_path = </span><span class="s0">None if </span><span class="s1">filename.startswith(</span><span class="s4">&quot;&lt;&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">os.path.abspath(filename)</span>
            <span class="s1">path = filename.rpartition(os.sep)[-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">log_locals:</span>
                <span class="s1">locals_map = {</span>
                    <span class="s1">key: value</span>
                    <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">locals.items()</span>
                    <span class="s0">if not </span><span class="s1">key.startswith(</span><span class="s4">&quot;__&quot;</span><span class="s1">)</span>
                <span class="s1">}</span>
                <span class="s1">renderables.append(render_scope(locals_map</span><span class="s0">, </span><span class="s1">title=</span><span class="s4">&quot;[i]locals&quot;</span><span class="s1">))</span>

            <span class="s1">renderables = [</span>
                <span class="s1">self._log_render(</span>
                    <span class="s1">self</span><span class="s0">,</span>
                    <span class="s1">renderables</span><span class="s0">,</span>
                    <span class="s1">log_time=self.get_datetime()</span><span class="s0">,</span>
                    <span class="s1">path=path</span><span class="s0">,</span>
                    <span class="s1">line_no=line_no</span><span class="s0">,</span>
                    <span class="s1">link_path=link_path</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s0">for </span><span class="s1">hook </span><span class="s0">in </span><span class="s1">render_hooks:</span>
                <span class="s1">renderables = hook.process_renderables(renderables)</span>
            <span class="s1">new_segments: List[Segment] = []</span>
            <span class="s1">extend = new_segments.extend</span>
            <span class="s1">render = self.render</span>
            <span class="s1">render_options = self.options</span>
            <span class="s0">for </span><span class="s1">renderable </span><span class="s0">in </span><span class="s1">renderables:</span>
                <span class="s1">extend(render(renderable</span><span class="s0">, </span><span class="s1">render_options))</span>
            <span class="s1">buffer_extend = self._buffer.extend</span>
            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">Segment.split_and_crop_lines(</span>
                <span class="s1">new_segments</span><span class="s0">, </span><span class="s1">self.width</span><span class="s0">, </span><span class="s1">pad=</span><span class="s0">False</span>
            <span class="s1">):</span>
                <span class="s1">buffer_extend(line)</span>

    <span class="s0">def </span><span class="s1">_check_buffer(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Check if the buffer may be rendered. Render it if it can (e.g. Console.quiet is False) 
        Rendering is supported on Windows, Unix and Jupyter environments. For 
        legacy Windows consoles, the win32 API is called directly. 
        This method will also record what it renders if recording is enabled via Console.record. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.quiet:</span>
            <span class="s0">del </span><span class="s1">self._buffer[:]</span>
            <span class="s0">return</span>
        <span class="s0">with </span><span class="s1">self._lock:</span>
            <span class="s0">if </span><span class="s1">self.record:</span>
                <span class="s0">with </span><span class="s1">self._record_buffer_lock:</span>
                    <span class="s1">self._record_buffer.extend(self._buffer[:])</span>

            <span class="s0">if </span><span class="s1">self._buffer_index == </span><span class="s2">0</span><span class="s1">:</span>

                <span class="s0">if </span><span class="s1">self.is_jupyter:  </span><span class="s3"># pragma: no cover</span>
                    <span class="s0">from </span><span class="s1">.jupyter </span><span class="s0">import </span><span class="s1">display</span>

                    <span class="s1">display(self._buffer</span><span class="s0">, </span><span class="s1">self._render_buffer(self._buffer[:]))</span>
                    <span class="s0">del </span><span class="s1">self._buffer[:]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">WINDOWS:</span>
                        <span class="s1">use_legacy_windows_render = </span><span class="s0">False</span>
                        <span class="s0">if </span><span class="s1">self.legacy_windows:</span>
                            <span class="s0">try</span><span class="s1">:</span>
                                <span class="s1">use_legacy_windows_render = (</span>
                                    <span class="s1">self.file.fileno() </span><span class="s0">in </span><span class="s1">_STD_STREAMS_OUTPUT</span>
                                <span class="s1">)</span>
                            <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">io.UnsupportedOperation):</span>
                                <span class="s0">pass</span>

                        <span class="s0">if </span><span class="s1">use_legacy_windows_render:</span>
                            <span class="s0">from </span><span class="s1">pip._vendor.rich._win32_console </span><span class="s0">import </span><span class="s1">LegacyWindowsTerm</span>
                            <span class="s0">from </span><span class="s1">pip._vendor.rich._windows_renderer </span><span class="s0">import </span><span class="s1">legacy_windows_render</span>

                            <span class="s1">legacy_windows_render(</span>
                                <span class="s1">self._buffer[:]</span><span class="s0">, </span><span class="s1">LegacyWindowsTerm(self.file)</span>
                            <span class="s1">)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s3"># Either a non-std stream on legacy Windows, or modern Windows.</span>
                            <span class="s1">text = self._render_buffer(self._buffer[:])</span>
                            <span class="s3"># https://bugs.python.org/issue37871</span>
                            <span class="s1">write = self.file.write</span>
                            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">text.splitlines(</span><span class="s0">True</span><span class="s1">):</span>
                                <span class="s0">try</span><span class="s1">:</span>
                                    <span class="s1">write(line)</span>
                                <span class="s0">except </span><span class="s1">UnicodeEncodeError </span><span class="s0">as </span><span class="s1">error:</span>
                                    <span class="s1">error.reason = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">error.reason</span><span class="s0">}\n</span><span class="s4">*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***&quot;</span>
                                    <span class="s0">raise</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">text = self._render_buffer(self._buffer[:])</span>
                        <span class="s0">try</span><span class="s1">:</span>
                            <span class="s1">self.file.write(text)</span>
                        <span class="s0">except </span><span class="s1">UnicodeEncodeError </span><span class="s0">as </span><span class="s1">error:</span>
                            <span class="s1">error.reason = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">error.reason</span><span class="s0">}\n</span><span class="s4">*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***&quot;</span>
                            <span class="s0">raise</span>

                    <span class="s1">self.file.flush()</span>
                    <span class="s0">del </span><span class="s1">self._buffer[:]</span>

    <span class="s0">def </span><span class="s1">_render_buffer(self</span><span class="s0">, </span><span class="s1">buffer: Iterable[Segment]) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot;Render buffered output, and clear buffer.&quot;&quot;&quot;</span>
        <span class="s1">output: List[str] = []</span>
        <span class="s1">append = output.append</span>
        <span class="s1">color_system = self._color_system</span>
        <span class="s1">legacy_windows = self.legacy_windows</span>
        <span class="s1">not_terminal = </span><span class="s0">not </span><span class="s1">self.is_terminal</span>
        <span class="s0">if </span><span class="s1">self.no_color </span><span class="s0">and </span><span class="s1">color_system:</span>
            <span class="s1">buffer = Segment.remove_color(buffer)</span>
        <span class="s0">for </span><span class="s1">text</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">control </span><span class="s0">in </span><span class="s1">buffer:</span>
            <span class="s0">if </span><span class="s1">style:</span>
                <span class="s1">append(</span>
                    <span class="s1">style.render(</span>
                        <span class="s1">text</span><span class="s0">,</span>
                        <span class="s1">color_system=color_system</span><span class="s0">,</span>
                        <span class="s1">legacy_windows=legacy_windows</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s0">elif not </span><span class="s1">(not_terminal </span><span class="s0">and </span><span class="s1">control):</span>
                <span class="s1">append(text)</span>

        <span class="s1">rendered = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(output)</span>
        <span class="s0">return </span><span class="s1">rendered</span>

    <span class="s0">def </span><span class="s1">input(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">prompt: TextType = </span><span class="s4">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">markup: bool = </span><span class="s0">True,</span>
        <span class="s1">emoji: bool = </span><span class="s0">True,</span>
        <span class="s1">password: bool = </span><span class="s0">False,</span>
        <span class="s1">stream: Optional[TextIO] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot;Displays a prompt and waits for input from the user. The prompt may contain color / style. 
 
        It works in the same way as Python's builtin :func:`input` function and provides elaborate line editing and history features if Python's builtin :mod:`readline` module is previously loaded. 
 
        Args: 
            prompt (Union[str, Text]): Text to render in the prompt. 
            markup (bool, optional): Enable console markup (requires a str prompt). Defaults to True. 
            emoji (bool, optional): Enable emoji (requires a str prompt). Defaults to True. 
            password: (bool, optional): Hide typed text. Defaults to False. 
            stream: (TextIO, optional): Optional file to read input from (rather than stdin). Defaults to None. 
 
        Returns: 
            str: Text read from stdin. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">prompt:</span>
            <span class="s1">self.print(prompt</span><span class="s0">, </span><span class="s1">markup=markup</span><span class="s0">, </span><span class="s1">emoji=emoji</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">password:</span>
            <span class="s1">result = getpass(</span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s1">stream=stream)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">stream:</span>
                <span class="s1">result = stream.readline()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result = input()</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">export_text(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">clear: bool = </span><span class="s0">True, </span><span class="s1">styles: bool = </span><span class="s0">False</span><span class="s1">) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot;Generate text from console contents (requires record=True argument in constructor). 
 
        Args: 
            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``. 
            styles (bool, optional): If ``True``, ansi escape codes will be included. ``False`` for plain text. 
                Defaults to ``False``. 
 
        Returns: 
            str: String containing console contents. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">self.record</span>
        <span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;To export console contents set record=True in the constructor or instance&quot;</span>

        <span class="s0">with </span><span class="s1">self._record_buffer_lock:</span>
            <span class="s0">if </span><span class="s1">styles:</span>
                <span class="s1">text = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(</span>
                    <span class="s1">(style.render(text) </span><span class="s0">if </span><span class="s1">style </span><span class="s0">else </span><span class="s1">text)</span>
                    <span class="s0">for </span><span class="s1">text</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self._record_buffer</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">text = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(</span>
                    <span class="s1">segment.text</span>
                    <span class="s0">for </span><span class="s1">segment </span><span class="s0">in </span><span class="s1">self._record_buffer</span>
                    <span class="s0">if not </span><span class="s1">segment.control</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">clear:</span>
                <span class="s0">del </span><span class="s1">self._record_buffer[:]</span>
        <span class="s0">return </span><span class="s1">text</span>

    <span class="s0">def </span><span class="s1">save_text(self</span><span class="s0">, </span><span class="s1">path: str</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">clear: bool = </span><span class="s0">True, </span><span class="s1">styles: bool = </span><span class="s0">False</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Generate text from console and save to a given location (requires record=True argument in constructor). 
 
        Args: 
            path (str): Path to write text files. 
            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``. 
            styles (bool, optional): If ``True``, ansi style codes will be included. ``False`` for plain text. 
                Defaults to ``False``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">text = self.export_text(clear=clear</span><span class="s0">, </span><span class="s1">styles=styles)</span>
        <span class="s0">with </span><span class="s1">open(path</span><span class="s0">, </span><span class="s4">&quot;wt&quot;</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">write_file:</span>
            <span class="s1">write_file.write(text)</span>

    <span class="s0">def </span><span class="s1">export_html(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">theme: Optional[TerminalTheme] = </span><span class="s0">None,</span>
        <span class="s1">clear: bool = </span><span class="s0">True,</span>
        <span class="s1">code_format: Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">inline_styles: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot;Generate HTML from console contents (requires record=True argument in constructor). 
 
        Args: 
            theme (TerminalTheme, optional): TerminalTheme object containing console colors. 
            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``. 
            code_format (str, optional): Format string to render HTML. In addition to '{foreground}', 
                '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``. 
            inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files 
                larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag. 
                Defaults to False. 
 
        Returns: 
            str: String containing console contents as HTML. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">self.record</span>
        <span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;To export console contents set record=True in the constructor or instance&quot;</span>
        <span class="s1">fragments: List[str] = []</span>
        <span class="s1">append = fragments.append</span>
        <span class="s1">_theme = theme </span><span class="s0">or </span><span class="s1">DEFAULT_TERMINAL_THEME</span>
        <span class="s1">stylesheet = </span><span class="s4">&quot;&quot;</span>

        <span class="s1">render_code_format = CONSOLE_HTML_FORMAT </span><span class="s0">if </span><span class="s1">code_format </span><span class="s0">is None else </span><span class="s1">code_format</span>

        <span class="s0">with </span><span class="s1">self._record_buffer_lock:</span>
            <span class="s0">if </span><span class="s1">inline_styles:</span>
                <span class="s0">for </span><span class="s1">text</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">Segment.filter_control(</span>
                    <span class="s1">Segment.simplify(self._record_buffer)</span>
                <span class="s1">):</span>
                    <span class="s1">text = escape(text)</span>
                    <span class="s0">if </span><span class="s1">style:</span>
                        <span class="s1">rule = style.get_html_style(_theme)</span>
                        <span class="s0">if </span><span class="s1">style.link:</span>
                            <span class="s1">text = </span><span class="s4">f'&lt;a href=&quot;</span><span class="s0">{</span><span class="s1">style.link</span><span class="s0">}</span><span class="s4">&quot;&gt;</span><span class="s0">{</span><span class="s1">text</span><span class="s0">}</span><span class="s4">&lt;/a&gt;'</span>
                        <span class="s1">text = </span><span class="s4">f'&lt;span style=&quot;</span><span class="s0">{</span><span class="s1">rule</span><span class="s0">}</span><span class="s4">&quot;&gt;</span><span class="s0">{</span><span class="s1">text</span><span class="s0">}</span><span class="s4">&lt;/span&gt;' </span><span class="s0">if </span><span class="s1">rule </span><span class="s0">else </span><span class="s1">text</span>
                    <span class="s1">append(text)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">styles: Dict[str</span><span class="s0">, </span><span class="s1">int] = {}</span>
                <span class="s0">for </span><span class="s1">text</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">Segment.filter_control(</span>
                    <span class="s1">Segment.simplify(self._record_buffer)</span>
                <span class="s1">):</span>
                    <span class="s1">text = escape(text)</span>
                    <span class="s0">if </span><span class="s1">style:</span>
                        <span class="s1">rule = style.get_html_style(_theme)</span>
                        <span class="s1">style_number = styles.setdefault(rule</span><span class="s0">, </span><span class="s1">len(styles) + </span><span class="s2">1</span><span class="s1">)</span>
                        <span class="s0">if </span><span class="s1">style.link:</span>
                            <span class="s1">text = </span><span class="s4">f'&lt;a class=&quot;r</span><span class="s0">{</span><span class="s1">style_number</span><span class="s0">}</span><span class="s4">&quot; href=&quot;</span><span class="s0">{</span><span class="s1">style.link</span><span class="s0">}</span><span class="s4">&quot;&gt;</span><span class="s0">{</span><span class="s1">text</span><span class="s0">}</span><span class="s4">&lt;/a&gt;'</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">text = </span><span class="s4">f'&lt;span class=&quot;r</span><span class="s0">{</span><span class="s1">style_number</span><span class="s0">}</span><span class="s4">&quot;&gt;</span><span class="s0">{</span><span class="s1">text</span><span class="s0">}</span><span class="s4">&lt;/span&gt;'</span>
                    <span class="s1">append(text)</span>
                <span class="s1">stylesheet_rules: List[str] = []</span>
                <span class="s1">stylesheet_append = stylesheet_rules.append</span>
                <span class="s0">for </span><span class="s1">style_rule</span><span class="s0">, </span><span class="s1">style_number </span><span class="s0">in </span><span class="s1">styles.items():</span>
                    <span class="s0">if </span><span class="s1">style_rule:</span>
                        <span class="s1">stylesheet_append(</span><span class="s4">f&quot;.r</span><span class="s0">{</span><span class="s1">style_number</span><span class="s0">} {{{</span><span class="s1">style_rule</span><span class="s0">}}}</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s1">stylesheet = </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">.join(stylesheet_rules)</span>

            <span class="s1">rendered_code = render_code_format.format(</span>
                <span class="s1">code=</span><span class="s4">&quot;&quot;</span><span class="s1">.join(fragments)</span><span class="s0">,</span>
                <span class="s1">stylesheet=stylesheet</span><span class="s0">,</span>
                <span class="s1">foreground=_theme.foreground_color.hex</span><span class="s0">,</span>
                <span class="s1">background=_theme.background_color.hex</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">clear:</span>
                <span class="s0">del </span><span class="s1">self._record_buffer[:]</span>
        <span class="s0">return </span><span class="s1">rendered_code</span>

    <span class="s0">def </span><span class="s1">save_html(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">path: str</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">theme: Optional[TerminalTheme] = </span><span class="s0">None,</span>
        <span class="s1">clear: bool = </span><span class="s0">True,</span>
        <span class="s1">code_format: str = CONSOLE_HTML_FORMAT</span><span class="s0">,</span>
        <span class="s1">inline_styles: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Generate HTML from console contents and write to a file (requires record=True argument in constructor). 
 
        Args: 
            path (str): Path to write html file. 
            theme (TerminalTheme, optional): TerminalTheme object containing console colors. 
            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``. 
            code_format (str, optional): Format string to render HTML. In addition to '{foreground}', 
                '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``. 
            inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files 
                larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag. 
                Defaults to False. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">html = self.export_html(</span>
            <span class="s1">theme=theme</span><span class="s0">,</span>
            <span class="s1">clear=clear</span><span class="s0">,</span>
            <span class="s1">code_format=code_format</span><span class="s0">,</span>
            <span class="s1">inline_styles=inline_styles</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">open(path</span><span class="s0">, </span><span class="s4">&quot;wt&quot;</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">write_file:</span>
            <span class="s1">write_file.write(html)</span>

    <span class="s0">def </span><span class="s1">export_svg(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">title: str = </span><span class="s4">&quot;Rich&quot;</span><span class="s0">,</span>
        <span class="s1">theme: Optional[TerminalTheme] = </span><span class="s0">None,</span>
        <span class="s1">clear: bool = </span><span class="s0">True,</span>
        <span class="s1">code_format: str = CONSOLE_SVG_FORMAT</span><span class="s0">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot; 
        Generate an SVG from the console contents (requires record=True in Console constructor). 
 
        Args: 
            path (str): The path to write the SVG to. 
            title (str): The title of the tab in the output image 
            theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal 
            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True`` 
            code_format (str): Format string used to generate the SVG. Rich will inject a number of variables 
                into the string in order to form the final SVG output. The default template used and the variables 
                injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable. 
        &quot;&quot;&quot;</span>

        <span class="s0">from </span><span class="s1">pip._vendor.rich.cells </span><span class="s0">import </span><span class="s1">cell_len</span>

        <span class="s1">style_cache: Dict[Style</span><span class="s0">, </span><span class="s1">str] = {}</span>

        <span class="s0">def </span><span class="s1">get_svg_style(style: Style) -&gt; str:</span>
            <span class="s5">&quot;&quot;&quot;Convert a Style to CSS rules for SVG.&quot;&quot;&quot;</span>
            <span class="s0">if </span><span class="s1">style </span><span class="s0">in </span><span class="s1">style_cache:</span>
                <span class="s0">return </span><span class="s1">style_cache[style]</span>
            <span class="s1">css_rules = []</span>
            <span class="s1">color = (</span>
                <span class="s1">_theme.foreground_color</span>
                <span class="s0">if </span><span class="s1">(style.color </span><span class="s0">is None or </span><span class="s1">style.color.is_default)</span>
                <span class="s0">else </span><span class="s1">style.color.get_truecolor(_theme)</span>
            <span class="s1">)</span>
            <span class="s1">bgcolor = (</span>
                <span class="s1">_theme.background_color</span>
                <span class="s0">if </span><span class="s1">(style.bgcolor </span><span class="s0">is None or </span><span class="s1">style.bgcolor.is_default)</span>
                <span class="s0">else </span><span class="s1">style.bgcolor.get_truecolor(_theme)</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">style.reverse:</span>
                <span class="s1">color</span><span class="s0">, </span><span class="s1">bgcolor = bgcolor</span><span class="s0">, </span><span class="s1">color</span>
            <span class="s0">if </span><span class="s1">style.dim:</span>
                <span class="s1">color = blend_rgb(color</span><span class="s0">, </span><span class="s1">bgcolor</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">)</span>
            <span class="s1">css_rules.append(</span><span class="s4">f&quot;fill: </span><span class="s0">{</span><span class="s1">color.hex</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">style.bold:</span>
                <span class="s1">css_rules.append(</span><span class="s4">&quot;font-weight: bold&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">style.italic:</span>
                <span class="s1">css_rules.append(</span><span class="s4">&quot;font-style: italic;&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">style.underline:</span>
                <span class="s1">css_rules.append(</span><span class="s4">&quot;text-decoration: underline;&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">style.strike:</span>
                <span class="s1">css_rules.append(</span><span class="s4">&quot;text-decoration: line-through;&quot;</span><span class="s1">)</span>

            <span class="s1">css = </span><span class="s4">&quot;;&quot;</span><span class="s1">.join(css_rules)</span>
            <span class="s1">style_cache[style] = css</span>
            <span class="s0">return </span><span class="s1">css</span>

        <span class="s1">_theme = theme </span><span class="s0">or </span><span class="s1">SVG_EXPORT_THEME</span>

        <span class="s1">width = self.width</span>
        <span class="s1">char_height = </span><span class="s2">20</span>
        <span class="s1">char_width = char_height * </span><span class="s2">0.61</span>
        <span class="s1">line_height = char_height * </span><span class="s2">1.22</span>

        <span class="s1">margin_top = </span><span class="s2">1</span>
        <span class="s1">margin_right = </span><span class="s2">1</span>
        <span class="s1">margin_bottom = </span><span class="s2">1</span>
        <span class="s1">margin_left = </span><span class="s2">1</span>

        <span class="s1">padding_top = </span><span class="s2">40</span>
        <span class="s1">padding_right = </span><span class="s2">8</span>
        <span class="s1">padding_bottom = </span><span class="s2">8</span>
        <span class="s1">padding_left = </span><span class="s2">8</span>

        <span class="s1">padding_width = padding_left + padding_right</span>
        <span class="s1">padding_height = padding_top + padding_bottom</span>
        <span class="s1">margin_width = margin_left + margin_right</span>
        <span class="s1">margin_height = margin_top + margin_bottom</span>

        <span class="s1">text_backgrounds: List[str] = []</span>
        <span class="s1">text_group: List[str] = []</span>
        <span class="s1">classes: Dict[str</span><span class="s0">, </span><span class="s1">int] = {}</span>
        <span class="s1">style_no = </span><span class="s2">1</span>

        <span class="s0">def </span><span class="s1">escape_text(text: str) -&gt; str:</span>
            <span class="s5">&quot;&quot;&quot;HTML escape text and replace spaces with nbsp.&quot;&quot;&quot;</span>
            <span class="s0">return </span><span class="s1">escape(text).replace(</span><span class="s4">&quot; &quot;</span><span class="s0">, </span><span class="s4">&quot;&amp;#160;&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">make_tag(</span>
            <span class="s1">name: str</span><span class="s0">, </span><span class="s1">content: Optional[str] = </span><span class="s0">None, </span><span class="s1">**attribs: object</span>
        <span class="s1">) -&gt; str:</span>
            <span class="s5">&quot;&quot;&quot;Make a tag from name, content, and attributes.&quot;&quot;&quot;</span>

            <span class="s0">def </span><span class="s1">stringify(value: object) -&gt; str:</span>
                <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(float)):</span>
                    <span class="s0">return </span><span class="s1">format(value</span><span class="s0">, </span><span class="s4">&quot;g&quot;</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">str(value)</span>

            <span class="s1">tag_attribs = </span><span class="s4">&quot; &quot;</span><span class="s1">.join(</span>
                <span class="s4">f'</span><span class="s0">{</span><span class="s1">k.lstrip(</span><span class="s4">&quot;_&quot;</span><span class="s1">).replace(</span><span class="s4">&quot;_&quot;</span><span class="s0">, </span><span class="s4">&quot;-&quot;</span><span class="s1">)</span><span class="s0">}</span><span class="s4">=&quot;</span><span class="s0">{</span><span class="s1">stringify(v)</span><span class="s0">}</span><span class="s4">&quot;'</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">attribs.items()</span>
            <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">(</span>
                <span class="s4">f&quot;&lt;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">} {</span><span class="s1">tag_attribs</span><span class="s0">}</span><span class="s4">&gt;</span><span class="s0">{</span><span class="s1">content</span><span class="s0">}</span><span class="s4">&lt;/</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">&gt;&quot;</span>
                <span class="s0">if </span><span class="s1">content</span>
                <span class="s0">else </span><span class="s4">f&quot;&lt;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">} {</span><span class="s1">tag_attribs</span><span class="s0">}</span><span class="s4">/&gt;&quot;</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self._record_buffer_lock:</span>
            <span class="s1">segments = list(Segment.filter_control(self._record_buffer))</span>
            <span class="s0">if </span><span class="s1">clear:</span>
                <span class="s1">self._record_buffer.clear()</span>

        <span class="s1">unique_id = </span><span class="s4">&quot;terminal-&quot; </span><span class="s1">+ str(</span>
            <span class="s1">zlib.adler32(</span>
                <span class="s1">(</span><span class="s4">&quot;&quot;</span><span class="s1">.join(segment.text </span><span class="s0">for </span><span class="s1">segment </span><span class="s0">in </span><span class="s1">segments)).encode(</span>
                    <span class="s4">&quot;utf-8&quot;</span><span class="s0">, </span><span class="s4">&quot;ignore&quot;</span>
                <span class="s1">)</span>
                <span class="s1">+ title.encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s0">, </span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">y = </span><span class="s2">0</span>
        <span class="s0">for </span><span class="s1">y</span><span class="s0">, </span><span class="s1">line </span><span class="s0">in </span><span class="s1">enumerate(Segment.split_and_crop_lines(segments</span><span class="s0">, </span><span class="s1">length=width)):</span>
            <span class="s1">x = </span><span class="s2">0</span>
            <span class="s0">for </span><span class="s1">text</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">_control </span><span class="s0">in </span><span class="s1">line:</span>
                <span class="s1">style = style </span><span class="s0">or </span><span class="s1">Style()</span>
                <span class="s1">rules = get_svg_style(style)</span>
                <span class="s0">if </span><span class="s1">rules </span><span class="s0">not in </span><span class="s1">classes:</span>
                    <span class="s1">classes[rules] = style_no</span>
                    <span class="s1">style_no += </span><span class="s2">1</span>
                <span class="s1">class_name = </span><span class="s4">f&quot;r</span><span class="s0">{</span><span class="s1">classes[rules]</span><span class="s0">}</span><span class="s4">&quot;</span>

                <span class="s0">if </span><span class="s1">style.reverse:</span>
                    <span class="s1">has_background = </span><span class="s0">True</span>
                    <span class="s1">background = (</span>
                        <span class="s1">_theme.foreground_color.hex</span>
                        <span class="s0">if </span><span class="s1">style.color </span><span class="s0">is None</span>
                        <span class="s0">else </span><span class="s1">style.color.get_truecolor(_theme).hex</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">bgcolor = style.bgcolor</span>
                    <span class="s1">has_background = bgcolor </span><span class="s0">is not None and not </span><span class="s1">bgcolor.is_default</span>
                    <span class="s1">background = (</span>
                        <span class="s1">_theme.background_color.hex</span>
                        <span class="s0">if </span><span class="s1">style.bgcolor </span><span class="s0">is None</span>
                        <span class="s0">else </span><span class="s1">style.bgcolor.get_truecolor(_theme).hex</span>
                    <span class="s1">)</span>

                <span class="s1">text_length = cell_len(text)</span>
                <span class="s0">if </span><span class="s1">has_background:</span>
                    <span class="s1">text_backgrounds.append(</span>
                        <span class="s1">make_tag(</span>
                            <span class="s4">&quot;rect&quot;</span><span class="s0">,</span>
                            <span class="s1">fill=background</span><span class="s0">,</span>
                            <span class="s1">x=x * char_width</span><span class="s0">,</span>
                            <span class="s1">y=y * line_height + </span><span class="s2">1.5</span><span class="s0">,</span>
                            <span class="s1">width=char_width * text_length</span><span class="s0">,</span>
                            <span class="s1">height=line_height + </span><span class="s2">0.25</span><span class="s0">,</span>
                            <span class="s1">shape_rendering=</span><span class="s4">&quot;crispEdges&quot;</span><span class="s0">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                <span class="s0">if </span><span class="s1">text != </span><span class="s4">&quot; &quot; </span><span class="s1">* len(text):</span>
                    <span class="s1">text_group.append(</span>
                        <span class="s1">make_tag(</span>
                            <span class="s4">&quot;text&quot;</span><span class="s0">,</span>
                            <span class="s1">escape_text(text)</span><span class="s0">,</span>
                            <span class="s1">_class=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">unique_id</span><span class="s0">}</span><span class="s4">-</span><span class="s0">{</span><span class="s1">class_name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s0">,</span>
                            <span class="s1">x=x * char_width</span><span class="s0">,</span>
                            <span class="s1">y=y * line_height + char_height</span><span class="s0">,</span>
                            <span class="s1">textLength=char_width * len(text)</span><span class="s0">,</span>
                            <span class="s1">clip_path=</span><span class="s4">f&quot;url(#</span><span class="s0">{</span><span class="s1">unique_id</span><span class="s0">}</span><span class="s4">-line-</span><span class="s0">{</span><span class="s1">y</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s0">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">x += cell_len(text)</span>

        <span class="s1">line_offsets = [line_no * line_height + </span><span class="s2">1.5 </span><span class="s0">for </span><span class="s1">line_no </span><span class="s0">in </span><span class="s1">range(y)]</span>
        <span class="s1">lines = </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">.join(</span>
            <span class="s4">f&quot;&quot;&quot;&lt;clipPath id=&quot;</span><span class="s0">{</span><span class="s1">unique_id</span><span class="s0">}</span><span class="s4">-line-</span><span class="s0">{</span><span class="s1">line_no</span><span class="s0">}</span><span class="s4">&quot;&gt;</span>
    <span class="s0">{</span><span class="s1">make_tag(</span><span class="s4">&quot;rect&quot;</span><span class="s0">, </span><span class="s1">x=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">y=offset</span><span class="s0">, </span><span class="s1">width=char_width * width</span><span class="s0">, </span><span class="s1">height=line_height + </span><span class="s2">0.25</span><span class="s1">)</span><span class="s0">}</span>
            <span class="s4">&lt;/clipPath&gt;&quot;&quot;&quot;</span>
            <span class="s0">for </span><span class="s1">line_no</span><span class="s0">, </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">enumerate(line_offsets)</span>
        <span class="s1">)</span>

        <span class="s1">styles = </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">.join(</span>
            <span class="s4">f&quot;.</span><span class="s0">{</span><span class="s1">unique_id</span><span class="s0">}</span><span class="s4">-r</span><span class="s0">{</span><span class="s1">rule_no</span><span class="s0">} {{ {</span><span class="s1">css</span><span class="s0">} }}</span><span class="s4">&quot; </span><span class="s0">for </span><span class="s1">css</span><span class="s0">, </span><span class="s1">rule_no </span><span class="s0">in </span><span class="s1">classes.items()</span>
        <span class="s1">)</span>
        <span class="s1">backgrounds = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(text_backgrounds)</span>
        <span class="s1">matrix = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(text_group)</span>

        <span class="s1">terminal_width = ceil(width * char_width + padding_width)</span>
        <span class="s1">terminal_height = (y + </span><span class="s2">1</span><span class="s1">) * line_height + padding_height</span>
        <span class="s1">chrome = make_tag(</span>
            <span class="s4">&quot;rect&quot;</span><span class="s0">,</span>
            <span class="s1">fill=_theme.background_color.hex</span><span class="s0">,</span>
            <span class="s1">stroke=</span><span class="s4">&quot;rgba(255,255,255,0.35)&quot;</span><span class="s0">,</span>
            <span class="s1">stroke_width=</span><span class="s4">&quot;1&quot;</span><span class="s0">,</span>
            <span class="s1">x=margin_left</span><span class="s0">,</span>
            <span class="s1">y=margin_top</span><span class="s0">,</span>
            <span class="s1">width=terminal_width</span><span class="s0">,</span>
            <span class="s1">height=terminal_height</span><span class="s0">,</span>
            <span class="s1">rx=</span><span class="s2">8</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">title_color = _theme.foreground_color.hex</span>
        <span class="s0">if </span><span class="s1">title:</span>
            <span class="s1">chrome += make_tag(</span>
                <span class="s4">&quot;text&quot;</span><span class="s0">,</span>
                <span class="s1">escape_text(title)</span><span class="s0">,</span>
                <span class="s1">_class=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">unique_id</span><span class="s0">}</span><span class="s4">-title&quot;</span><span class="s0">,</span>
                <span class="s1">fill=title_color</span><span class="s0">,</span>
                <span class="s1">text_anchor=</span><span class="s4">&quot;middle&quot;</span><span class="s0">,</span>
                <span class="s1">x=terminal_width // </span><span class="s2">2</span><span class="s0">,</span>
                <span class="s1">y=margin_top + char_height + </span><span class="s2">6</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">chrome += </span><span class="s4">f&quot;&quot;&quot;</span>
            <span class="s4">&lt;g transform=&quot;translate(26,22)&quot;&gt;</span>
            <span class="s4">&lt;circle cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;7&quot; fill=&quot;#ff5f57&quot;/&gt;</span>
            <span class="s4">&lt;circle cx=&quot;22&quot; cy=&quot;0&quot; r=&quot;7&quot; fill=&quot;#febc2e&quot;/&gt;</span>
            <span class="s4">&lt;circle cx=&quot;44&quot; cy=&quot;0&quot; r=&quot;7&quot; fill=&quot;#28c840&quot;/&gt;</span>
            <span class="s4">&lt;/g&gt;</span>
        <span class="s4">&quot;&quot;&quot;</span>

        <span class="s1">svg = code_format.format(</span>
            <span class="s1">unique_id=unique_id</span><span class="s0">,</span>
            <span class="s1">char_width=char_width</span><span class="s0">,</span>
            <span class="s1">char_height=char_height</span><span class="s0">,</span>
            <span class="s1">line_height=line_height</span><span class="s0">,</span>
            <span class="s1">terminal_width=char_width * width - </span><span class="s2">1</span><span class="s0">,</span>
            <span class="s1">terminal_height=(y + </span><span class="s2">1</span><span class="s1">) * line_height - </span><span class="s2">1</span><span class="s0">,</span>
            <span class="s1">width=terminal_width + margin_width</span><span class="s0">,</span>
            <span class="s1">height=terminal_height + margin_height</span><span class="s0">,</span>
            <span class="s1">terminal_x=margin_left + padding_left</span><span class="s0">,</span>
            <span class="s1">terminal_y=margin_top + padding_top</span><span class="s0">,</span>
            <span class="s1">styles=styles</span><span class="s0">,</span>
            <span class="s1">chrome=chrome</span><span class="s0">,</span>
            <span class="s1">backgrounds=backgrounds</span><span class="s0">,</span>
            <span class="s1">matrix=matrix</span><span class="s0">,</span>
            <span class="s1">lines=lines</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">svg</span>

    <span class="s0">def </span><span class="s1">save_svg(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">path: str</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">title: str = </span><span class="s4">&quot;Rich&quot;</span><span class="s0">,</span>
        <span class="s1">theme: Optional[TerminalTheme] = </span><span class="s0">None,</span>
        <span class="s1">clear: bool = </span><span class="s0">True,</span>
        <span class="s1">code_format: str = CONSOLE_SVG_FORMAT</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Generate an SVG file from the console contents (requires record=True in Console constructor). 
 
        Args: 
            path (str): The path to write the SVG to. 
            title (str): The title of the tab in the output image 
            theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal 
            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True`` 
            code_format (str): Format string used to generate the SVG. Rich will inject a number of variables 
                into the string in order to form the final SVG output. The default template used and the variables 
                injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable. 
        &quot;&quot;&quot;</span>
        <span class="s1">svg = self.export_svg(</span>
            <span class="s1">title=title</span><span class="s0">,</span>
            <span class="s1">theme=theme</span><span class="s0">,</span>
            <span class="s1">clear=clear</span><span class="s0">,</span>
            <span class="s1">code_format=code_format</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">open(path</span><span class="s0">, </span><span class="s4">&quot;wt&quot;</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">write_file:</span>
            <span class="s1">write_file.write(svg)</span>


<span class="s0">def </span><span class="s1">_svg_hash(svg_main_code: str) -&gt; str:</span>
    <span class="s5">&quot;&quot;&quot;Returns a unique hash for the given SVG main code. 
 
    Args: 
        svg_main_code (str): The content we're going to inject in the SVG envelope. 
 
    Returns: 
        str: a hash of the given content 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">str(zlib.adler32(svg_main_code.encode()))</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s4">&quot;__main__&quot;</span><span class="s1">:  </span><span class="s3"># pragma: no cover</span>
    <span class="s1">console = Console(record=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">console.log(</span>
        <span class="s4">&quot;JSONRPC [i]request[/i]&quot;</span><span class="s0">,</span>
        <span class="s2">5</span><span class="s0">,</span>
        <span class="s2">1.3</span><span class="s0">,</span>
        <span class="s0">True,</span>
        <span class="s0">False,</span>
        <span class="s0">None,</span>
        <span class="s1">{</span>
            <span class="s4">&quot;jsonrpc&quot;</span><span class="s1">: </span><span class="s4">&quot;2.0&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;method&quot;</span><span class="s1">: </span><span class="s4">&quot;subtract&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;params&quot;</span><span class="s1">: {</span><span class="s4">&quot;minuend&quot;</span><span class="s1">: </span><span class="s2">42</span><span class="s0">, </span><span class="s4">&quot;subtrahend&quot;</span><span class="s1">: </span><span class="s2">23</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s4">&quot;id&quot;</span><span class="s1">: </span><span class="s2">3</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">console.log(</span><span class="s4">&quot;Hello, World!&quot;</span><span class="s0">, </span><span class="s4">&quot;{'a': 1}&quot;</span><span class="s0">, </span><span class="s1">repr(console))</span>

    <span class="s1">console.print(</span>
        <span class="s1">{</span>
            <span class="s4">&quot;name&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s4">&quot;empty&quot;</span><span class="s1">: []</span><span class="s0">,</span>
            <span class="s4">&quot;quiz&quot;</span><span class="s1">: {</span>
                <span class="s4">&quot;sport&quot;</span><span class="s1">: {</span>
                    <span class="s4">&quot;answered&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                    <span class="s4">&quot;q1&quot;</span><span class="s1">: {</span>
                        <span class="s4">&quot;question&quot;</span><span class="s1">: </span><span class="s4">&quot;Which one is correct team name in NBA?&quot;</span><span class="s0">,</span>
                        <span class="s4">&quot;options&quot;</span><span class="s1">: [</span>
                            <span class="s4">&quot;New York Bulls&quot;</span><span class="s0">,</span>
                            <span class="s4">&quot;Los Angeles Kings&quot;</span><span class="s0">,</span>
                            <span class="s4">&quot;Golden State Warriors&quot;</span><span class="s0">,</span>
                            <span class="s4">&quot;Huston Rocket&quot;</span><span class="s0">,</span>
                        <span class="s1">]</span><span class="s0">,</span>
                        <span class="s4">&quot;answer&quot;</span><span class="s1">: </span><span class="s4">&quot;Huston Rocket&quot;</span><span class="s0">,</span>
                    <span class="s1">}</span><span class="s0">,</span>
                <span class="s1">}</span><span class="s0">,</span>
                <span class="s4">&quot;maths&quot;</span><span class="s1">: {</span>
                    <span class="s4">&quot;answered&quot;</span><span class="s1">: </span><span class="s0">False,</span>
                    <span class="s4">&quot;q1&quot;</span><span class="s1">: {</span>
                        <span class="s4">&quot;question&quot;</span><span class="s1">: </span><span class="s4">&quot;5 + 7 = ?&quot;</span><span class="s0">,</span>
                        <span class="s4">&quot;options&quot;</span><span class="s1">: [</span><span class="s2">10</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">13</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s4">&quot;answer&quot;</span><span class="s1">: </span><span class="s2">12</span><span class="s0">,</span>
                    <span class="s1">}</span><span class="s0">,</span>
                    <span class="s4">&quot;q2&quot;</span><span class="s1">: {</span>
                        <span class="s4">&quot;question&quot;</span><span class="s1">: </span><span class="s4">&quot;12 - 8 = ?&quot;</span><span class="s0">,</span>
                        <span class="s4">&quot;options&quot;</span><span class="s1">: [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s4">&quot;answer&quot;</span><span class="s1">: </span><span class="s2">4</span><span class="s0">,</span>
                    <span class="s1">}</span><span class="s0">,</span>
                <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
</pre>
</body>
</html>